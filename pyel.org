* todo
** built-in methods
| method           | list? | tuple? | str? | dict? | tests | notes |
|------------------+-------+--------+------+-------+-------+-------|
| append           | YES   | na     | na   | na    | YES   |       |
| count            | YES   | YES    | YES  | na    | YES   |       |
| extend           | YES   | na     | na   | na    | YES   |       |
| index            | YES   | YES    | YES  | na    | YES   |       |
| insert           | YES   | na     | na   | na    | YES   |       |
| pop              | YES   | na     | na   | YES   | YES   |       |
| remove           | YES   | na     | na   | na    | YES   |       |
| reverse          | YES   | na     | na   | na    | YES   |       |
| sort             |       | na     | na   | na    |       |       |
| clear            | na    | na     | na   |       |       |       |
| copy             | na    | na     | na   | YES   | YES   |       |
| fromkeys         | na    | na     | na   |       |       |       |
| get              | na    | na     | na   | YES   | YES   |       |
| items            | na    | na     | na   | YES   | YES   |       |
| keys             | na    | na     | na   | YES   | YES   |       |
| popitem          | na    | na     | na   | YES   | YES   |       |
| setdefault       | na    | na     | na   |       |       |       |
| update           | na    | na     | na   |       |       |       |
| values           | na    | na     | na   | YES   | YES   |       |
| zfill            | na    | na     |      | na    |       |       |
| upper            | na    | na     | YES  | YES   | YES   |       |
| translate        | na    | na     |      | na    |       |       |
| title            | na    | na     |      | na    |       |       |
| swapcase         | na    | na     |      | na    |       |       |
| strip            | na    | na     | YES  | YES   | YES   |       |
| startswith       | na    | na     |      | na    |       |       |
| splitlines       | na    | na     |      | na    |       |       |
| split            | na    | na     | YES  | YES   | YES   |       |
| rstrip           | na    | na     |      | na    |       |       |
| rsplit           | na    | na     |      | na    |       |       |
| rpartition       | na    | na     |      | na    |       |       |
| rjust            | na    | na     |      | na    |       |       |
| rindex           | na    | na     |      | na    |       |       |
| rfind            | na    | na     |      | na    |       |       |
| replace          | na    | na     |      | na    |       |       |
| partition        | na    | na     |      | na    |       |       |
| lstrip           | na    | na     |      | na    |       |       |
| lower            | na    | na     | YES  | YES   | YES   |       |
| ljust            | na    | na     |      | na    |       |       |
| join             | na    | na     | YES  | na    | YES   |       |
| isupper          | na    | na     |      | na    |       |       |
| istitle          | na    | na     |      | na    |       |       |
| isspace          | na    | na     |      | na    |       |       |
| isprintable      | na    | na     |      | na    |       |       |
| isnumeric        | na    | na     |      | na    |       |       |
| islower          | na    | na     |      | na    |       |       |
| isidentifier     | na    | na     |      | na    |       |       |
| isdigit          | na    | na     |      | na    |       |       |
| isdecimal        | na    | na     |      | na    |       |       |
| isalpha          | na    | na     |      | na    |       |       |
| isalnum          | na    | na     |      | na    |       |       |
| format_map       | na    | na     |      | na    |       |       |
| format           | na    | na     |      | na    |       |       |
| find             | na    | na     |      | na    |       |       |
| expandtabs       | na    | na     |      | na    |       |       |
| capitalize       | na    | na     |      | na    |       |       |
| center           | na    | na     |      | na    |       |       |
| encode           | na    | na     |      | na    |       |       |
| endswith         | na    | na     |      | na    |       |       |
| maketrans        | na    | na     |      | na    |       |       |
| __add__          |       |        |      | na    |       |       |
| __contains__     |       |        |      |       |       |       |
| __delitem__      |       | na     | na   |       |       |       |
| __eq__           |       | na     |      |       |       |       |
| __ge__           |       | na     |      |       |       |       |
| __getattribute__ |       |        |      |       |       |       |
| __getitem__      |       |        |      |       |       |       |
| __getnewargs__   | na    |        |      | na    |       |       |
| __hash__         |       |        |      |       |       |       |
| __gt__           |       |        |      |       |       |       |
| __iadd__         |       | na     | na   | na    |       |       |
| __imul__         |       | na     | na   | na    |       |       |
| __init__         |       |        |      |       |       |       |
| __iter__         |       |        |      |       |       |       |
| __le__           |       |        |      |       |       |       |
| __len__          |       |        |      |       |       |       |
| __lt__           |       |        |      |       |       |       |
| __mul__          |       |        |      | na    |       |       |
| __ne__           |       |        |      |       |       |       |
| __repr__         |       |        |      |       |       |       |
| __rmul__         |       |        |      | na    |       |       |
| __reversed__     |       | na     | na   | na    |       |       |
| __rmul__         |       |        |      | na    |       |       |
| __setitem__      |       | na     | na   |       |       |       |
| __sizeof__       |       |        |      |       |       |       |

** built-in functions
http://docs.python.org/2/library/functions.html

| function     | status | tests | notes                                    |
|--------------+--------+-------+------------------------------------------|
| abs          | x      |       |                                          |
| divmod       |        |       |                                          |
| input        | x      |       |                                          |
| open         |        |       |                                          |
| staticmethod |        |       |                                          |
| all          |        |       |                                          |
| enumerate    |        |       |                                          |
| int          |        |       |                                          |
| ord          | x      |       | strings > 1 char does not raise an error |
| str          |        |       |                                          |
| any          |        |       |                                          |
| eval         | x      |       |                                          |
| isinstance   | x      |       |                                          |
| pow          | -      |       | assumes numbers                          |
| sum          |        |       |                                          |
| basestring   |        |       |                                          |
| execfile     |        |       |                                          |
| issubclass   |        |       |                                          |
| print        | -      |       | does not call pyel str functions         |
| super        |        |       |                                          |
| bin          | x      |       |                                          |
| file         |        |       |                                          |
| iter         |        |       |                                          |
| property     |        |       |                                          |
| tuple        |        |       |                                          |
| bool         |        |       |                                          |
| filter       |        |       |                                          |
| len          | x      |       |                                          |
| range        | x      |       |                                          |
| type         |        |       |                                          |
| bytearray    |        |       |                                          |
| float        |        |       |                                          |
| list         | x      |       |                                          |
| raw_input    |        |       |                                          |
| unichr       |        |       |                                          |
| callable     |        |       |                                          |
| format       |        |       |                                          |
| locals       |        |       |                                          |
| reduce       |        |       |                                          |
| unicode      |        |       |                                          |
| chr          | x      |       |                                          |
| frozenset    |        |       |                                          |
| long         |        |       |                                          |
| reload       |        |       |                                          |
| vars         |        |       |                                          |
| classmethod  |        |       |                                          |
| getattr      | x      |       |                                          |
| map          | x      |       | ??? really equivalent?                   |
| repr         |        |       |                                          |
| xrange       |        |       |                                          |
| cmp          |        |       |                                          |
| globals      |        |       |                                          |
| max          |        |       |                                          |
| reversed     |        |       |                                          |
| zip          |        |       |                                          |
| compile      |        |       |                                          |
| hasattr      | x      |       |                                          |
| memoryview   |        |       |                                          |
| round        |        |       |                                          |
| __import__   |        |       |                                          |
| complex      |        |       |                                          |
| hash         |        |       |                                          |
| min          |        |       |                                          |
| set          |        |       |                                          |
| apply        |        |       |                                          |
| delattr      |        |       |                                          |
| help         |        |       |                                          |
| next         |        |       |                                          |
| setattr      |        |       |                                          |
| buffer       |        |       |                                          |
| dict         |        |       |                                          |
| hex          | x      |       |                                          |
| object       |        |       |                                          |
| slice        |        |       |                                          |
| coerce       |        |       |                                          |
| dir          |        |       |                                          |
| id           |        |       |                                          |
| oct          |        |       |                                          |
| sorted       |        |       |                                          |
| intern       |        |       |                                          |
| exit         | x      | no    | not of type Quitter, just a function     |

* documentation
TODO: how to export a heading as pdf or into a seporate file?

TODO: update most of this. tranforms have changed
** type switches
 pyel-switch forms are inserted in a backquoted form so an ',' unquote
 may be used. DO NOT UNQUOTE THE ARGUMENTS, they will be replaced later

** from py ast to e-lisp transform
#+Begin_SRC emacs-lisp
  ;;First, get the python ast:
  (py-ast "(a,b)")
  "Module(body=[Expr(value=Tuple(elts=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], ctx=Load()))])
  "
  
  ;;Second create any newly needed python AST interpretor.
  ;; Here we need Tuple(elts,ctx)
  
  def Tuple(elts, ctx):
      return l_str(["tuple ", ll_str(elts), ctx])
  
  ;;Third, define a tranform to convert the function to lisp
  (def-transform tuple pyel ()
    (lambda (elts ctx) ;;Ignoring ctx for now
      (concat "["
              (mapconcat 'transform elts " ")
              "]")))
  
  
  ;;Forth, create tests. Evaluate the expresstion, the test are sent to the kill ring
  (pyel-create-tests 'Tuple
                     "()"
                     "(a, b)"
                     "(a, (b, (c,d)))"
                     "((((((((a))))))))")
#+END_SRC
** ways to define new transforms
TODO:
 how to define a macro transform

*** change a function name
Example:
#+Begin_SRC emacs-lisp
(pyel-translate-function-name 'range 'py-range)
(pyel-translate-function-name 'map 'mapcar)o
#+END_SRC
*** change a variable name
Example:
#+Begin_SRC emacs-lisp
(pyel-translate-variable-name 'None 'nil)
#+END_SRC
*** define a general translation
Example:
#+Begin_SRC emacs-lisp
(def-transform assert pyel ()
    (lambda (test msg)
      `(assert ,(transform test) t ,(transform msg))))
#+END_SRC

*** define a method translation
$var replaces var with name of the original var
   (expands to ,var in the macro definition)
 other parameter references are evaluated and assigned to tmp variables
#+Begin_SRC emacs-lisp
(pyel-method-transform append (obj thing)
                  (list _) -> (setq $obj (append obj (list thing)))
                  (_ _)    -> (append obj thing))
#+END_SRC

*** define a function translation
#+Begin_SRC emacs-lisp
  (pyel-func-transform len (thing)
                       (object) -> (__len__ ,thing)
                       (_)      -> (length ,thing))
#+END_SRC
*** type switching transforms
  (pyel-dispatch-func ** (l r) ;;pow
                    (number number) -> (expt l r)
                    (object _ )
                    (_ object) -> (--pow-- l r))

*** declare a name to be a macro
(pyel-declare-macro "save_excursion")
** writing faster code
*** large difference
*** small difference
prevent pyel from converting *varargs to a vector. Instead manipulate it in python as if it were a list instead of a tuple like it normally is.
put the following line in your config:
  (setq pyel-use-list-for-varargs t)
  ==> NO! ALL CHANGES TO CODE TRANSFORMS SHOULD BE INDECATED IN THE PYTHON SOURCE

* headers
** main
#+Begin_SRC emacs-lisp :tangle pyel.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** transforms
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** py-lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  # This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC

* main
header
** require
#+Begin_SRC emacs-lisp :tangle pyel.el
  (add-to-list 'load-path "~/programming/pyel/")
  (add-to-list 'load-path "~/programming/code-transformer/")
  (require 'eieio)
  (require 'cl)
  ;;other requires are at the end
#+END_SRC
** main
#+Begin_SRC emacs-lisp :tangle pyel.el
;; This is a tangled file  -- DO NOT HAND-EDIT --
;;PYEL -> translate PYthon to Emacs Lisp
#+END_SRC

main
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defun mpp (code)
    (let ((pp (pp-to-string code)))
      (insert "\n" pp)))
  
  ;;TODO: more robust checking, return type of error as well
  (defun pyel-is-error (code)
    "return the line of the error in CODE, else nil"
    (let ((line))
      (if (string-match "^Traceback" code)
          (with-temp-buffer
            (insert code)
            (goto-char (point-max))
            (if (re-search-backward "line \\([0-9]+\\)")
                (setq line (match-string 1)))))
      ;;TODO: why is this the actual line number...it should be relative the a bunch of code it's appended to ...
      (and line (string-to-number line))))
  
  (defvar pyel-transform-status nil
    "indicate status (success/fail) of last pyel transform
  status types:
  nil for no error
  ('python ast transform error'  <line number>)
  ")
  
  (defvar pyel-error-string "PYEL ERROR"
    "string returned by `pyel' when it failed to transform")
  
  (defun pyel-py-ast-file-name ()
    "return the full file name of py-ast.el"
    (file-path-concat pyel-directory "py-ast.py"))
  
  (defun pyel (python &optional no-line-and-col-nums include-defuns py-ast-only)
    "translate PYTHON into Emacs Lisp.
  PYTHON is a string.
  include line and column nums in output unless NO-LINE-AND-COL-NUMS is non-nil
  If PY-AST-ONLY, return the un-evaled ast.
  If INCLUDE-DEFUNS, include the list of pyel defined functions in the output
    this is ignored if PY-AST-ONLY is non-nil"
    (assert (eq lexical-binding nil) "pyel requires dynamic scoping")
  
    (setq pyel-marked-ast-pieces nil)
    (setq pyel-transform-status nil) ;;so far so good...
  
    (let* (;;Q general way of replacing backslashes?
           (python (replace-regexp-in-string "\"" "\\\\\"" python))
                                          ;(python (replace-regexp-in-string "\n" "\\\\n" python nil :literal))
  
           ;; (pyel "x = 'x\n'")
           (py-ast "")
           (el-code "")
           (current-transform-table (get-transform-table 'pyel))
           (python (with-temp-buffer
                     (insert python)
                     (pyel-preprocess-buffer2)
                     (buffer-string)))
           (pyel-context nil)
           line ret
           )
  
      ;;?? setting the mark?
      (with-temp-buffer
        ;;    (find-file file)
        ;;    (erase-buffer)
        (insert-file-contents-literally (pyel-py-ast-file-name))
        (goto-char (point-max))
        (insert "\n")
        (setq line (line-number-at-pos))
        (insert (format "print(eval(ast.dump(ast.parse(\"\"\"%s\"\"\")%s)))"
                        python
                        (if no-line-and-col-nums "" ",include_attributes=True")))
        (write-region
         nil
         nil
         pyel-tmp-file nil 'silent))
  
      (setq py-ast (shell-command-to-string (format "python3 %s" pyel-tmp-file)))
      (setq _x py-ast)
      (if (setq py-error (pyel-is-error py-ast))
          (progn
            (setq pyel-python-error-line py-error)
            pyel-error-string)
        ;;else: no error
        (if py-ast-only
            py-ast
          ;;      (pyel-do-splices (transform (read py-ast))))))
          ;;read can only return one sexp so we need to put it in a progn or something
          ;;similar
  
          (setq ret (pyel-do-splices (if include-defuns
                                         (list '@ (cons '@ pyel-function-definitions)
                                                  (transform (read (format "(@ %s)" py-ast))))
                                       (transform (read  (format "(@ %s)" py-ast))))))
          ;;TODO: this is a temp solution for convenience
          (mapc 'eval pyel-function-definitions)
          ret
          ))))
  
  (defun pyel-buffer-to-string (&optional ast-only)
    "transform python in current buffer and return a string"
    ;;THIS DOES NOT RETURN A STRING!
    (pyel (buffer-string) ast-only))
  
  (defvar pyel-pp-function 'pp-to-string
    "function that pretty prints pyel e-lisp code")
  
  (defun pyel-buffer (&optional out-buff)
    "transform python in current buffer and display in OUT-BUFF,
  OUT-BUFF defaults to *pyel-output*"
    (interactive)
    (let ((out (pyel-buffer-to-string)))
      (switch-to-buffer-other-window "*pyel-output*")
      (erase-buffer)
      (insert (funcall 'pyel-pp-function out))
      (emacs-lisp-mode)))
  
  (defun pyel-transform-ast (ast &optional no-splice)
    "transform a python AST to Emacs Lisp, AST must be a string
  AST can be generated by `pyel' with (pyel py-string t)"
    (with-transform-table 'pyel
                          (let ((code (transform (read  (format "(@ %s)" ast)))))
                            (if no-splice
                                code
                              (pyel-do-splices code)))))
  
  (defun pyel-file-ast (file-name)
    "return the ast from .py file FILE-NAME"
    )
  
  (defmacro pyel-with-known-types (known-types &rest code)
    "translate CODE while faking the known types"
    `(flet ((pyel-get-possible-types
             (&rest args)
             (mapcar* (lambda (arg type) (cons arg type))
                      args ,known-types)))
  
       (pyel ,@code)))
  
  (defun py-ast (code &optional pp include-attributes python2)
    "Return the python abstract syntax tree for python CODE
  useing python3 unless PYTHON2 is non-nil"
    (let ((py-ast "")
          (el-code "")
          ret)
  
      (with-temp-buffer
        (insert "import ast" "\n")
        (insert (format "print(ast.dump(ast.parse(\"\"\"%s\"\"\")%s))"
                        code
                        (if include-attributes ",include_attributes=True" "")))
        (write-region nil nil pyel-tmp-file nil 'silent))
  
      (setq ret (shell-command-to-string (format "python%s %s"
                                                 (if python2 "" "3")
                                                 pyel-tmp-file)))
      (if pp
          (mapconcat 'identity (split-string ret ",") ",\n")
        ret)))
  
  ;;'(a (@ b (c)))) => (a b (c))
  ;;'(a (@ b c)))   => (a b c)
  ;;'(@ a b c) => (progn a b c)
  ;;'(@ (a b)) = > (a b)
  ;;'(a (@) b) = > (a b)
  
  (defun pyel-do-splices (code)
    (if (listp code)
        (let (c)
          (if (eq (car code) '@) ;;special case: outer most list
              (if (> (length code) 2)
                  (pyel-do-splices `(progn ,code))
                (pyel-do-splices (cadr code)))
            (let ((ncode nil))
              (while code
                (setq c (pop code))
                (if (listp c)
                    (if (equal (car c) '@)
                        (setq ncode (append (reverse (pyel-do-splices (cdr c))) ncode))
                      (push (pyel-do-splices c) ncode))
                  (push c ncode)))
              (if (listp ncode) (reverse ncode) ncode))))
      code))
  
  (defun pyel-reload ()
    (interactive)
    (pyel-reset)
    (dolist (f '(pyel
                 pyel-tests
                 pyel-transforms
                 pyel-mode
                 pyel-pp
                 pyel-preprocessor
                 pyel-tests-generated
                 py-lib
                 transformer))
      (setq features (remove f features)))
    (require 'pyel))
  
  (defun pyel-reset()
    "reset internal variables"
    (setq pyel-method-name-arg-signature (make-hash-table :test 'eq)
          pyel-function-definitions nil
          pyel-defined-functions nil
          pyel-method-transforms nil
          pyel-context nil))
  
  (defvar pyel-method-name-format-string "_%s-method%s"
    "format string for the method transform names
  It must accept two args, the name of the method
  and its arg signature")
  
  (defun pyel-method-transform-name (method-name &optional arglist)
    "Return the name of the temlate that transform the method METHOD-NAME.
      template names are modified to avoid potential conflict with other templates
    the arglist must be placed in a list before passing so that the code can
     tell if the arglist is empty or not provided. 
    ARGLIST is used to generate a name that is unique to that arglist signature"
    (assert (and (listp arglist) (listp (car arglist)))
            "Invalid arglist. Expected a list of a list")
    (let* ((signature (if arglist (pyel-arglist-signature (car arglist)) "_"))
           (name (format pyel-method-name-format-string
                         (symbol-name method-name) signature)))
      (if arglist
          (assert (equal (pyel-extract-arg-descriptor signature)
                         (pyel-arg-descriptor (car arglist)))
                  "Invalid method name"))
      (intern name)))
  
  (defun pyel-func-transform-name (func-name)
    "like `pyel-method-transform-name' for functions"
    (intern (format "_%s-function_" (symbol-name func-name))))
  
  (defmacro push-back (val place)
    "Add VAL to the end of the sequence stored in PLACE. Return the new
  value."
    `(setq ,place (append ,place (list ,val))))
  
  (defun pyel-translate-function-name (name new-name)
    "translate python NAME to e-lisp NEW-NAME"
    (push (list name new-name) pyel-function-name-translations))
  
  (defun pyel-translate-variable-name (name new-name)
    "translate python  NAME to e-lisp NEW-NAME"
    (push (list name new-name) pyel-variable-name-translations))
  
  (defun pyel-not-implemented (message)
    "signify that a feature is not implemented"
    ;;TODO
    (message message) ;;tmp
    )
  
  (defmacro insert-at (list nth value)
    "insert VALUE at NTH index in LIST"
    `(setq ,list (append (subseq ,list 0 ,nth)
                         (list ,value)
                         (subseq ,list  ,nth))))
  
  (defun list-to-vector (list)
    (let ((v (make-vector (length list) nil))
          (rest list)
          (i 0))
      (while rest
        (aset v i (car rest))
        (setq rest (cdr rest)
              i (1+ i)))
      v))
  
  (defun pyel-replace-in-thing (from to thing)
    "replace character FROM to TO in THING
  THING may be a symbol, string or list"
    (cond
     ((stringp thing)
      (replace-regexp-in-string from to  thing))
     ((symbolp thing)
      (intern (replace-regexp-in-string from to  (symbol-name thing))))
     ((listp thing) (mapcar (lambda (x) (pyel-replace-in-thing from to x)) thing))
     (t (error "invalid thing"))))
  
  (defun _to- (thing)
    (pyel-replace-in-thing "_" "-" thing))
  (defun -to_ (thing)
    (pyel-replace-in-thing "-" "_" thing))
  
  (defun pyel-change-ctx (form ctx)
    "change ctx of form to CTX"
    (let ((type (and (listp form) (car form))))
      (cond ((eq type 'name)
             (list (car form) (cadr form) (list 'quote ctx)))
            ;;TODO: attribute and other forms (if needed)
            (t form))))
  
  (defun pyel-make-ast (type &rest args)
    "Generate pyhon ast.
  This is used when the ast form is needed by a transform that is manually
   called from another transform"
    (flet ((assert_n_args (type expect have)
                          (assert (= expect have)
                                  (format "pyel-make-ast -- ast type '%s'expects %s args. received %s args" type expect have)))
           (correct_ctx (ctx)
                        (if (symbolp ctx)
                            (pyel-make-ast ctx)
                          ctx))
           (correct_to_string (name)
                              (if (stringp name)
                                  name
                                (if (symbolp name)
                                    (symbol-name name)
                                  (error "invalid type for 'name'")))))
  
      ;;TODO: should have seporate functions to check
      ;;      the validity of the ast instead of having
      ;;      the correction functions do it
      (case type
  
        (subscript ;;args: value slice ctx
         (assert_n_args 'subscript 3 (length args))
  
         (let ((ctx (correct_ctx (car (last args)))))
           (list 'subscript (car args) (cadr args) ctx)))
  
        (name ;;args: name ctx
         (assert_n_args 'name 2 (length args))
         (let* ((name (correct_to_string (car args)))
  
                (ctx (correct_ctx (car (last args)))))
  
           (list 'name name ctx)))
        (load
         '(quote load))
        (store
         '(quote store)))))
  
  (defmacro macrop (sym)
    (if (boundp sym)
        (list 'macrop-1 sym)
      `(macrop-1 (quote ,sym))))
  
  (defun macrop-1 (function)
    ;;this is mostly taken from `describe-function-1'
    (let* ((advised (and (symbolp function) (featurep 'advice)
                         (ad-get-advice-info function)))
           ;; If the function is advised, use the symbol that has the
           ;; real definition, if that symbol is already set up.
           (real-function
            (or (and advised
                     (let ((origname (cdr (assq 'origname advised))))
                       (and (fboundp origname) origname)))
                function))
           ;; Get the real definition.
           (def (if (symbolp real-function)
                    (symbol-function real-function)
                  function)))
      (eq (car-safe def) 'macro)))
  
  (defun callable-p (object)
    (if (symbolp object)
        (or (fboundp object)
            (functionp object)) ;;necessary?
      (functionp object)))
  
  (defun pyel-split-list (lst sym)
    "split list LST into two sub-lists at separated by SYM
    The return value is the two sub-lists consed together"
    (let ((current (not sym))
          first)
      
      (while (and (not (eq current sym))
                  lst)
        (setq current (pop lst))
        (push current first)
        )
      
      (cons (reverse (if (eq (car first) sym) (cdr first) first)) lst)))
  
  
  (defun pyel-eval-last-sexp-1-function (eval-last-sexp-arg-internal)
    "Evaluate sexp before point; print value in minibuffer.
  With argument, print output into current buffer.
  
  This function is redefined to print python objects in a
  reasonable manner. The origional definition has been stored
  in `pyel-orig-eval-last-sexp-1'"
    (let ((standard-output (if eval-last-sexp-arg-internal (current-buffer) t))
          (val (eval (eval-sexp-add-defvars (preceding-sexp)) lexical-binding)))
      ;; Setup the lexical environment if lexical-binding is enabled.
      (if (and pyel-object-prettyprint
               (py-object-p val))
          (setq val (pyel-repr val)))
      (eval-last-sexp-print-value val)))
  
  (fset 'pyel-orig-eval-last-sexp-1 'eval-last-sexp-1)
  (fset 'eval-last-sexp-1 'pyel-eval-last-sexp-1-function)
  
  (defvar pyel-object-prettyprint t
    "if non-nil, objects will be printed with their pyel repr value
  during interactive emacs-lisp sessions where possible")
          
  (defun pyel-toggle-object-prettyprint ()
    (interactive)
    (setq pyel-object-prettyprint (not pyel-object-prettyprint)))
  
  (defun pyel-get-generated-function (name)
    "return the generated function/macro definition for NAME"
    (get-matching-item pyel-function-definitions
                       (lambda (x) (eq (cadr x) name))))
  
  (defun pyel-strip-leading-nil (list)
    "remove all nil items from the front of LIST until the first non-nil item"
    (while (and (not (null list))
                (not (car list)))
      (setq list (cdr list)))
    list)
  
  (defun pyel-strip-trailing-nil (list)
    "remove all nil items from the back of LIST until the last non-nil item"
    (setq list (reverse list))
    (while (and (not (null list))
                (not (car list)))
      (setq list (cdr list)))
    (reverse list))
#+END_SRC
** variables
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defvar pyel-directory ""
    "Path to pyel files. must include py-ast.py, pyel.el etc")
  
  (defmacro vfunction-p (f)
    `(and (boundp ',f)
          (functionp ,f)))
  
  (defmacro pyel-empty-list-p (list)
    `(eq ,list 'py-empty-list))
  
  (set (defvar pyel-type-test-funcs nil
         "alist of types used in pyel-call-transform for the switch-type
          and the function used to test for that type")
       '((string stringp)
         (number numberp)
         (integer integerp)
         (int integerp)
         (float floatp)
         (vector vectorp)
         (empty-list pyel-empty-list-p)
         (list listp)
         (cons consp)
         (hash hash-table-p)
         (hash-table hash-table-p)
         (symbol symbolp)
         (array arrayp)
         ;;         (object object-p)
         (class py-class-p)
         (instance py-instance-p)
         (object py-object-p)
         (function functionp)
         (func fboundp)
         (vfunction vfunction-p)
         (vfunc vfunction-p)
         (callable callable-p)))
  
  (defvar pyel-negated-function-tests nil
    "A list of automatically created negated functions from `pyel-type-test-funcs'
    stored here just for convenient inspection")
  
  ;;create negated test functions
  (let (new func fname)
    (setq pyel-negated-function-tests nil)
    (mapc (lambda (x)
            (setq name (cadr x)
                  !name (intern (concat "!" (symbol-name name)))
                  func `(defsubst ,!name (x) (not (,name x))))
            (add-to-list 'pyel-negated-function-tests func)
            (eval func)
            (push (list (intern (concat "!" (symbol-name (car x))))
                        !name)
                  new))
          pyel-type-test-funcs)
    (setq pyel-type-test-funcs (append pyel-type-test-funcs new)))
  
  (defvar pyel-defined-classes nil
    "list of call class names defined by pyel")
  
  (defvar pyel-defined-functions nil
    "list of some functions defined pyel
        used by some templates to determine if a needed function has been defined yet")
  
  (defvar pyel-function-definitions nil
    "used to store function definitions created by pyel, not the user.")
  
  (defvar pyel-replace-args nil
    "if non-nil, pyel-do-call-transform will replace the arg symbols with their
        value, used if the code is to be inlined
        TODO: the option to replace the args should probably be obsoletede")
  
  (defvar pyel-unique-obj-names nil
    "if non-nil, uniquely name object instantces")
  
  (defvar pyel-context-groups nil ;;TODO: still used?
    "groups of contexts that cannot exist at the same time.
      `context-p' will stop at the first one in the list,")
  
  (setq pyel-context-groups
        '((assign-target assign-value)))
  
  (defvar pyel-function-name-translations nil
    "alist of function name translations, python->e-lisp.
  
      Entries in `pyel-function-name-translations' are applied before
      checking for function transforms.
      If a translation len->length is defined then the function transform for
      'len' will not be detected because the name is now 'length'
      ")
  
  (defvar pyel-variable-name-translations nil
    "alist of variable name translations, python->e-lisp.")
  
  (setq pyel-function-name-translations `(
  
                                          ))
  ;;TODO: list, vector, etc
  ;;      map?
  
  (setq pyel-variable-name-translations '((True t)
                                          (False nil)
                                          (None nil)))
  
  (defvar pyel-method-transforms nil
    "List of names of methods for which a transform has been defined
      For internal use only--do not modify by hand"
    )
  
  (defvar pyel-func-transforms nil
    "list of function names that have transforms defined for them")
  
  (defconst pyel-nothing '(@)
    "value to return from a function/transform when it should
      not contribute to the output code")
  
  (defconst pyel-python-version "3.2.3"
    "python interpreter version whose ast pyel is written for")
  
  (defvar test-variable-values nil
    "variables values for running tests")
  
  (setq test-variable-values
        '((pyel-defined-classes nil)
          (pyel-function-definitions nil)
          (pyel-defined-functions nil)
          (pyel-obj-counter 0)
          (pyel-unique-obj-names nil)
          (pyel-fully-functional-functions nil)
          ;;(pyel-method-transforms nil)
          ;;(pyel-func-transforms nil)
          (pyel-marker-counter 0)))
  
  (defvar pyel-marker-counter 0)
  
  (defvar pyel-tmp-file  "/tmp/pyel-ast.py"
    "Name of temp file to use for AST generation")
  
  (defvar pyel-interactive nil
    "non-nil during interactive session translation and evaluation")
#+END_SRC
** syntax output variables
variables that effect the form of the output code
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defvar pyel-default--init--method
    "(defmethod --init-- ((self %s))
       \"Default initializer\"
      )"

    "default initializer for pyel objects.")

  (defvar pyel-use-list-for-varargs nil
    "Determines if *varargs will be passed to function as a list or a vector,
    non-nil for list, otherwise vector.
    To be like python (vectors), this should be nil
    To be consistent with Emacs-Lisp (lists), this should be t.
       On the python side, this means that *varargs is a list instead of a tuple")
#+End_SRC
** pyel-block
This will have to be removed after the code is generated
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defmacro pyel-block (&rest code)
    `(progn ,@ code))
#+END_SRC
** context
#+Begin_SRC emacs-lisp :tangle pyel.el
  ;;TODO: this should be generalized and added to the transform code
  (defvar pyel-context nil
    "list of current expansion contexts")
  
  (defmacro using-context (context &rest code)
    `(progn
       (push ',context pyel-context)
       (let (ret)
         (condition-case err
             (setq ret (progn ,@code))
           (error (pop pyel-context)
                  (error (format "using-context: %s" err))))
         (pop pyel-context)
         ret)))
  
  (def-edebug-spec using-context (symbolp &rest form))
  
  (defmacro remove-context (context &rest code)
    "remove CONTEXT and translate CODE, then restore context"
    `(let ((pyel-context (remove ',context pyel-context)))
       ,@code))
  (def-edebug-spec remove-context (symbolp &rest form))
  
  (defmacro context-switch (&rest forms)
    `(cond ,@(mapcar (lambda (x)
                       `(,(let ((context (car x)))
                            (if (eq context t) t
                              `(member ',context pyel-context))) ,@(cdr x)))
                     forms)))
  
  (defun get-context-group (context)
    (let ((groups pyel-context-groups)
          (found nil)
          group)
      (while groups
        (setq group (car groups)
              groups (cdr groups))
        (dolist (g group)
          (when (equal g context)
            (setq found group
                  groups nil))))
      found))
  
  ;; (defun context-p (context)
  ;;   (member context pyel-context))
  (defun context-p (context)
      ;;;;TODO: the extra features that this provides is probably not being used anywere...
    (let ((group (get-context-group context))
          (cont pyel-context)
          (ret nil)
          c)
      (while cont
        (setq c (car cont)
              cont (cdr cont))
        ;;if the context is in a group only return t if it is the first one in pyel-context
        (if (member c group)
            (setq ret (equal c context)
                  cont nil)
          (when (equal c context)
            (setq ret t
                  cont nil))))
      ret))
  
  (defun context-depth (context)
    "get the depth of CONTEXT in `pyel-context'"
    ;;TODO:
    )
#+end_src
** type inference
#+Begin_SRC emacs-lisp :tangle pyel.el
  ;;this is all temp for testing
  (setq known-types '((number object ) (number string)))
  
  ;;prevents error: "Wrong type argument: listp, string"
  ;;TODO: this is a bit of a mess now. types 'func' and 'function' in type
  ;;transforms result in different tests but func/function still kind of mean the
  ;;same thing when it comes to python. if func is known type, function should
  ;;also be know. need some kind of an alias mechanism
  (setq known-types
        '((number list vector string object hash function func symbol vfunc class instance)
          (number list vector string object hash function func symbol vfunc class instance)
          (number list vector string object hash function func symbol vfunc class instance)
          (number list vector string object hash function func symbol vfunc class instance)
          (number list vector string object hash function func symbol vfunc class instance)
          (number list vector string object hash function func symbol vfunc class instance)
          (number list vector string object hash function func symbol vfunc class instance)
          (number list vector string object hash function func symbol vfunc class instance)
          (number list vector string object hash function func symbol vfunc class instance)
          (number list vector string object hash function func symbol vfunc class instance)))
  (push (list 'known-types known-types) test-variable-values)
  
  (defun pyel-get-possible-types (&rest args)
    "return a list in the form (arg types).
    The car is the argument and the cdr is a list of possible types"
  
    ;;FOR TESTING
    (let ((types (if (>= (length known-types) (length args))
                     known-types
                   (append known-types '(string number list vector integer float))))
          (args (filter (lambda (x) (not (or (eq x '&optional)
                                             (eq x '&rest)))) args)))
  
      (mapcar* (lambda (arg type) (cons arg type))
               args types)))
#+end_src
** type dispatching transforms
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defun pyel-filter-non-args(args)
    "remove '&optional' and '&rest' from ARGS list"
    (filter (lambda (x) (not (or (eq x '&optional)
                                 (eq x '&rest))))
            args))
  
  (defmacro pyel-dispatch-func (name args &rest type-switches)
    "Define a transform that creates a runtime function that
  dispatches on argument type as defined by TYPE-SWITCHES.
  The transform will have the same NAME and ARGS and must be called with a
  function like `call-transform', it will return a call to
  the function it creates.
  After the resulting transform is called, it adds the name of the
  created function in `pyel-defined-functions' and adds the function 
  definition to `pyel-function-definitions'
  
  Use `pyel-func-transform' to define transforms for functions that
  will be automatically called.
  
  NOTE: if the name of the function to be created is already in
   `pyel-defined-functions', the function will not be updated
  "
    ;;temp solution: does not check types etc
    (let* ((striped-args (mapcar 'strip_ args))
           (args-just-vars (pyel-filter-non-args striped-args))
           (rest-arg (if (eq (car (last striped-args 2)) '&rest)
                         (car (last striped-args)) nil)))
  
      `(def-transform ,name pyel ()
         (lambda ,striped-args
           (let ((fsym ',(intern (concat "pyel-" (symbol-name name) "")))
                 (body (pyel-do-call-transform (pyel-get-possible-types
                                                ,@args-just-vars)
                                               ',args
                                               ',type-switches))) 
             (unless (member fsym pyel-defined-functions)
               (push (list 'defmacro fsym ',striped-args
                           body)
                     pyel-function-definitions)
               (push fsym pyel-defined-functions)
               (fset fsym (lambda () nil)))
             (cons fsym ,(if rest-arg
                             `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
                           (cons 'list args-just-vars))))))))
  
  (defmacro pyel-method-transform (name args &rest type-switches)
    "Defines a transform for methods that dispatches on NAME and ARG length.
  The syntax and the function creation is the same as with `pyel-dispatch-func'.
  These transforms are automatically called for methods during translation time.
  The transform will be dispatched on NAME and the possible number
  of arguments that ARGS allows.
  During translation time, if no transform is found for a method call that
  matches NAME and has the proper arg length then no transform will be called."
    (add-to-list 'pyel-method-transforms name)
  
    ;;temp solution: does not check types etc
    (let* ((striped-args (mapcar 'strip_ args))
           (args-just-vars (pyel-filter-non-args striped-args))
           (rest-arg (if (eq (car (last striped-args 2)) '&rest)
                         (car (last striped-args)) nil))
           (fsym (intern (format "pyel-%s-method%s"
                                 (symbol-name name)
                                 (pyel-arglist-signature args))))
           (transform-name (pyel-method-transform-name name (list args))))
  
      (pyel-add-method-name-sig name args)
      
      `(def-transform ,transform-name pyel ()
         (lambda ,striped-args
           (let ((body (pyel-do-call-transform (pyel-get-possible-types
                                                ,@args-just-vars)
                                               ',args
                                               ',type-switches))) 
  
             (unless (member ',fsym pyel-defined-functions)
               (push (list 'defmacro ',fsym ',striped-args
                           body)
                     pyel-function-definitions)
               (push ',fsym pyel-defined-functions)
               (fset ',fsym (lambda () nil)))
             (cons ',fsym ,(if rest-arg
                               `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
                             (cons 'list args-just-vars))))))))
  
  (defmacro pyel-func-transform (name args &rest type-switches)
    "Define a transform for function calls.
  This is just like `pyel-method-transform' except that the
  ARG signature has no effect on the transform dispatch"
    (add-to-list 'pyel-func-transforms name)
    ;;TODO: should name be modified to avoid conflicts ?
    
    (let* ((striped-args (mapcar 'strip_ args))
           (args-just-vars (pyel-filter-non-args striped-args))
           (rest-arg (if (eq (car (last striped-args 2)) '&rest)
                         (car (last striped-args)) nil))
           (fsym (intern (concat "pyel-" (symbol-name name) "-function"))))
      `(def-transform ,(pyel-func-transform-name name) pyel ()
         (lambda ,striped-args
           (let ((body (pyel-do-call-transform (pyel-get-possible-types
                                                ,@args-just-vars)
                                               ',args
                                               ',type-switches)))
             (unless (member ',fsym pyel-defined-functions)
               (push (list 'defmacro ',fsym ',striped-args
                           body)
                     pyel-function-definitions)
               (push ',fsym pyel-defined-functions)
               (fset ',fsym (lambda () nil)))
             (cons ',fsym ,(if rest-arg
                               `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
                             (cons 'list args-just-vars))))))))
  
  (defvar pyel-func-transforms2 nil
    "list of functions whose translations are defined
  with the macro `pyel-define-function-translation'")
  
  (defmacro pyel-define-function-translation (name &rest body)
    "BODY will form the body of a function that is called during transform time
  to tranlate a call to NAME, variables 'args' and 'kwargs'  are available at
  this point. 'args' will be a list and 'kwargs will be an alist
  This is called at the same time `pyel-func-transform' would be called"
    (add-to-list 'pyel-func-transforms2 name)
  
    `(def-transform ,(pyel-func-transform-name name) pyel ()
       (lambda (args kwargs)
         ,@body
         )))
  
  ;;TODO: this should be more general to allow for things like subscript to use it
  
  (defmacro pyel-def-funcall (name args &rest type-switches)
    "Define how to call the function NAME.
        NAME is a function that is called differently based on its argument types.
        An attempt will be made to test the least possible number of types.
  
        This defines a transforms in the pyel transform table with NAME and ARGS"
    `(def-transform ,name pyel ()
       (lambda ,args
         (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                 ',args
                                 ',type-switches))))
  
  ;;TODO: rename pyel-def-funcall -> pyel-def-type-transform
  (defmacro pyel-def-type-transform (name args &rest type-switches)
    "Define a transform NAME that produces code based on the types of ARGS
      TYPE-SWITCHES
  
      This defines a transforms in the pyel transform table with NAME and ARGS"
    `(def-transform ,name pyel ()
       (lambda ,args
         (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                 ',args
                                 ',type-switches))))
  
  ;; (defmacro pyel-def-call-func (name args &rest type-switches)
  ;;   "like `pyel-def-call-template' except that it generates a macro that
  ;; is called directly, because of this NAME must be unique"
  ;;   `(defun ,name ,args
  ;;      ;;   (let (,(mapcar (lambda (arg) `(,arg ',arg)) args))
  ;;      (pyel-do-call-transform (pyel-get-possible-types ,@args)
  ;;                              ',args
  ;;                              ',type-switches)))
  
  (defun pyel-expand-type-switch (type-switch)
    "expands the types switch form to a list of cond clauses"
    (flet ((helper (arg form)
                   (let ((type (car form))
                         (varlist (cadr form))
                         mod types ret and-or)
                     (if (consp type)
                         (progn
                           ;;TODO: this can never be 'and'
                           (setq and-or (car type))
                           (dolist (tp (cdr type))
                             (push `((,arg ,tp) ,varlist) ret))
                           `(,and-or ,@(reverse ret)))
                       `((,arg ,type) ,varlist))))
           (expander (type-switch)
  
                     (let ((args (car type-switch))
                           (forms (cdr type-switch))
                           and-or ret inner tmp tests)
                       (if (consp args)
                           (progn
                             (setq and-or (car args)) ;;TODO: verify and/or
                             (if (eq and-or 'and)
                                 (dolist (form forms)
                                   (setq tests nil)
                                   (dolist (arg (cdr args))
                                     (push (car (helper arg form)) tests))
                                   (push `(and ,(reverse tests) ,(cadr form)) ret))
                               ;;else == or
                               (dolist (form forms)
                                 (dolist (arg (cdr args))
                                   (setq tmp (helper arg form))
                                   (if (equal (car tmp) 'or)
                                       (dolist (x (cdr tmp))
                                         (push x ret))
                                     (push (helper arg form) ret))))))
  
                         ;;else single arg
                         (dolist (form forms)
                           (setq tmp (helper args form))
                           (if (equal (car tmp) 'or)
                               (dolist (x (cdr tmp))
                                 (push x ret))
                             (push tmp ret))))
                       (reverse ret))))
      (let ((ret nil))
        (dolist (ts type-switch)
          (dolist (e (expander ts))
            (push e ret)))
        (reverse ret))))
  
  ;;TODO: fix bug with  `pyel-expand-type-switch-2'
  ;;      the arg pattern (x x) should not expand unless
  ;;      x is a possible type of both args
  
  (defun pyel-expand-type-switch-2 (arglist patterns)
    "has output identical to `pyel-expand-type-switch' just translates
        different syntax"
    (let ((group nil)
          (groups nil)
          (ngroups nil)
          (ret nil)
          code)
  
      ;;stage1: collect into groups
      (while patterns
        (setq p (pop patterns))
  
        (if (not (eq p '->))
            (push-back p group)
          (push-back (pop patterns) group)
          (push-back group groups)
          (setq group nil)))
  
      (dolist (g groups)
        (let* ((g (reverse g))
               (code (car g))
               (g (cdr g))
               ;;      (param-types (make-vector (length (car g)) nil))
               type)
  
          (dolist (arg-pattern (reverse g)) ;;for each arg pattern
            (setq group-patterns nil)
            (dotimes (i (length arg-pattern)) ;;for each type or '_
              (setq type (nth i arg-pattern))
              (if  (not (eq type '_))
                  (push `((,(nth i arglist) ,type) ,code) group-patterns)))
            (if (null group-patterns) ;;all types where _
                (setq ret (append ret (list (list t code))))
              (if (= (length group-patterns) 1)
                  (setq ret (append ret (reverse group-patterns)))
                (setq ret (append ret (list (cons 'and
                                                  (list (mapcar 'car
                                                                (reverse group-patterns))
                                                        code))))))))))
      ret))
  
  (defun pyel-remove-nil (list)
    "remove all nil items from LIST"
    (let ((new nil))
      (dolist (e list)
        (when e
          (setq new (cons e new))))
      (reverse new)))
  
  (defun pyel-do-call-transform (possible-types args type-switch)
    "This is responsible for  producing a call to NAME in the most
        efficient way possible with the known types"
    (let* ((possible-types (let ((ret nil)
                                 arg)
                             ;;get entries in form (arg . type)
                             (dolist (p-t possible-types)
                               (setq arg (car p-t))
                               (dolist (type (cdr p-t))
                                 (push (cons arg type) ret)))
                             ret))
           (c 0)
  
           (args-just-vars (pyel-filter-non-args (mapcar 'strip_ args)))
           (new-args (loop for a in args
                           collect (if (or (eq a '&optional)
                                           (eq a '&rest)
                                           (string-match-p "\\(^_\\)\\(.+\\)"
                                                           (symbol-name a))) nil
                                     (intern (format "__%s__" (symbol-name a))))))
           (arg-replacements4 (let (ar)
                                (mapcar (lambda (x) (if (string-match-p "\\(^_\\)\\(.+\\)"
                                                                        (symbol-name x))
                                                        (push (list (strip_ x) (list '\, (strip_ x))) ar)))
  
                                        args)
                                ar))
           ;;list of symbols to replace
           ;;format: (symbol replace)
           (let-vars (let (lv) (mapcar* (lambda (a b) (if b
                                                          (push (list a b) lv)))
                                        args new-args)
                          lv))
           ;;strip any leading underscores
           (args (mapcar (lambda (a)
                           (if (string-match "\\(^_\\)\\(.+\\)" (symbol-name a))
                               (intern (match-string 2 (symbol-name a))) a))
                         args))
  
           ;;the __x__ type replacements interfere with the (\, x) type replacements
           ;;so they must be seporated and done one at a time
           (arg-replacements1 let-vars)
           (arg-replacements2 (mapcar (lambda (x)
                                        (list  (intern (format "$%s" x)) (list '\, x)))
                                      args-just-vars))
           (arg-replacements3 (mapcar (lambda (x)
                                        (list (intern (format "$$%s" x)) (list 'quote (list '\, x))))
                                      args-just-vars))
           (arg-replacements (append arg-replacements1 arg-replacements2))
  
           (arg-quote-replacements (mapcar (lambda (x)
                                             (list x (list '\, x)))
                                           args-just-vars))
           (current-replace-list nil)
           ;; (arg-replacements (append let-vars
           ;;                           (mapcar (lambda (x)
           ;;                                     (list  (intern (format "$%s" x)) (list '\, x)))
           ;;                                   args)))
  
           (ts ) ;;??
           (valid nil) ;;list of valid arg--types
           (found nil)
           (lets nil)
           var value type all-good var-vals len)
      ;;        (print "possible types = ")
      ;;        (print possible-types)
  
  
      ;;collect all the arg-type--code pairs that are valid possibilities,
      ;;that is, members of possible-types.
      ;;This essentially throws out all the arg types that have been ruled out.
      (dolist (t-s (pyel-expand-type-switch-2 args-just-vars type-switch))
        (if (equal (car t-s) 'and)
            (progn (setq all-good t
                         found nil)
                   (dolist  (x (cadr t-s)) ;;for each 'and' member type-switch
                     (dolist (pos-type possible-types) ;;for each arg type
                       (if (and (equal (eval (car x)) (car pos-type))
                                (equal (cadr x) (cdr pos-type)))
                           (setq found t)))
                     (setq all-good (if (and all-good found) t nil)))
                   (when all-good
                     (push t-s valid)))
          ;;else
          (if (eq (car t-s) t) ;;when all types are _
              (push t-s valid)
            ;;otherwise check if the type is one of the valid types
  
            (setq _xx t-s)
            (dolist(pos-type possible-types)
              (when (and (equal (eval (caar t-s)) (car pos-type))
                         (equal (strip$ (cadar t-s)) (cdr pos-type)))
                (push t-s valid))))));;TODO: break if found?
  
      ;;generate code to call NAME
      ;;if there is 2 posible types, use IF. For more use COND
      (setq len (length valid))
  
      (flet ((replace (code replacements)
                      (let ((ret nil)
                            found)
  
                        (dolist (c code)
                          (setq found nil)
                          (dolist (r replacements)
                            (if (consp c)
                                (setq c (replace c replacements))
                              (if (and (equal c (car r))
                                       (not found))
                                  (progn (push (cadr r) ret)
                                         (setq found t)))))
                          (unless found
                            (push c ret)))
                        (reverse ret)))
  
             (type-tester (x) (cadr (assoc x pyel-type-test-funcs)))
             (and-type-tester (x) (cadr (assoc (car x) pyel-type-test-funcs)))
             ;;(get-replacement (arg) ;;returns arg replacement
             ;;                 (cadr (assoc arg arg-replacements)))
             (get-replacement (arg) ;;returns arg replacement
                              (cadr (assoc arg current-replace-list)))
  
             ;;bug fix maybe...
             (get-replacement-OLD (arg) ;;returns arg replacement
                                  (or (cadr (assoc arg arg-replacements))
                                      (cadr (assoc arg arg-replacements4))))
  
             ;;replaces the vars, one type at a time
             (replace-vars (code)
                           (let* ((current-replace-list arg-replacements1)
                                  (code (replace code arg-replacements1))
                                  (current-replace-list arg-replacements2)
                                  (code (replace code arg-replacements2))
                                  (current-replace-list arg-replacements3))
                             (replace code arg-replacements3)))
  
             (gen-cond-clause (t-s--c) ;;Type-Switch--Code
                              (if (equal (car t-s--c) 'and)
                                  (progn (setq __x t-s--c)
                                         `((and ,@(mapcar '(lambda (x)
                                                             ;;TODO: test
                                                             `(,(type-tester (cadr x))
                                                               ,(get-replacement-OLD
                                                                 (car x))))
                                                          (cadr t-s--c)))
                                           ,(replace-vars (caddr t-s--c))))
  
                                ;;TODO
                                (progn (setq __x t-s--c)
                                       (if (equal (car t-s--c) t) ;;all types where _
                                           `(t ,(replace-vars (cadr t-s--c)))
                                         (let* ((str (symbol-name (cadar t-s--c)))
                                                (quote-arg-p (string-match-p "\\(^\\$\\)\\(.+\\)"
                                                                             str))
                                                (type (if quote-arg-p (intern (match-string 2 str)) (cadar t-s--c)))
                                                (tester (type-tester type))
                                                (body (replace-vars (cadr t-s--c)))
                                                (arg (get-replacement-OLD (caar t-s--c))))
                                           `((,tester ,(if quote-arg-p (list 'quote (list '\, (caar t-s--c))) arg))
                                             ,body))
  
                                         ))))
  
             (gen-varlist ()
                          (mapcar (lambda (x) `(,(cadr x) ,(list '\, (car x))))
                                  let-vars)
                          ))
  
        (cond ((<= len 0) "ERROR: no valid type")
              ((= len 1)
               (if (eq (caar valid) 'and)
                   ;;; (eval (caddar valid))
                   (caddar valid)
                 ;;;(eval  (cadar valid))
                 ;;there is only one possibility, so replace the args with their quoted counterpart
                 ;;instead of replacing with the let bound vars
                 (list 'backquote (replace (cadar valid) arg-quote-replacements))
                 ))
              ;;?TODO: are there possible problems with evaluating the arguments
              ;;       multiple times? Maybe they should be put in a list
              (t (let* ((clauses (mapcar 'gen-cond-clause valid))
                        (clauses (if (eq (caar clauses) t)
                                     clauses
                                   (cons
                                    '(t (error "invalid type, expected <TODO>"))
                                    clauses)))
                        (varlist (gen-varlist)))
                   `(backquote ,(if varlist
                                    `(let ,varlist
                                       (cond ,@(reverse clauses)))
                                  `(cond ,@(reverse clauses)))
                               )))))))
  
  (defun call-transform (template-name &rest args)
    "expand TEMPLATE-NAME with ARGS in the same way that `transform' would
  if was called as (transform '(template-name args))
  NOTE: this calls `transform' on all ARGS, but not TEMPLATE-NAME"
    (eval `(transform '(,template-name ,@(mapcar 'transform args)))))
  
  (defun strip$ (sym)
    (let ((str (symbol-name sym)))
      (if (string-match "\\(^\\$\\)\\(.+\\)" str)
          (intern (match-string 2 str))
        sym)))
  (defun strip_ (sym)
    (let ((str (symbol-name sym)))
      (if (string-match "\\(^_\\)\\(.+\\)" str)
          (intern (match-string 2 str))
        sym)))
  
  (defun pyel-arg-descriptor (arglist)
    "return the number of values that may be passed to ARGLIST
  If ARGLIST contains &optional or &rest then return a cons of
  the min and max values that may be passed.
  
  This does not check if ARGLIST has a valid form"
  
    (let ((min 0)
          (max 0)
          optional)
      (when arglist
        (if (member '&rest arglist)
            (setq max 'I
                  arglist (subseq arglist 0 -2)))
        (if (member '&optional arglist)
            (setq optional (pyel-split-list arglist '&optional)
                  min (length (car optional)) ;;positional args
                  max (if (eq max 'I) max
                        (+ min (length (cdr optional))))) ;;optional args
          (setq min (length arglist)
                max (if (eq max 'I)
                        max
                      min))))
      (if (or (equal min max)
              (and (= min 0)
                   (eq max 'I)))
          max
        (cons min max))))
  
  (defun pyel-arglist-signature (arglist)
    (let ((num (pyel-arg-descriptor arglist)))
      (format "->%s<-" (if (or (numberp num)
                               (eq num 'I))
                           num
                         (format "%s~%s" (car num) (cdr num))))))
  
  (defun pyel-extract-arg-descriptor (name)
    "extract the arglist descriptor from name"
  
    (assert (stringp name) "Name must be a string")
    (if (symbolp name) (setq name (symbol-name name)))
    (let (min max I?)
      (cond ((string-match "->\\([0-9I]+\\)<-" name)
             (setq min (match-string 1 name)
                   max min))
  
            ((string-match "->\\([0-9]+\\)~\\([0-9I]+\\)<-" name)
             (setq min (match-string 1 name)
                   max (match-string 2 name))))
  
      (if min
          (setq I? (intern max)
                max (if (eq I? 'I) 'I (string-to-number max))
                min (string-to-number min)))
  
      (cond ((null min) nil)
            ((or (equal min max)
                 (and (= min 0)
                      (eq max 'I)))
             max)
            (t (cons min max)))))
  
  (defun pyel-arg-descriptor-to-signature (descriptor)
    (format "->%s<-" (if (or (numberp descriptor)
                             (eq descriptor 'I))
                         descriptor
                       (format "%s~%s" (car descriptor) (cdr descriptor)))))
  
  (defvar pyel-method-name-arg-signature (make-hash-table :test 'eq)
    "mapping of method transform names to a list of argument signatures")
  
  (defun pyel-add-method-name-sig (name args)
    "Add the argument signature of ARGS to NAME in `pyel-method-name-arg-signature'"
    (let* ((signatures (gethash name pyel-method-name-arg-signature)))
      (add-to-list 'signatures (pyel-arg-descriptor args))
      (puthash name signatures pyel-method-name-arg-signature)))
  
  (defun pyel-find-method-transform-name (name num-args)
    "find a matching method transform for NAME with NUM-ARGS
  will return the name of the first match"
    (let ((signatures (gethash name pyel-method-name-arg-signature))
          found min max)
      (if signatures
          (progn (while signatures
                   (setq sig (car signatures)
                         signatures (cdr signatures))
  
                   (if (or (and (numberp sig)
                                (= sig num-args))
  
                           (eq sig 'I)
  
                           (and (consp sig)
                                (setq min (car sig)
                                      max (cdr sig))
                                (and (>= num-args min)
                                     (or (<= num-args max)
                                         (eq max 'I)))))
                       (setq signatures nil
                             found sig)))
                 (if found
                     (intern (format pyel-method-name-format-string
                                     name
                                     (pyel-arg-descriptor-to-signature found)))))
        (error "method transform %s does not exist in the signature table"
               name))))
#+END_SRC
*** example usage
(pyel-def-call-func pyel+ (lhs rhs)
		    ((or lsh rhs)
		     (string (concat lhs rhs))
		     (number (+ lhs rhs))
		     (list (append lhs rhs)
			   (vector (ldk lhs rhs)))))


(setq known-types '((string list) (number vector)))

(pyel+ 'a 'b)
==>  (cond
      ((listp a)
       (append a b))
      ((numberp b)
       (+ a b))
      ((stringp a)
       (concat a b))
      (t
       (error "invalid type, expected <TODO>")))


TODO: describe alternative syntax
==> look at the bin-op heading for examples
(pyel-def-funcall * (l r)
                    (number number) ->  (* l r)
                    (object _)
                    (_ object)  -> (--mul-- l r)
                    (_ string)
                    (string _)  -> (pyel-mul-num-str l r))

*** tests
auto generated tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;
#+END_SRC
hand written
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-test-expand-type-switch ()
    (should (equal (pyel-expand-type-switch-2 '(l r)
                                              '((number number) ->  (* l r)
                                                (object _)
                                                (_ object)  -> (--mul-- l r)
                                                (_ string)
                                                (string _)  -> (pyel-mul-num-str l r)))
                   '((and ((l number) (r number)) (* l r)) ((l object) (--mul-- l r)) ((r object) (--mul-- l r)) ((r string) (pyel-mul-num-str l r)) ((l string) (pyel-mul-num-str l r))))))
#+END_SRC

** translation messages
#+Begin_SRC emacs-lisp :tangle pyel.el
(defvar pyel-translation-messages nil
  "collects messages during pyel translations")

(defvar pyel-message-formats '((error "ERROR: %s")
			       (warn "WARNING: %s")
			       (recommend "RECOMMENDATION: %s"))
  "alist of message type and their format strings")

(defun pyel-notify (type msg)
  "add MSG to `pyel-translation-messages', TYPE specifies the format string
in `pyel-message-formats'"
  (push (format (or (cadr (assoc type pyel-message-formats))
		    (format "[%s]: %%s" (upcase (symbol-name type))))
		msg) pyel-translation-messages))

#+END_SRC
** line/column numbers
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defun pyel-skip-whitespace ()
    (skip-chars-forward " \t\n\r"))
  
  (defun char-at-point ()
    (buffer-substring-no-properties (point) (1+ (point))))
  
  (defun read-tree-positions ()
    "Create a tree of buffer positions corresponding to the source tree at the point
  format [start end list-of-sub-trees] list-of-sub-trees is nil for leaves"
    (pyel-skip-whitespace)
    (let ((start (point))
          inner)
      (goto-char (1+ start))
      (setq inner (read-list-positions)) ;;asssumes we start on a list
      (vector start (point) inner)))
  
  (defun read-list-positions ()
    (let (start end elems)
      (condition-case nil
          (while t
            (pyel-skip-whitespace)
            (setq start (point))
            (if (string= (char-at-point) "(")
                (push (get-tree-positions) elems)
              (setq end (scan-sexps start 1))
              (push (vector start end nil) elems)
              (goto-char end)))
        (scan-error (goto-char (1+ start))))
      (reverse elems)))
#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-test-do-splices ()
    (should (equal (pyel-do-splices '(a (@ b (c)))) '(a b (c))))
    (should (equal (pyel-do-splices '(a (@ b c)))  '(a b c)))
    (should (equal (pyel-do-splices '(a (@ b (c (@ 2 (n (x 1 (@ 2))) 3 (@ 3) (@ a b (2)))))))
                   '(a b (c 2 (n (x 1 2)) 3 3 a b (2)))))
  
    (should (equal (pyel-do-splices '(@ (a b (@ d (e 2 (@ a b c ))))))
                   '(a b d (e 2 a b c))))
  
    (should (equal (pyel-do-splices '(@ (a b (@ d (e 2 (@ a b c )))) last))
                   '(progn (a b d (e 2 a b c)) last)))
  
    (should (equal (pyel-do-splices '(@)) nil))
    )
#+END_SRC

* python preprocessor
The preprocessor is no longer tangled

(lambda (a b) (print a))
lambda((a,b)
       print(a))

(cond ((> a b) (print a))
      (t (print b)))
cond([a > b, print(a)]
     [true, print(b)])

(py-ast "lambda([a,b],
print(a)) " t)

preprocessor expand separately
  scan for regex
  copy form to seporate file and expand to pyel-ast
    store in hash table with unique ID
  in py-ast replace with variable that matches some regex and contains that id
  in pyel expanstion match names, when match found, transform ast from hash table

* transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(make-transform-table 'pyel)
#+END_SRC
** tests
* python ast
This is for all non template specific code.
#+Begin_SRC python :tangle py-ast.py
  import ast
  
  #TODO: use *args
  
  def l_str(x):
      return "(" + " ".join(map(str,x)) + ")"
  
  def ll_str(x):
      if x == []:
          return "nil"
      elif type(x) == str:
          return x
      return "(" + " ".join(map(str,x)) + ")"
  #    return " ".join(map(str,x))
  #    return "(list " + " ".join(map(str,x)) + ")"
  # commented out for 'assign'. cause problems elsewhere?
  
  def untuple(x):
      return ll_str(x)
      if x == []:
          return "nil"
      elif type(x) == str:
          return x
  
  def Module(body):
      return "\n".join(body)
  
  def keyword(arg, value, lineno='nil', col_offset='nil'):
      return l_str(["(keyword ", arg, " ", value, lineno, col_offset, ")"])
  
  def Print(dest, values, nl, lineno='nil', col_offset='nil'):
      print("Error: using python2, upgrade to python3")
      exit()
  
  def Param():
      return "'param"
  
  def Load():
      return "'load"
  
  def Store():
      return "'store"
  
  def Expr(value, lineno='nil', col_offset='nil'): #?
      return value
  
  def Import(names, lineno=None, col_offset='None'):
      return l_str(["import ",ll_str(names), lineno, col_offset])
  
  def alias(name, asname):
      if asname: asname = "\"" + asname + "\""
      return l_str(["alias ", "\"" + name + "\"", asname or "nil"])
  
  def ImportFrom(module, names, level, lineno=None, col_offset='None'):
      return l_str(["import-from ","\"" + module + "\"", ll_str(names), level, lineno, col_offset])
#+END_SRC
* runtime
* testing
ert tests
http://www.gnu.org/software/emacs/manual/html_mono/ert.html#Test-Selectors

#+Begin_SRC emacs-lisp :tangle pyel.el
  (defvar pyel-test-py-functions nil
    "list of generated python test functions.
  when `pyel-run-tests' is run, these are translated to e-lisp
  and compared to expected values")
  
  (setq _pyel-tests nil)
  (setq _pyel-structure-tests nil)
  
  (defvar pyel-test-func-counter 0
    "just another counter")
  
  (defun pyel-make-test-func-name ()
    (setq pyel-test-func-counter (1+ pyel-test-func-counter)))
  
  (defun cl-prettyprint-to-string (form)
    (with-temp-buffer
      (cl-prettyprint form)
      (buffer-string)))
  
  
  (defun pyel-test-list-form-p (form)
    "return t if FORM describes part of a pyel test.
  All lists are a part of pyel tests except those whose
  car is 'lambda or 'quote" 
    (and
     (listp form)
     (> (length form) 0)
     (not (or (eq (car form) 'lambda)
              (eq (car form) 'quote)))))
  
  (defun pyel-valid-test-form-p (form)
    "Returns t if FORM is a valid pyel test"
    (or (stringp form)
        
        (and (consp form)
             (>= (length form) 2)
             (stringp (car form))
             (or 
              ;; form: ("test" expect)
              (and (= (length form) 2)
                   (not (pyel-test-list-form-p (cadr form)))
                   (or (null (cadr form)) (eq (cadr form) t)
                       (not (symbolp (cadr form)))))
              ;; form: ("setup" test-forms ...)
              (and (let ((ok t))
                     (dolist (x (cdr form))
                       (setq ok (and ok (and (consp x)
                                             (= (length x) 2)
                                             (stringp (car x))
                                         ;;;test-form: ("test1" result1)
                                             (or (and (not (pyel-test-list-form-p (cadr x)))
                                                      (or (null (cadr x))
                                                          (eq (cadr x) t)
                                                          (not (symbolp (cadr x)))))
                                                 ;;test-form: ("test1setup" ("test1" result1))
                                                 (let ((subform (cadr x)))
                                                   (and (consp subform)
                                                        (= (length subform) 2)
                                                        (stringp (car subform))
                                                        (and (not (pyel-test-list-form-p (cadr subform)))
                                                             (or (null (cadr subform))
                                                                 (eq (cadr subform) t)
                                                                 (not (symbolp (cadr subform))))))))))))
                     ok))))))
  
  (ert-deftest pyel-test-valid-forms ()
    ;;valid forms
    (should (pyel-valid-test-form-p "test"))
    (should (pyel-valid-test-form-p '("test" nil)))
    (should (pyel-valid-test-form-p '("test" "expect")))
    (should (pyel-valid-test-form-p '("test" 'expect)))
    (should (pyel-valid-test-form-p '("test" 3)))
    (should (pyel-valid-test-form-p '("test" '(a b c))))
    (should (pyel-valid-test-form-p '("test" (lambda () c))))
    (should (pyel-valid-test-form-p '("setup" ("test1" 'result1))))
    (should (pyel-valid-test-form-p '("setup" ("test1setup" ("test1" 34)))))
    (should (pyel-valid-test-form-p '("setup" ("test1" 'result1) ("test2" "r3") ("test2" 3) ("test1setup" ("test1" 'result1)))))
    (should (pyel-valid-test-form-p '("setup" ("test1" '(a b c)) ("test2" (lambda () 4))  ("test1setup" ("test1" '(a b c))))))
    (should (pyel-valid-test-form-p '("setup" ("test1setup" ("test1" (lambda () 3))))))
    ;;invalid forms
    (should (not (pyel-valid-test-form-p 3)))
    (should (not (pyel-valid-test-form-p 'symbol)))
    (should (not (pyel-valid-test-form-p '(s))))
    (should (not (pyel-valid-test-form-p '(s 3))))
    (should (not (pyel-valid-test-form-p '("skld" "ldkj" "lskdjf"))))
    (should (not (pyel-valid-test-form-p '("test" expect))))
    (should (not (pyel-valid-test-form-p '('a "expect"))))
    (should (not (pyel-valid-test-form-p '(3 expect))))
    (should (not (pyel-valid-test-form-p '((b c) 3))))
    (should (not (pyel-valid-test-form-p '((lambda ()) '(a b c)))))
    (should (not (pyel-valid-test-form-p '("setup" (3 result1)))))
    (should (not (pyel-valid-test-form-p '(3 ("test1" result1)))))
    (should (not (pyel-valid-test-form-p '("setup" ("test1setup" (34 "test1"))))))
    (should (not (pyel-valid-test-form-p '("setup" ("test1setup" ("test1" sym))))))
    (should (not (pyel-valid-test-form-p '("setup" ("test1" result1) ("test2" "r3") ("test2" 3) ("test1setup" (1 result1))))))
    (should (not (pyel-valid-test-form-p '("setup" ("test1" '(a b c)) (test2 (lambda () 4))  ("test1setup" ("test1" '(a b c)))))))
    (should (not (pyel-valid-test-form-p '(("test1setup" ("test1" (lambda () 3))))))))
  
  
  (defmacro pyel-create-tests (name &rest py-tests)
    (let ((complete nil)
          (py-ast nil)
          (el-ast nil)
          (c 0)
          ert-tests
          tests
          invalid-form
          trans)
      (message "creating tests for '%s'" name)
      (progv
          (mapcar 'car test-variable-values)
          (mapcar 'cadr test-variable-values)
  
        (flet ((pyel-create-new-marker () "test_marker"))
          (condition-case err
              (dolist (test (reverse py-tests))
                (or (setq valid-form (pyel-valid-test-form-p test)) (error nil))
                (cond ((and (consp test)
                            (>= (length test) 2)
                            (and (consp (cadr test))
                                 (not (or (eq (caadr test) 'lambda)
                                          (eq (caadr test) 'quote))))
                            )
                       (let* ((tests)  ;;form: ("setup" ("test1" result1) ("test2" result2) ...)
                              (name-str (replace-regexp-in-string "-" "_" (symbol-name name)))
                              (test-name (concat "pyel_test_" name-str "_" (number-to-string (pyel-make-test-func-name))))
                              (d 0))
  
                         (push (setq _x (pyel-functionize (concat (car test)
                                                                  (if (= (length test) 2)
                                                                      (if (listp (cadr test))
                                                                          ;;form:  ("setup" ("test" expect))
                                                                          (concat "\nreturn " (caadr test))
                                                                        ;;form: ("test" expect)
                                                                        (concat "return " (caaddr (cdr test))))
                                                                    ;;form ("setup" ("test1setup" ("test1" result1)) ...)
                                                                    (mapconcat (lambda (x) (concat "\nif n == " (number-to-string (setq d (1+ d))) ":\n"
                                                                                                   (if (and (listp (cadr x))
                                                                                                            ;;form:  ("setup" ("test" expect))
                                                                                                            (not (or (eq (caadr x) 'lambda)
                                                                                                                     (eq (caadr x) 'quote)
                                                                                                                     (null (caadr x)))))
                                                                                                       (concat (pyel-indent-py-code (car x)) "\n"
                                                                                                               (concat " return " (caadr x)))
                                                                                                     ;;form: ("test" expect)
                                                                                                     (concat " return " (car x)))))
                                                                               (cdr test) "\n")))
                                                          test-name (if (= (length test) 2) nil "n")))
                               pyel-test-py-functions)
                         (setq d 0)
                         (mapc (lambda (x)
                                 (push `(ert-deftest
                                            ,(intern (format "pyel-test-%s-%s" name-str
                                                             (number-to-string (setq c (1+ c))))) ()
                                          (equal (eval (pyel ,(if (= (length test) 2)
  
  
                                                                  (format "%s()" test-name)
                                                                (format "%s(%s)" test-name (setq d (1+ d))))))
                                                 ,(if (and (listp (cadr x))
                                                           (not (or (eq (caadr x) 'lambda)
                                                                    (eq (caadr x) 'quote))))
                                                      (cadr (cadr x)) ;;form: ("setup" ("test" expect))
                                                    (cadr x)))) ;;;;form: ("test" expect)
                                       tests))
                               (cdr test))
                         (setq _pyel-tests (append _pyel-tests (reverse tests)))
                         ))
  
                      ((consp test) ;;form: ("test" expect)
                       (push `(ert-deftest
                                  ,(intern (concat "pyel-" (symbol-name name)
                                                   (number-to-string (setq c (1+ c))))) ()
                                (equal (eval (pyel ,(concat (pyel-functionize (car test) "_pyel21312")
                                                            "\n_pyel21312()")))
                                       ,(cadr test)))
  
                             _pyel-tests))
  
                      (t (progn ;;form "test"
                           ;;check complete code transformation
                           (setq trans (pyel test))
                           (push `(ert-deftest ,(intern (format "pyel-transform-test-%s-%s"  name (pyel-make-test-func-name))) ()
                                    (equal (pyel ,test)
                                           ',trans))
                                 _pyel-structure-tests)
                           ;;check python ast
                           (push `(ert-deftest ,(intern (format "pyel-py-ast-test-%s-%s"  name (pyel-make-test-func-name))) ()
                                    (equal (py-ast ,test)
                                           ,(py-ast test)))
                                 _pyel-structure-tests)
                           ;;check transformed .py syntax tree
                           (push `(ert-deftest ,(intern (format "pyel-el-ast-test-%s-%s"  name (pyel-make-test-func-name))) ()
                                    (string= (pyel ,test nil nil t)
                                             ,(pyel test nil nil t)))
                                 _pyel-structure-tests)))))
            (error (error "Error while creating test: '%s'. Error: %s" name (if valid-form
                                                                                err
                                                                              "Invalid form"))))))))
  
  (defun pyel-create-tests-with-known-types (name known-types &rest py-code)
    "just like `pyel-create-tests-with-known-types' fakes the known types during the tests"
    ;;99% of the code is the same...
    (let ((complete nil)
          (py-ast nil)
          (el-ast nil)
          trans)
      (progv
          (mapcar 'car test-variable-values)
          (mapcar 'cadr test-variable-values)
  
        (dolist (code (reverse py-code))
          ;;check complete code transformation
          (setq trans (pyel-with-known-types known-types code))
          (push `(should (equal
                          (pyel-with-known-types ',known-types ,code)
                          ',trans))
                complete)
          ;;check pure .py syntax tree
          (push `(should (equal (py-ast ,code)
                                ,(py-ast code)))
                py-ast)
          ;;check transformed .py syntax tree
          (push `(should (string= (pyel ,code t)
                                  ,(pyel code t)))
                el-ast))
  
        (kill-new (pp-to-string `(ert-deftest ,(intern (concat "pyel-" (symbol-name name) "-full-transform"))
                                     () ,@complete)))
        (kill-append (pp-to-string `(ert-deftest ,(intern (concat "pyel-" (symbol-name name) "-py-ast"))
                                        () ,@py-ast)) nil)
  
        (kill-append (pp-to-string `(ert-deftest ,(intern (concat "pyel-" (symbol-name name) "-el-ast"))
                                        () ,@el-ast)) nil)
        (message "Tests copied to kill ring"))))
  
  
  (defun pyel-indent-py-code (code &optional indent)
    "Indent CODE by INDENT. CODE is a string. INDENT defaults to one space"
    (let ((indent (or indent " ")))
      (mapconcat 'identity (mapcar (lambda (x) (concat indent x))
                                   (split-string code "\n"))
                 "\n")))
  
  (defun pyel-generate-tests ()
    (interactive)
    ;;read in tests from pyel-tests.el
    ;;save resulting tests in  pyel-tests-generated.el
    ;;evaluate all the tests
    (let ((pyel-test-func-counter 0)
          pyel-test-py-functions
          _pyel-tests
          _pyel-structure-tests)
  
      (load-file (file-path-concat pyel-directory "pyel-tests.el"))
      (with-temp-buffer
        ;;save py test functions
        (insert (format "(setq pyel-test-py-functions '%s)"
                        (prin1-to-string pyel-test-py-functions)))
        ;;insert normal tests
        (mapc (lambda (x)
                (insert (prin1-to-string x) "\n"))
              _pyel-tests)
        ;;insert the other tests
        (mapc (lambda (x)
                (insert (prin1-to-string x) "\n"))
              _pyel-structure-tests)
  
        (insert "\n(provide 'pyel-tests-generated)")
        (write-file (file-path-concat pyel-directory "pyel-tests-generated.el")))))
  
  (defalias 'pyel-verify 'pyel-run-tests)
  (defun pyel-run-tests (&optional selector)
    "setup and run pyel test.
  SELECTOR may be any of the following:
  'pyel-test' all normal tests. This is the default
  The following tests check code structure, but do not eval
  generated lisp code.
  'pyel-transform-test' check full code transform
  'pyel-py-ast-test' check python AST
  'pyel-el-ast-test' check lisp AST
  
  'pyel' will run all tests'"
    (interactive)
    (setq selector (or selector
                       (let ((tests '(("all" . "pyel")
                                      ("standard" . "pyel-test")
                                      ("python AST" . "pyel-py-ast-test")
                                      ("lisp AST" . "pyel-el-ast-test")
                                      ("transform" . "pyel-transform-test"))))
                         (cdr (assoc (completing-read "select tests> "
                                                      (mapcar 'car tests)
                                                      nil t)
                                     tests)))))
    (flet ((pyel-create-new-marker () "test_marker"))
      (progv
          (mapcar 'car test-variable-values)
          (mapcar 'cadr test-variable-values)
  
        (if (or (string= selector "pyel-test")
                (string= selector "pyel"))
            (let ((tmp-file "/tmp/pyel-test-functions.el"))
              (message "Evaluating test functions...")
              ;;(mapc (lambda (x) (eval (pyel x))) pyel-test-py-functions)
              (find-file tmp-file)
              (erase-buffer)
              (mapc (lambda (x)
                      ;;macroexpand so edebug-defun can be used on it
                      (insert (cl-prettyprint-to-string (macroexpand (pyel x)))))
                    pyel-test-py-functions)
              (save-buffer)
              (kill-buffer)
              (load-file tmp-file)))
  
        (ert-run-tests-interactively selector)
        )))
  
  (defun pyel-functionize (py-code &optional func-name &rest args)
    "wrap PY-CODE in a function definition
  FUNC-NAME defaults to 'f'"
    (concat  "def " (or func-name "f") (if args (format "(%s)" (mapconcat 'identity args ", ")) "()") ":\n"
             (mapconcat 'identity (mapcar (lambda (x) (concat " " x))
                                          (split-string py-code "\n"))
                        "\n")))
  
#+END_SRC
** tests
this test is disabled. It pollutes global variables
# #+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-create-tests ()
    (let ((pyel-test-func-counter 0)
          pyel-test-py-functions
          _pyel-tests)
      (pyel-create-tests
       test
       "test1\na\nb"
       ("test2 setup"
        ("test2_1" expect2_1)
        ("test2_2setup\na\nb" ("test2_2" expect2_2)))
       ("test3" expect3)
       ("test4setup\na\nb" ("test4" expect4)))
      (equal pyel-test-py-functions '("def pyel_test_test_2(n):
   test2 setup
   if n == 1:
    return test2_1

   if n == 2:
    test2_2setup
    a
    b
    return test2_2" "def pyel_test_test_1():
   test4setup
   a
   b
   return test4"))

      (equal _pyel-tests
             '((push (quote (string= (pyel "test1
  a
  b" t) "(name  \"test1\" 'load)
  (name  \"a\" 'load)
  (name  \"b\" 'load)
  ")) pyel-el-ast-tests) (push (quote (equal (py-ast "test1
  a
  b") "Module(body=[Expr(value=Name(id='test1', ctx=Load())), Expr(value=Name(id='a', ctx=Load())), Expr(value=Name(id='b', ctx=Load()))])
  ")) pyel-py-ast-tests) (push (quote (equal (pyel "test1
  a
  b") (quote (progn test1 a b)))) pyel-transform-tests) (ert-deftest pyel-test2 nil (equal (eval (pyel "def _pyel21312():
  test3
  _pyel21312()")) expect3)) (ert-deftest pyel-test1 nil (equal (eval (pyel "pyel_test_test_1()")) expect4)) (ert-deftest pyel-test3 nil (equal (eval (pyel "pyel_test_test_2(1)")) expect2_1)) (ert-deftest pyel-test4 nil (equal (eval (pyel "pyel_test_test_2(2)")) expect2_2))))))
# #+END_SRC
* ---------------------
* ast transforms
** assign
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;; should not fset functions because the effect takes place globally
  ;; even when the name being set is let bound.
  (pyel-dispatch-func set (_sym _val)
                      (_ $function) -> (setq $sym $$val)
                      (_ _) -> (setq $sym $val)) ;;TODO: other?
  
  (def-transform assign pyel ()
    (lambda (targ val &optional line col) (py-assign targ val line col)))
  
  ;;TODO: put all setq's in a single form: (setq a 1 b 2) etc
  
  (defun py-assign (targets values &optional line col)
  
    (let ((wrap-values t)
          unpack i)
      ;;make sure targets and lists are both in a list form
      ;;the 'unpack' flag is needed because it leaves no difference
      ;;between a,b=c and a=b=c
      (if (and (listp (car targets))
               (eq (caar targets) 'tuple))
          (progn
  
            (if (eq (car values) 'tuple)
                (progn
  
                  (setq values (cadr values))
                  (setq wrap-values nil))
              (setq unpack t) ;;targets is a tuple and values is not
              ;;(setq values (list values))
              )
  
            (setq targets (cadar targets)))
        )
  
      (when wrap-values
        (setq values (list values)))
  
  
      ;;py-sssign2 does the main transforms
      ;;TODO: check for the special case a,b=b,a and create temp variables
      ;;TODO: check that legnth of the lists are the same
  
      ;;TODO:
      (cond (unpack
             ;;TODO: pyel error unless: (and (> (length targets) 1)  (= (length values) 1)
  
             (let ((code '(@)))
               `(let ((__value__ ,(transform (car values))))
  
                  ,(dotimes (i (length targets) (reverse code))
                   ;;;TODO: will have to help the transform know what type __value__ is
                     (push (py-assign2 (nth i targets)
  
                                       (pyel-make-ast 'subscript '__value__ i 'load))
                           code))
                  )))
  
            ((= (length targets) 1)
             ;;form: a=b
             (py-assign2 (car targets)
                         (car values))) ;;if this is the second call of a "a,b = c" type form, then the ctx of values will be store instead of load which leads to an error
  
            ;;form: a,b = c
            ((and (> (length targets) 1) (= (length values) 1))
             (list '@ (py-assign2 (car (last targets)) (car values))
                      (py-assign  (butlast targets)
                                  (pyel-change-ctx (car (last targets)) 'load))))
  
            ;;form: a,b = x,y
            (t (let* ((tmp-vars (loop for i from 1 to (length targets)
                                      collect (intern (format "__%s__" i))))
                      (let-vars (mapcar* (lambda (a b)
                                           (list a (transform b)))
                                         tmp-vars values)))
                 `(let ,let-vars
                    ,(cons '@ (mapcar* 'py-assign2 targets tmp-vars))))))))
  
  ;;DOC: tranforms must be carefull not to transform code multiple times
  
  (defun py-assign2 (target value)
    ;;access line and col values from `py-assign' calling env.
    (let ((ctx (eval (car (last target))))
  
          (assign-value value))
  
      ;;the target code is responsible for providing the correct assign function
      ;;
  
      ;;TODO:     is context-value still used?
      ;; (using-context assign-target
      ;;             (setq t-target (transform target)))
      ;; (using-context assign-value
      ;;             (setq t-value (transform value)))
  
      ;;The target transform is responsible for generating the code
      ;;The value being assigned to the target is available to the
      ;;target transform via the variable assign-value.
      ;;assign-value is untransformed, the target transform must tranform it
  
      ;; (using-context assign-value
      ;;             (setq assign-value (transform value)))
      ;;problem: code was being transformed multiple times
      (setq assign-value value)
      (using-context assign-target
                     (transform target))
      ;;    (list assign-func t-target t-value)
  
      ))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Assign(targets, value, lineno='nil', col_offset='nil'):
      #    print("targets: ", targets)
      return l_str(["assign ", untuple(targets), value, lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   assign
   ("a = 1" ("a" 1))
   ("class a: pass
  a.b = 1" ("a.b" 1))
   "a.b = c"
   "a.b.c = 1"
   "a.b = d.c"
   ("a,b = 1,2"
    ("a" 1)
    ("b" 2))
   ("x = [1,0,9]
  f = lambda: 3
  class C: pass
  C.a = 3
  a, C.v, x[2] = C.a,1.1, x[x[1]]"
    ("a" 3)
    ("C.v" 1.1)
    ("x[2]" 1))
  
   ("a = 1
  b = 2
  a,b= b,a"
    ("a" 2)
    ("b" 1))
   ("a = [1,2]
  b = (3,4)
  x,y = a
  xx,yy = b"
    ("x" 1)
    ("y" 2)
    ("xx" 3)
    ("yy" 3))
   ("class C:
   a = [11,22,33]
  x,y,z = C.a"
    ("x" 11)
    ("y" 22)
    ("z" 33))
   ("a = 1
  b = 2
  c = 3
  d = a,b,c"
    ("d" [1 2 3]))
  
   "a,b = a.e.e()"
  
   "a[1:4], b[2], a.c = c"
  
   "a = b = c"
   "a = b = c.e"
   "a = b = c.e()"
   ("a = b = c = 9"
    ("a" 9)
    ("b" 9)
    ("c" 9))
   )
#+END_SRC
** attribute
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform attribute pyel ()
    (lambda (value attr ctx &optional line col)
      (pyel-attribute value attr ctx line col)))
  
  (defun pyel-attribute (value attr ctx &optional line col)
    (setq ctx (cond ((context-p 'force-load) 'load)
                    ((context-p 'force-store) 'store)
                    (t (eval ctx))))
    (let ((t-value (transform value))
          (attr (read (_to- (transform attr)))))
  
      ;;create slot for this attribute if it does not already exist
      (when (and (context-p 'method-def)
                 (not (assoc attr class-def-slots)))
        (push `(,attr :initarg ,(intern (concat ":"
                                                (symbol-name attr)))
                      :initform nil)
  
              class-def-slots))
      (if (and (context-p 'method-call)
               (not (context-p 'method-call-override)))
          (using-context method-call-override
                         ;;ctx?
                         `(@ call-method ,(transform value) ,attr))
  
        ;; (if (context-p 'assign-target)
        ;;          (setq assign-func 'oset))
  
        ;;check the presumption:
        (when (and (eq ctx 'store)
                   (not (context-p 'assign-target))
                   nil);;for this to work, this function need to set context as well
          (error "`pyel-attribute': Presumption failed: ctx==store but not in assign context"))
        (when (and (eq ctx 'store)
                   (not (boundp 'assign-value)))
          (error "`pyel-attribute': Presumption failed: ctx==store but assign-value is unbound"))
  
        (cond
         ((eq ctx 'store)
          ;;(list 'oset t-value attr (transform assign-value)) ;;assign target
          (list 'setattr t-value attr (transform assign-value)))
         ((eq ctx 'load) ;;assign value
          ;;(list 'oref t-value attr)
          (list 'getattr t-value attr))
         (t "Error in attribute-- invalid ctx"))
        )))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Attribute(value, attr, ctx, lineno='nil', col_offset='nil'):
      return l_str(["attribute ", value, "\"" + attr + "\"", ctx, lineno, col_offset])
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests attribute
                     "a.b"
                     "a.b.c"
                     "a.b.c.e"
                     "a.b()"
                     "a.b.c()"
                     "a.b.c.d()"
                     "a.b.c.d(1,3)"
                     "a.b = 2"
                     "a.b.e = 2"
                     "a.b.c = d.e"
                     "a.b.c = d.e.f"
                     "a.b.c = d.e()"
                     "a.b.c = d.e.f()"
                     "a.b.c = d.e.f(1,3)"
                     "a.b, a.b.c = d.e.f(1,3), e.g.b"
                     "a.b(x.y,y)"
                     "a.b(x.y(g.g()),y.y)")
  
#+END_SRC
** num
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform num pyel ()
    (lambda (n &optional line col)
      n 
      ))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Num(n, lineno='nil', col_offset='nil'):
      return "(num " + str(n) +" " + str(lineno) + " " + str(col_offset) + ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   num
   ("3" 3)
   ("4.23" 4.23)
   ("3e2" 300.0))
#+END_SRC
** name
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform name pyel ()
    (lambda (id ctx &optional line col)
      (pyel-name id ctx line col)))
  
  (defun pyel-name (id ctx &optional line col)
    (let ((new-id)
          (id (read id))
          piece code)
  
      ;;TODO: id should be string. verify?
      (setq ctx (cond ((context-p 'force-load) 'load)
                      ((context-p 'force-store) 'store)
                      (t (eval ctx))))
  
  
      (if (assoc id pyel-marked-ast-pieces)
          ;;this id is a marker, insert the corresponding macro
          (progn
            (setq piece (assoc id pyel-marked-ast-pieces))
            ;;'piece' has form: (marker macro-name macro-body)
            (using-context macro-call
                           (list (second piece)
                                 (pyel-transform-ast (third piece) :nosplice))))
  
        ;;else: normal name
        (setq id (_to- id))
        (when (and (context-p 'assign-value) ;;checking assumption
                   (not (equal ctx 'load)))
          (error (format "In transform name: context is 'assign-value' but ctx is not 'load'.
            ctx = %s" ctx)))
  
        (when (setq new-id (assoc id pyel-variable-name-translations))
          (setq id (cadr new-id)))
  
        (when (and (eq ctx 'store)
                   (context-p 'function-def)
                   (context-p 'assign-target))
          (add-to-list 'let-arglist id))
  
        (cond
         ((eq ctx 'load) id)
         ((eq ctx 'store)  (if (context-p 'for-loop-target)
                               id
                             (call-transform 'set id assign-value)))
         (t  "<ERROR: name>"))
        )))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Name(id, ctx, lineno='nil', col_offset='nil'):
      return l_str(["name ", "\"" + id + "\"", ctx, lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-test-name ()
   (should (eq (pyel "testName") 'testName)))
#+END_SRC
** list
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform list pyel ()
    (lambda (elts ctx &optional line col)
      (pyel-list elts ctx line col)))
  
  (defun pyel-list (elts ctx &optional line col)  ;;IGNORING CTX
    (if (context-p 'macro-call)
        (mapcar 'transform elts)
      (cons 'list (mapcar 'transform elts))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def List(elts, ctx, lineno='nil', col_offset='nil'):
      return "(list " + ll_str(elts) + " " + ctx + " " + str(lineno) + " " +str(col_offset) +")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   list
   ("[]" nil)
   ("['a',1,2]" '("a" 1 2))
   ("a = [1,2,'b']
  b = [1,[1,'3',a,[],3]]"
    ("a" '(1 2 "b"))
    ("b" '(1 (1 "3" (1 2 "b") nil 3))))
   ("[[[1]]]" '(((1)))))
#+END_SRC
** dict
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (defvar pyel-dict-test 'equal "Test function for dictionaries")
  
  (def-transform dict pyel ()
    (lambda (keys values &optional line col)
      (pyel-dict keys values line col)))
  
  (defun pyel-dict (keys values line col) ;;TODO: move to lambda in template and create template vars
    (if keys
        `(let ((__h__ (make-hash-table :test ',pyel-dict-test))) ;;default length??
           ,(cons '@ (mapcar* (lambda (key value)
                                `(puthash ,key ,value __h__))
                              (mapcar 'transform  keys)
                              (mapcar 'transform  values)))
           __h__)
      `(make-hash-table :test ',pyel-dict-test)))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Dict(keys, values, lineno='nil', col_offset='nil'):
      return "(dict " + ll_str(keys) + " " + ll_str(values) + " " + str(lineno) + " " + str(col_offset) + ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests dict
                     "{'a':2, 'b':4}"
                     "a = {a:2, b:4}"
                     "x = {'a':2, 'b':4, 'c' : {'d' : 1,'e': 2,f:{g:3}}}")
#+END_SRC

** tuple
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform tuple pyel ()
    (lambda (elts ctx &optional line col) ;;Ignoring ctx for now
      (cons 'vector (mapcar 'transform elts))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Tuple(elts, ctx, lineno='nil', col_offset='nil'):
      return l_str(["tuple ", ll_str(elts), ctx, lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests Tuple
                     "()"
                     "(a, b)"
                     "(a, (b, (c,d)))"
                     "((((((((a))))))))")
#+END_SRC
** string
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform str pyel ()
    (lambda (s &optional line col)
      ;;    (format "\"%s\"" s)
      s
      ))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Str(s, lineno='nil', col_offset='nil'):
      return "(str \"" + str(s) +"\"" + " " + str(lineno) + " " + str(col_offset) + ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests string
                     "'a'"
                     "x = 'a'"
                     "['a','b']")
#+END_SRC
** comparisons: >, <, ==, !=, <=, >=
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform compare pyel ()
    (lambda (left ops comparators &optional line col)
      ;;what if comparators has multiple items?
      (pyel-compare left ops comparators :outer line col)))
  
  ;;TODO: assign comparators to temp variables to prevent repeated evaluation
  (defun pyel-compare (left ops comparators &optional outer line col)
    ;;if outer is non-nil, then we use 'and' to combine the seporate tests
    (if (> (length ops) 1)
        (list (if outer 'and '@)
              (pyel-compare left (list (car ops)) (list (car comparators)))
              (pyel-compare (car comparators) (cdr ops) (cdr comparators)))
      
      (call-transform (read (car ops)) left (car comparators))))
  
  (pyel-dispatch-func == (l r)
                      (number number) -> (= l r)
                      (string string) -> (string= l r)
                      ;;                       (object _) -> (--eq-- l r)
                      
                      (_ _) -> (equal l r))
  
  (pyel-dispatch-func > (l r)
                      (number number) -> (> l r)
                      ;;TODO: macro for this
                      (string string) -> (pyel-string> l r)
                      (list list) -> (pyel-list-> l r)
                      (object _) -> (call-method l __gt__ r)
                      (vector vector) -> (pyel-vector-> l r)
                      )
  
  ;;TODO: other py types?
  
  ;;::Q does `string<' behave like < for strings in python?
  (pyel-dispatch-func < (l r)
                      (number number) -> (< l r)
                      (string string) -> (string< l r)
                      (list list) -> (pyel-list-< l r)
                      (object _) -> (call-method l __lt__ r)
                      (vector vector) -> (pyel-vector-< l r))
  
  (pyel-dispatch-func >= (l r)
                      (number number) -> (>= l r)
                      (string string) -> (pyel-string>= l r)
                      (list list)     ->  (pyel-list>= l r)
                      (object _) -> (call-method l __ge__ r)
                      (vector vector) -> (pyel-vector->= l r))
  
  (pyel-dispatch-func <= (l r)
                      (number number) -> (<= l r)
                      (string string) -> (pyel-string<= l r)
                      (list list)     -> (pyel-list<= l r)
                      (object _) -> (call-method l __le__ r)
                      (vector vector) -> (pyel-vector-<= l r))
  
  (pyel-dispatch-func != (l r)
                      (number number) -> (pyel-number!= l r)
                      (string string) -> (pyel-string!= l r)
                      (object _) -> (call-method l __ne__ r)
                      (_ _) -> (!equal l r))
  
  ;;this is defined as a transform because `pyel-compare' expects
  ;;all comparison functions to be transforms
  (pyel-dispatch-func is (l r)
                      (_ _) -> (eq l r))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Compare (left, ops, comparators, lineno='nil', col_offset='nil'):
        return l_str(["compare ", left, ll_str(ops), ll_str(comparators), lineno, col_offset ])

  def Gt():
        return "\">\""
  def Lt():
        return "\"<\""
  def Eq():
        return "\"==\""
  def NotEq ():
        return "\"!=\""
  def LtE():
        return "\"<=\""
  def GtE():
        return "\">=\""
  def In():
        return "\"in\""
  def NotIn():
        return "\"not-in\""
  def Is():
        return "\"is\""
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defsubst pyel-string> (a b)
    (and (not (string< a b)) (not (string= a b))))
  
  (defsubst pyel-string<= (a b)
    (or (string< a b) (string= a b)))
  
  (defsubst pyel-string!= (a b)
    (not (string= a b)))
  
  (defsubst pyel-number!= (a b)
    (not (= a b)))
  
  (defsubst pyel-string<= (a b)
    (not (string< a b)))
  
  (defun pyel-list-< (a b)
    "a < b"
    (let ((greator nil)
          e1 e2)
      (while (and a b (equal e1 e2))
        (setq e1 (car a)
              e2 (car b)
              a (cdr a)
              b (cdr b)))
      (pyel-< e1 e2)))
  (defun pyel-list-> (a b)
    "a > b"
    (let ((greator nil)
          e1 e2)
      (while (and a b (equal e1 e2))
        (setq e1 (car a)
              e2 (car b)
              a (cdr a)
              b (cdr b)))
      (pyel-> e1 e2)))
  
  (defsubst pyel-list>= (a b)
    (or (equal a b) (pyel-list-> a b)))
  
  (defsubst pyel-list<= (a b)
    (or (equal a b) (pyel-list-< a b)))
  
  (defun pyel-vector-> (a b)
    (let* ((greator nil)
           (len-a (length a))
           (len-b (length b))
           (len (min len-a len-b))
           (i 0)
           e1 e2)
      (while (and (< i len)
                  (equal e1 e2))
        (setq e1 (aref a i)
              e2 (aref b i)
              i (1+ i)))
      (or (pyel-> e1 e2)
          (and (= i len)
               (equal e1 e2)
               (> len-a len-b)))))
  (defun pyel-vector-< (a b)
    (let* ((greator nil)
           (len-a (length a))
           (len-b (length b))
           (len (min len-a len-b))
           (i 0)
           e1 e2)
      (while (and (< i len)
                  (equal e1 e2))
        (setq e1 (aref a i)
              e2 (aref b i)
              i (1+ i)))
      (or (pyel-< e1 e2)
          (and (= i len)
               (equal e1 e2)
               (< len-a len-b)))))
  
  (defsubst pyel-vector-<= (a b)
    (or (equal a b) (pyel-vector-< a b)))
  
  (defsubst pyel-vector->= (a b)
    (or (equal a b) (pyel-vector-> a b)))
  
  (defsubst !equal (a b)
    (not (equal a b)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests compare
                     "a=='d'"
                     "a==b"
                     "a>=b"
                     "a<=b"
                     "a<b"
                     "a>b"
                     "a!=b"
                     "(a,b) == [c,d]"
                     "[a == 1]"
                     "((a == 1),)"
                     "a<b<c"
                     "a<=b<c<=d"
                     "a.b<=b.c()<c<=3")
#+END_SRC
** if
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform if pyel ()
    (lambda (test body orelse &optional line col)
      (let* ((tst (transform test))
             (true-body (append (remove-context tail-context
                                                (mapcar 'transform
                                                        (or (subseq body 0 -1)
                                                            (list (car body)))
                                                            ))
                                  (when (> (length body) 1)
                                    (list (transform (car (last body)))))))
             (progn-code (if (> (length true-body) 1)
                             '(@ progn)
                           '@)))
  
        `(if  ,(if (equal tst []) nil tst)
  
             (,progn-code ,@true-body)
           ,@(append (remove-context tail-context
                                     (mapcar 'transform
                                             (subseq orelse 0 -1)))
                     (when (> (length orelse) 1)
                            (list (transform (car (last orelse))))))))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def If (test, body, orelse, lineno='nil', col_offset='nil'):
      return l_str(["if ",test, ll_str(body), ll_str(orelse), lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests if
                     "if (a==b):
    b=c
  else:
    a = d"

                     "if (a==b):
     b=c
     z=1
  else:
    a = 4
    b = a.b"

                     "if (a.b <= a.e):
   a.b=(2.1,2)
  else:
   b.a.c=[a,{'a':23.3,'b':(3.2,3.1)}]"
                     )
#+END_SRC
** call
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (defvar pyel-obj-counter 0)
  
  (defun pyel-next-obj-name ()
    (if pyel-unique-obj-names
        (format "obj-%d" (setq pyel-obj-counter (1+ pyel-obj-counter)))
      "obj"))
  
  ;; (pyel-dispatch-func fcall (_func &rest args)
  ;;                      ($func _) -> ($func ,@args)
  ;;                      (_ _) -> (funcall $func ,@args))
  
  ;; functions set to variables override those defined with `defun'
  ;; this allows locally defined functions to override their global
  ;; counterparts without defining themselves globally
  (pyel-dispatch-func fcall (_func &rest _args)
                      (vfunc _) -> (funcall $func ,@(pyel-sort-kwargs args))
                      ($function _) -> ($func ,@(pyel-sort-kwargs args))
                      (class _) -> (call-method $func --new--
                                                ,@(pyel-sort-kwargs args))
                      (instance _) -> (call-method $func --call--
                                               ,@(pyel-sort-kwargs args))
                      (_ _) -> ($func ,@(pyel-sort-kwargs args));;for macros
                      )
  
  (def-transform keyword pyel ()
    (lambda (arg value &optional line col)
      (if (context-p 'keywords-alist)
          (list (_to- arg) (transform value))
        (list '@ (_to- arg)  '= (transform value)))))
  
  (def-transform call pyel ()
    ;;TODO: some cases funcall will need to be used, how to handle that?
    (lambda (func args keywords starargs kwargs &optional line col)
      (pyel-call-transform func args keywords starargs kwargs line col)))
  
  (defun pyel-call-transform (func args keywords starargs kwargs &optional line col)
    (let ((t-func (transform func))
          (keyword-args (using-context keywords-alist
                                       (mapcar (lambda (x) (transform (car x)))
                                               keywords)))
          new-func m-name f-name star-args kw-args)
      ;; (if (member t-func pyel-defined-classes)
      ;;     ;;instantiate an object and call its initializer
      ;;     `(let ((__c (,t-func ,(pyel-next-obj-name))))
      ;;        (--init-- __c ,@(mapcar 'transform args))
      ;;        __c)
      
      (if (eq (car func) 'attribute);;method call
          (if (and (member (setq m-name (read (caddr func)))
                           pyel-method-transforms)
                   (setq m-name (pyel-find-method-transform-name
                                 m-name
                                 (1+ (length args)))));;1+ because args does not include the object
  
              ;;this methods transform is overridden
              (progn
                ;;dynamic scoping saves the day again!
                (setq keyword-args keywords
                      star-args starargs
                      kw-args kwargs)
  
                (eval `(call-transform ',m-name
                                       ',(transform (cadr func))
                                       ,@(mapcar '(lambda (x) `(quote ,x)) args))))
            ;;normal method call
            (remove-context method-call-override
                            (using-context method-call
                                           `(,(transform func) ,@(remove-context method-call
                                                                                 (mapcar 'transform args))))))
  
        (when (setq new-func (assoc t-func pyel-function-name-translations));;function call
          ;;translate name
          (setq t-func (cadr new-func)))
  
        ;;call function transform if one was defined
        (cond ((member t-func pyel-func-transforms)
               ;;transform defined with `pyel-func-transform'
               (eval `(call-transform ',(pyel-func-transform-name t-func)
                                      ;;',(transform (cadr func))
                                      ,@(mapcar '(lambda (x) `(quote ,x)) args))))
  
              ((member t-func pyel-func-transforms2)
               ;;transform defined with `pyel-define-function-translation'
               (eval `(call-transform ',(pyel-func-transform-name t-func)
                                      ;;,(mapcar '(lambda (x) `(quote ,x)) args)
                                      (mapcar 'transform args)
                                      keyword-args)))
  
              ;;normal function call
              ;;`(,t-func ,@(mapcar 'transform args))
              ;;TODO: this is dumb, convert `call-transform' to a macro?
              (t (eval `(call-transform 'fcall ,@(cons 't-func
                                                       (mapcar (lambda (x)
                                                                 `(quote ,x))
                                                               (append args
                                                                       (mapcar 'car
                                                                               keywords))
                                                               )))))))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Call(func, args, keywords, starargs, kwargs, lineno='nil', col_offset='nil'):
      return l_str(["call ", func, ll_str(args), ll_str(keywords), starargs or "nil" , kwargs or "nil", lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests call
                     "aa()"
                     "aa(b,c(1,2))"
                     ;;"aa()()" does not work yet
                     "aa=b()"
                     ;;"aa.b()"
                     ;;"[aa.b()==4]"
                     "aa(3,b(c(),[2,(2,3)]))"
                     "aa.b()"
                     "aa.b(1,2)"
                     "aa.b(1,a.b(1,2,3))"

                     "a.b().c()"
                     "a.b().c().d()"
                     "a.b(x.y().e()).c()"

                     )
#+END_SRC
** while loop
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform while pyel ()
    (lambda (test body orelse &optional line col)
      (pyel-while test body orelse line col)))
  
  ;;doc: context macro-call
  (defun pyel-while (test body orelse &optional line col)
    ;;pyel-while is special. it gets to handle the macro definitions
    (let* ((tst (transform test))
           (else (mapcar 'transform orelse))
           break-code
           continue-code
           macro-name
           ;;inter-transform variables
           continue-while
           break-while )
  
      (if (and (symbolp tst)
               (string-match (format "^%s\\([A-Za-z0-9_]+\\)$" pyel-py-macro-prefix)
                             (symbol-name tst)))
          (using-context
           macro-call
           ;;expand as a macro call
           `(,(intern (replace-regexp-in-string "_" "-"
                                                (match-string 1 (symbol-name tst))))
             ;;TODO: if macro name is an alias, replace with actual
             ,@(mapcar 'transform body)))
  
        ;;expand as a normal while loop
        (setq t-body (remove-context tail-context
                                     (mapcar 'transform (subseq body 0 -1)))
              t-last (transform (car (last body)))
              code (append t-body (list t-last))
  
              break-code (if break-while '(catch '__break__)
                           pyel-nothing)
              continue-code (if continue-while '(catch '__continue__)
                              pyel-nothing)
              wile `(,@break-code
                     (while
                         ,(if (equal tst []) nil tst)
                       (,@continue-code
                        ,@code))))
        (if else
            `(@ ,wile ,@else)
          wile))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def While(test, body, orelse, lineno='nil', col_offset='nil'):
      return l_str(["while ", test, ll_str(body), ll_str(orelse), lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests while
                     "while (a==b):
    print('hi')"

                     "while (a==b):
    print('hi')
    a=b"

                     "while (a==b):
    while (a>2):
      b(3,[a,2])
      b=c.e
    a=b"

                     "while a:
   if b:
    break
   else:
    c()"

                     "while a:
   if b:
    continue
   c()"

                     )
#+END_SRC
** arguments
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform arguments pyel ()
    (lambda (args vararg varargannotation kwonlyargs kwarg kwargannotation
                  defaults kw_defaults)
      (pyel-arguments args vararg varargannotation kwonlyargs kwarg kwargannotation
                      defaults kw_defaults)))

  (defun pyel-arguments (args vararg varargannotation
                              kwonlyargs kwarg kwargannotation
                              defaults kw_defaults)
    ;;TODO: other args

    (let* ((args (mapcar 'transform args))
           (defaults (mapcar 'transform defaults)))

      ;;create default assignment code
      (when (and defaults
                 (context-p 'function-def))

        ;;`assign-defaults' only exists under function-def context
        (setq assign-defaults (mapcar* (lambda (arg default)
                                         `(setq ,arg (or ,arg ,default)))
                                       (reverse args) (reverse defaults))))

      ;;&optional
      (when defaults
        (insert-at args (- (length args) (length defaults)) '&optional))
      ;;&rest
      (when vararg
        (setq args (append args (list '&rest vararg)))
        (when (and (not pyel-use-list-for-varargs)
                   (context-p 'function-def))
          (push `(setq, vararg (list-to-vector ,vararg)) assign-defaults)))
      ;;&kwarg
      (when kwarg
        (setq args (append args (list '&kwarg kwarg))))

      args))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def arguments(args=None, vararg=None, varargannotation=None, kwonlyargs=None,
                kwarg=None, kwargannotation=None,defaults=None, kw_defaults=None):
      return ll_str(["(arguments ",
                     ll_str(args) or "nil",
                     vararg or "nil",
                     varargannotation or "nil",
                     kwonlyargs or "nil",
                     kwarg or "nil",
                     kwargannotation or "nil",
                     ll_str(defaults) or "nil",
                     kw_defaults or "nil", ")"])
      #return l_str(["_arguments ",ll_str(args) or "nil",vararg or "nil",varargannotation or "nil", kwonlyargs or "nil", kwarg or "nil", kwargannotation or "nil", defaults or "nil", kw_defaults or "nil"])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-test-arguments ()
    (with-transform-table 'pyel
                          (and
                           (should (equal (transform '(arguments ((arg "b" nil)
                                                                  (arg "c" nil)) nil nil nil nil nil nil nil))
  
                                          '(b c)))
                           ;;other tests here
                           )))
#+END_SRC
** function def
includes 'arg' transformation
*** python ast expansion example
"def a(b,c):
  print('ok')
  return c+a"

FunctionDef(name='a',
	    args=arguments(args=[arg(arg='b', annotation=None), arg(arg='c', annotation=None)],
				vararg=None,
				varargannotation=None,
				kwonlyargs=[],
				kwarg=None,
				kwargannotation=None,
				defaults=[],
				kw_defaults=[]),

	    body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='ok')], keywords=[], starargs=None, kwargs=None)), Return(value=BinOp(left=Name(id='c', ctx=Load()), op=Add(), right=Name(id='a', ctx=Load())))],

	    decorator_list=[],
	    returns=None)

*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform arg pyel ()
    (lambda (arg annotation) ;;Ignoring annotation
      (read arg)))
  
  (def-transform def pyel ()
    (lambda (name args body decoratorlist returns &optional line col)
      (pyel-def name args body decoratorlist returns line col)))
  
  (defun transform-last-with-context (context code)
    ;;TODO: this does not work: fix and replace code in `pyel-def
    (let*  ((last-line (using-context context
                                      (transform (car (last code)))))
            (first (mapcar 'transform (subseq code 0 (1- (length code))))))
      (append first (list last-line))))
  
  (defun pyel-def (name args body decoratorlist returns &optional line col)
    (let ((name (read (_to- name))))
  
      (when (context-p 'function-def)
        (push name let-arglist)) ;;do this before the let-arglists gets overridden for this transform
  
      (let* ((func 'def)
             t-body
             arglist
             first
             last-line
  
             ;;trans-template vars
             (assign-defaults (list pyel-nothing));;holds assignment code set by the arguments transform
             return-middle
             let-arglist
             global-vars
             docstring
  
                ;;;
             (ret pyel-nothing)
             (args (_to- (using-context function-def (transform (car args)))))
             (inner-defun (context-p 'function-def))
             (orig-name name)
             (decorators (mapcar 'transform decoratorlist))
             setq-code
             )
  
        (when (or (context-p 'lambda-def)
                  (and inner-defun
                       (not (member '&kwarg args))))
  
          (setq func 'lambda
                name pyel-nothing))
  
        (using-context
         function-def
         (cond
  
          ;; ((context-p 'class-def) (using-context method-def
          ;;                           (setq last-line (using-context tail-context
          ;;                                                          (transform (car (last body))))
          ;;                                 first (mapcar 'transform (subseq body 0 (1- (length body))))
          ;;                                 t-body (append first (list last-line)))
  
          ;;                           ;;TODO: let-arlist for methods like
          ;;                           ;;      and *args ...
          ;;                           (push `(defmethod ,name
          ;;                                    ((,(car args) ,class-def-name)
          ;;                                     ,@(cdr args))
  
          ;;                                    ,@t-body)
          ;;                                 class-def-methods)))
  
          (t (setq last-line (using-context tail-context
                                            (transform (car (last body))))
                   first (subseq body 0 (1- (length body)))
                   first (if first
                             (mapcar 'transform first)
                           nil)
                   t-body (append first (list last-line)))
  
             ;;(setq t-body (transform-last-with-context
             ;;                'tail-context body))
  
             ;;remove variables from the let arglist that have been declared global
             (setq let-arglist (let (arglist) (mapcar (lambda (x)
                                                        (unless (or (member x global-vars)
                                                                    (member x args))
                                                          (push x arglist)))
                                                      let-arglist)
                                    arglist))
             ;;      ?remove variables that are defined in emacs?
  
             (setq docstring
                   (if (stringp (car t-body))
                       (pop t-body)
                     pyel-nothing))
  
             (setq ret (if return-middle '(catch '__return__)
                         '(@)))
  
             (if let-arglist
                 (setq let-arglist (list '@ 'let let-arglist))
               (setq let-arglist '@))
  
             (if inner-defun
                 (progn
                   (if (member '&kwarg args)
                       (setq decorators
                             (cons 'pyel-inner-function-def decorators)))
                   (setq setq-code (list '@ 'setq orig-name)))
               (setq setq-code '@))
  
             `(,setq-code (,func ,name ,args ,decorators
                                 ,docstring
                                 ,@assign-defaults
                                 (,let-arglist
                                  (,@ret
                                   ,@t-body
                                   ))))
             ))))))
  
  (defun pyel-sort-kwargs (args)
    "Organize args in the format required by functions that accept keyword args
  Returns a list whose first element has an alist containing the keyword args
  in the cdr and ':kwargs' in the car position.
  and whose second element is a list of all non-keyword args
  Recognizes keyword args in the form 'arg = value'."
    ;;for use in the 'fcall' transform
    (if (member '= args)
        (let ((current args)
              kwargs
              normal)
          (when (eq (car current) '=) (error "invalid keyword arg syntax"))
          (while current
            (if (eq (car current) '=)
                (progn
                  (when (null (cdr current)) (error "invalid keyword arg syntax"))
                  (push (cons (pop normal) (cadr current)) kwargs)
                  (setq current (cddr current)))
              (push (car current) normal)
              (setq current (cdr current))))
          (list (list 'quote (cons :kwargs kwargs)) (list 'quote (reverse normal))))
      args))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-alist-to-hash (alist)
    "Turn ALIST a hash table."
    (let ((ht (make-hash-table
               :test 'equal
               :size (length alist))))
      (mapc (lambda (x)
              (puthash (car x) (cdr x) ht))
            alist)
      ht))
  
  (defmacro def (name args decorator-list &rest body)
    ;;TODO: apply decorators
    (using-context
     function-def
     (if (member '&kwarg args)
         (let ((n -1)
               (func-name (if (member 'pyel-inner-function-def decorator-list)
                              (progn
                                (setq decorator-list
                                      (remove 'pyel-inner-function-def
                                              decorator-list))
                                '(lambda))
                            (list 'defun name)))
               optional
               pos+optional rest kwarg
               npositional nargs arg-index)
  
           (when (member '&kwarg args)
             (setq kwarg (car (last args))
                   args (subseq args 0 -2)
                   args-without-kwarg args))
           (when (member '&rest args)
             (setq rest (last args)
                   args (subseq args 0 -2)))
           (if (member '&optional args)
               (setq optional (pyel-split-list args '&optional)
                     positional (car optional)
                     optional (cdr optional))
             (setq positional args))
  
           (setq npositional (length positional)
                 nargs (+ (length positional) (length optional))
                 arg-index-alist (mapcar (lambda (x)
                                           (setq n (1+ n))
                                           (cons x n))
                                         (append positional optional)))
  
           `(,@func-name (&rest args)
                         ;;if this is called with keyword args they will be
                         ;;the in an alist in the car position.
                         (if (and (listp (car args))
                                  (eq (caar args) :kwargs))
                             (let* ((kwargs (cdar args))
                                    (args (cadr args))
                                    (len (length args))
                                    (index 0)
                                    (kwargs-used 0)
                                    pos+optional rest arg-index index-value tmp)
                               (cond ((= len ,nargs)
                                      nil)
                                     ((> len ,nargs)
                                      (setq pos+optional (subseq args 0 ,nargs)
                                            rest (subseq args ,nargs)))
                                     (t ;;(< len ,nargs)
                                      (setq pos+optional
                                            (append args (make-list (- ,nargs len) nil)))))
  
                               ;;make alist of index value pairs
                               (setq index-value
                                     (mapcar (lambda (kw)
                                               (if (setq arg-index
                                                         (assoc (car kw) ',arg-index-alist))
                                                   (list (cdr arg-index)
                                                         (cdr kw)
                                                         ;;need reference to remove arg later
                                                         (car arg-index))))
                                             kwargs))
                               ;;set the keyword args values in arg list
                               (setq tmp pos+optional)
                               (while tmp
                                 (when (setq iv (assoc index index-value))
                                   (if (< (car iv) len)
                                       (signal 'TypeError (format ,(format "%s() got multiple values for keyword argument '%%s'" name) (caddr iv)))
                                     )
                                   (setq kwargs (remove (assoc (caddr iv) kwargs) kwargs))
                                   (setcar tmp (cadr iv))
                                   (setq kwargs-used (1+ kwargs-used)))
                                 (setq tmp (cdr tmp))
                                 (setq index (1+ index)))
                               (if (< (+ kwargs-used len) ,npositional)
                                   (signal 'TypeError (format ,(format "%s() takes at least %s arguments (%%s given)" name npositional) (+ kwargs-used len))))
                               (apply (lambda (,@(append positional optional rest) ,kwarg)
                                        ,@body)
                                      (append pos+optional
                                              (list rest (pyel-alist-to-hash kwargs)))))
                           ;;else: called without keyword args
                           (let ((kwargs (make-hash-table :size 0)))
                             (apply (lambda ,args-without-kwarg
                                      (let (,kwarg)
                                        ,@body))
                                    args)))))
  
       ;;else: no &kwarg
       `(defun ,name ,args
          ,@body)
       )))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def FunctionDef(name, args, body, decorator_list, returns, lineno='nil', col_offset='nil'):
      return " ".join(map(str, ["(def \"", name,"\"", ll_str(args), ll_str(body), ll_str(decorator_list) or "nil",returns or "nil", lineno, col_offset, ")"]))
  
  def arg(arg, annotation):
      return "(arg \"" + arg + "\" " + " " + (annotation or "nil") + ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests def
                     "def a(b,c):
    print('ok')
    a=b"
  
                     "def a(b,c):
    if (a==b()):
      c()
      while (a < d.b):
        b,c = 1,3
    a.b.c = [a,(2,2)]"
  
                     "def a():
    return time()"
  
                     "def a(x,y=2,z=4):
   print(z)"
                     "def a(x=1,y=2,z=4):
   print(z)"
                     "def a(x,y,z=4):
   print(z)"
                     "def a(x,y,z=4,*g):
   print(z)"
  
                     ;;optional and variable args
                     "def pyel_test(a,b=1,*c):
   if ab:
    x = a+b
   y = 3
   _a_()
   z.a = 4")
  
  (pyel-create-tests
   function-arguments
   ("def func(__a,__b,c=1,d='two',*rest,**kwargs):
   return [__a,__b,c,d,rest,kwargs]"
    ("repr(func(1,2))"
     "[1, 2, 1, \"two\", [], {}]")
    ("repr(func(1,2,3))"
     "[1, 2, 3, \"two\", [], {}]")
    ("repr(func(1,2,3,4))"
     "[1, 2, 3, 4, [], {}]")
    ("repr(func(1,2,3,4,5))"
     "[1, 2, 3, 4, [5], {}]")
    ("repr(func(1,2,3,4,5,6))"
     "[1, 2, 3, 4, [5, 6], {}]")
    ("repr(func(1,2,3,4,5,6,x = 's'))"
     "[1, 2, 3, 4, [5, 6], {x: \"s\"}]")
    ("repr(func(1,2,3,4,5,6,x = 's',y = 23))"
     "[1, 2, 3, 4, [5, 6], {y: 23, x: \"s\"}]")
    ("repr(func(x = 's',__b = 324,__a = 'n',))"
     "[\"n\", 324, 1, \"two\", [], {x: \"s\"}]")
    ("repr(func(x = 's',__b = 324,__a = 'n',d = 2))"
     "[\"n\", 324, 1, 2, [], {x: \"s\"}]")))
  
  (ert-deftest pyel-test-sort-kwargs ()
    (equal (pyel-sort-kwargs '(a b = 1 5 12 x = 1 3))
           '((a 5 12 3) ((x . 1) (b . 1))))
    (equal (pyel-sort-kwargs '(b = 1 x = 1))
           '(nil ((x . 1) (b . 1))))
    (equal (pyel-sort-kwargs '(b = 1))
           '(nil ((b . 1))))
    (equal (pyel-sort-kwargs '(a b c d))
           '((a b c d) nil))
    (equal (pyel-sort-kwargs '(a b = (b 1 2) 5 12 x = 1 (+ 1 3 ) y = "s"))
           '((a 5 12 (+ 1 3)) ((y . "s") (x . 1) (b b 1 2)))))
#+END_SRC
** bin-op, +, -, *, /, **, |, &
::Q can an overloaded + operator obj be used like:  3+obj
    these transforms assume you can
TODO: FIX: most of these are wrong.
      if one arg is a number, then the other may still be an object
overloadable operators: http://rgruet.free.fr/PQR26/PQR2.6.html#SpecialMethods

emacs bitwise operators: http://www.gnu.org/software/emacs/manual/html_node/elisp/Bitwise-Operations.html

*** transform
TODO: tests!
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform bin-op pyel ()
    (lambda (left op right &optional line col)
      (call-transform op left right)))
  
  (pyel-dispatch-func * (l r)
                      (number _) ->  (* l r)
                      (object _)      -> (call-method l --mul-- r)
                      (_ number) -> (* l r)
                      (_ string)
                      (string _)      -> (pyel-mul-num-str l r))
  
  (pyel-dispatch-func + (lhs rhs)
                      (number _) -> (+ lhs rhs)
                      (string _) -> (concat lhs rhs)
                      (list _)   -> (append lhs rhs)
                      (object _) -> (call-method l --add-- r)
                      (_ number)  -> (+ lhs rhs)
                      (vector _)
                      (_ vector)  -> (vconcat lhs rhs)
                      (_ string) -> (concat lhs rhs)
                      (_ list)   -> (append lhs rhs))
  
  (pyel-dispatch-func - (l r)
                      (number _) -> (- l r)
                      (object _) -> (call-method l --sub-- r)
                      (_ number) -> (- l r))
  
  (pyel-dispatch-func ** (l r) ;;pow
                      (number _) -> (expt l r)
                      (object _) -> (call-method l --pow-- r)
                      (_ number) -> (expt l r))
  
  (pyel-dispatch-func / (l r)
                      (number _) -> (pyel-div l r)
                      (object _) -> (call-method l --truediv-- r)
                      (_ number) -> (pyel-div l r))
  
  (pyel-dispatch-func // (l r) ;;floored (normal) division
                      (number _) -> (/ l r)
                      (object _) -> (call-method l --floordiv-- r)
                      (_ number) -> (/ l r))
  
  (pyel-dispatch-func ^ (l r) ;;bit xor
                      (number _) -> (logxor l r)
                      (object _) -> (call-method l --xor-- r)
                      (_ number) -> (logxor l r))
  
  (pyel-dispatch-func & (l r) ;;bit and
                      (number _) -> (logand l r)
                      (object _) (call-method l --and-- r)
                      (_ number) -> (logand l r))
  
  (pyel-dispatch-func | (l r) ;;bit or
                      (number _) -> (logior l r)
                      (object _) -> (call-method l --or-- r)
                      (_ number) -> (logior l r))
  
  (pyel-dispatch-func % (l r)
                      (number _) -> (% l r)
                      (object _) -> (call-method l --mod-- r))
  
  
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def BinOp(left, op, right, lineno='nil', col_offset='nil'):
      return l_str(["bin-op ", left, op, right, lineno, col_offset])

  def Add():
      return "+"
  def Mult():
      return "*"
  def Sub():
      return "-"
  def Div():
      return "/"
  def FloorDiv():
      return "//"
  def Pow():
      return "**"
  def BitXor():
      return "^"
  def BitOr():
      return "|"
  def BitAnd():
      return "&"
  def Mod():
      return "%"
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
    (defun pyel-mul-num-str (left right)
      "not implemented"
      )
  
  (defmacro pyel-div (l r)
    (cond ((or (floatp l)
               (floatp r))
           `(/ ,l ,r))
          ((integerp l)
           `(/ ,(* 1.0 l) ,r))
          ((integerp r)
           `(/ ,l ,(* 1.0 r)))
          (t `(/ (* ,l 1.0) ,r))))
#+END_SRC
*** tests TODO
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests binop
                     "assert 1//2 == 0"
                     "assert 1/2 == 0.5")
#+END_SRC
** subscript,index,slice
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (defclass PySlice nil ;;TODO: name?
    ((start :initarg :start)
     (end :initarg :end)
     (step :initarg :step)))
  
  (def-transform index pyel ()
    (lambda (value &optional line col)
      (transform value)))
  
  (def-transform slice pyel ()
    (lambda (lower upper step)
      (PySlice "slice"
               :start (transform lower)
               :end (transform upper)
               :step (transform step))))
  
  (def-transform subscript pyel ()
    (lambda (value slice ctx &optional line col)
      (pyel-subscript value slice ctx line col)))
  
  (pyel-dispatch-func subscript-load-index (name value)
                      (list _) -> (nth value name)
                      (object _) -> (--getitem-- name value)
                      (vector _) -> (aref name value)
                      (string _) -> (char-to-string (aref name value))
                      (hash _) -> (gethash value name))
  
  (pyel-dispatch-func subscript-load-slice (name start end step)
                      (object _ _ _) -> (--getitem-- name (PySlice "slice"
                                                                   :start start
                                                                   :end  end
                                                                   :step  step))
                      ;;TODO implement step
                      (_ _ _ _) -> (subseq name start end))
  
  (pyel-dispatch-func subscript-store-slice (name start end step assign)
                      (object _ _ _) -> (--setitem-- name
                                                     (PySlice "slice"
                                                              :start start
                                                              :end  end
                                                              :step  step)
                                                     assign)
  
                      ;;TODO implement step
                      (_ _ _ _) -> (setf (subseq name start end) assign))
  
  (pyel-dispatch-func subscript-store-index (name value assign)
                      (list _) -> (setf (nth value name) assign)
                      (object _) -> (--setitem-- name value assign)
                      (vector _) -> (setf (aref name value) assign)
                      (hash _) -> (puthash value assign name))
  ;;                  (string _) -> not supported in python
  
  (defun pyel-subscript (value slice ctx &optional line col)
    (let* (;(value (transform value))
           (slice (transform slice))
           (ctx (cond ((context-p 'force-load) 'load)
                      ((context-p 'force-store) 'store)
                      (t (eval ctx))))
           start stop step)
  
      (when (object-p slice)
        (setq start (oref slice start)
              stop (oref slice end)
              step (oref slice step)))
      (if (eq ctx 'load)
          (if (object-p slice)
              (call-transform 'subscript-load-slice value start stop step) ;;load slice
            (call-transform 'subscript-load-index value slice)) ;;load index
        ;;else: store
        (if (object-p slice)
            (call-transform 'subscript-store-slice value start stop step assign-value)
          (call-transform 'subscript-store-index value slice assign-value)) ;;load index
  
        ;;      (test value start stop step assign-value)
        )))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Slice(lower, upper, step):
      step = step or "nil"
      lower = lower or 0
      upper = upper or "nil"
      return l_str(["slice", lower, upper, step])

  def Index(value, lineno='nil', col_offset='nil'):
      return "(index " + value + " " + str(lineno) + " " + str(col_offset) + ")"

  def Subscript(value, slice, ctx, lineno='nil', col_offset='nil'):
      return ll_str(["subscript", value, slice, ctx, lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
  subscript
   ;;load index====
   ;;string
   "a = '1X23'
  assert a[1] == 'X'"
   ;;list
   "a = [1,2,3,4]
  assert a[1] == 2"
   ;;vector
   "a = (1,2,3,4)
  assert a[1] == 2"
   ;;object
   "class a:
   def __getitem__ (self, value):
    return value + 4
  x = a()
  assert x[1] == 5"
   ;;=load slice====
   ;;vector
   "a = (1,2,3,4,5)
  assert a[1:4] == (2,3,4)
  assert a[:4] == (1,2,3,4)
  assert a[2:] == (3,4,5)
  assert a[:] == (1,2,3,4,5)"
   ;;list
   "a = [1,2,3,4,5]
  assert a[1:4] == [2,3,4]
  assert a[:4] == [1,2,3,4]
  assert a[2:] == [3,4,5]
  assert a[:] == [1,2,3,4,5]"
   ;;strings
   "a = '012345678'
  assert a[1:4] == '123'
  assert a[:4] == '0123'
  assert a[2:] == '2345678'
  assert a[:] == '012345678'"
   ;;object
   "class a:
   def __getitem__ (self, value):
    return value.start + value.end
  x = a()
  assert x[1:2] == 3
  assert x[5:7] == 12"

   ;;store index
   ;; list
   "def __add(a,b):
   return a+b
  a = [1,2,3,4]
  a[0] = __add(a[1],a[2])
  assert a[0] == 5
  a[2] = 'str'
  assert a[2] == 'str'"
   ;;vector
   "a = (1,2,3,4)
  a[0] = a[1] + a[2]
  assert aa[0] == 5
  a[2] = 'str'
  assert a[2] == 'str'"
   ;;object
   "class a:
   def __setitem__ (self, index, value):
    self.index = index
    self.value = value
  x = a()
  x[3] = 5
  assert x.index == 3
  assert x.value == 5"

   ;;store slice
   ;;list
   "a = [1,2,3,4,5,6]
  a[1:4] = [5,4,'f']
  assert a == [1,5,4,'f',5,6]
  a[:3] = ['a',4,2.2]
  assert a == ['a',4,2.2,'f',5,6]
  a[3:] = [3,3]
  assert a == ['a', 4, 2.2, 3, 3, 6]#TODO: should == ['a', 4, 2.2, 3, 3]"
   ;;vector
   "a = (1,2,3,4,5,6)
  a[1:4] = (5,4,'f')
  assert a == (1,5,4,'f',5,6)
  a[:3] = ('a',4,2.2)
  assert a == ('a',4,2.2,'f',5,6)
  a[3:] = (3,3)
  assert a == ('a', 4, 2.2, 3, 3, 6)#TODO: should == ('a', 4, 2.2, 3, 3)"
   ;;string
   "a = '123456'
  a[1:4] = '54f'
  assert a == '154f56'
  a[:3] = 'a42'
  assert a == 'a42f56'
  a[3:] = '33'
  assert a == 'a42336'#TODO: should == 'a4233'"
   ;;object
   "class a:
   def __setitem__ (self, index, value):
    self.start = index.start
    self.end = index.end
    self.step = index.step
    self.value = value
  x = a()
  x[2:3] = [1,2,3]
  assert x.start == 2
  assert x.end == 3
  assert x.value == [1,2,3]"

  "a[2] += 3"
  "a[2] += b[3]"

  "[2,3,3][2]"
  "assert [1,2,(3,2,8)][2][2] == 8"
   )
#+END_SRC

** class
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform classdef pyel ()
    (lambda (name bases keywords starargs kwargs
                  body decorator_list &optional line col)
      (pyel-defclass name bases keywords starargs kwargs
                     body decorator_list line col)))
  
  (defun pyel-defclass (name bases keywords starargs kwargs
                             body decorator_list &optional line col)
    (let ((class-def-methods nil) ;; list of methods that are part of this class
          (class-def-slots nil) ;;list of slots that are part of this class
          (class-def-name (transform name))
          (t-bases (mapcar 'transform bases)))
      ;;transform body with the class-def context, the transformed code
      ;;will store its methods and slots in class-def-methods and class-def-slots
      ;;respectively.
      (when (context-p 'function-def)
        (push name let-arglist)
        (push '__defined-in-function-body t-bases))
      (remove-context
       function-def
       (using-context class-def
                      (add-to-list 'pyel-defined-classes name)
                      `(define-class ,name ,t-bases
                         ,@(mapcar 'transform body)
                         )))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def ClassDef (name, bases, keywords, starargs, kwargs, body, decorator_list, lineno='nil', col_offset='nil'):
    return ll_str(["classdef",
                   name,
                   ll_str(bases),
                   ll_str(keywords),
                   starargs or "nil",
                   kwargs or "nil",
                   ll_str(body),
                   ll_str(decorator_list),
                   lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   objects
   ("class tclass():
   '''a test class'''
   cvar = 12
   def __init__(self, x):
    self.a = x + 10
   def get(self):
    return self.a
   def set(self,n):
    self.a = n
  x = tclass(4)"
    ("tclass.__name__" "tclass")
    ("tclass.get" (lambda (self) (getattr self a)))
    ("tclass.set" (lambda (self n) (setattr self a n)))
    ("tclass.cvar" 12)
    ("tclass.v = 'hi'" ("tclass.v" "hi"))
    ("tclass.set(tclass, 23)" ("tclass.a" 23))
    ("tclass.set(tclass, 19)" ("tclass.get(tclass)" 19))
    ("tclass.add5 = lambda self: self.cvar + 5" ("tclass.add5" (lambda (self) nil (pyel-+ (getattr self cvar) 5))))
    ("repr(x)" "<class 'object'>")
    ("x.__class__ == tclass" t)
    ("x.__class__.__name__" "tclass")
    ("x.a" 14)
    ("x.a = 2" ("x.a" 2))
    ("x.cvar = 4" (" x.cvar, tclass.cvar" [4 12]))
    ("x.set(10); y = x.get" ("y()" 10))
    ("tclass.sixmore = lambda self: self.a + 6
  y = x.sixmore
  x.a = 2"
     ("y()" 8)))

   ("class one:
   def __init__(self,x):
    self.n = x
   def m(self):
    return self.n + 1
  class two:
   def __init__(self):
    self.other = one(5)
  x = two()"
    ("x.other.n" 5)
    ("x.other.m()" 6)))

  (pyel-create-tests
   special-method-lookup
   ( "class adder:
   def __init__(self, n):
    self.x = n
   def __call__ (self, n):
    return self.x + n
  c = adder(10)
  d = adder(10)
  d.__call__ = lambda : 'hi'"
     ("c(6)" 16)
     ("repr(c.__call__)"
      "<bound method adder.__call__ of adder object at 0x18b071>")
     ("d.__call__" (lambda nil nil "hi"))))
#+END_SRC
** assert
*** transform
;;TODO: have custom option for t/nil value of assert's 2nd parameter

;;TODO: fix this case:
  (pyel "assert (True,1), 'message'")
   -> (assert (vector True 1) t "message")
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform assert pyel ()
    (lambda (test msg &optional line col)
      (pyel-assert test msg line col)))
  
  (defun pyel-assert (test msg &optional line col)
    `(assert ,(transform test) t ,(transform msg)))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Assert(test, msg, lineno='nil', col_offset='nil'):
      return ll_str(["assert ", test , msg or "nil", lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests assert
                     "assert sldk()"
                     "assert adk,'messsage'")
#+END_SRC
** for loop
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform for pyel ()
    (lambda (target iter body orelse &optional line col)
      (pyel-for target iter body orelse line col)))
  
  ;;TODO: for a,y in thing: ...
  ;;TODO: check if iter is an object, then do the iterator thing
  
  (defun pyel-for (target iter body orelse &optional line col)
    (let ((target (using-context for-loop-target
                                 (if (eq (car target) 'tuple)
                                     (mapcar 'transform (cadr target))
                                   (list (transform target)))))
          (body (using-context for (mapcar 'transform body)))
          (else (mapcar 'transform orelse))) ;;break/continue for else?
      (when else
        (setq body (append body (cons 'else else))))
  
      `(py-for ,@target in ,(transform iter) ,@body)))
  
  ;; (if (eq (car target) 'tuple)
  ;;     "TODO: var unpacking"
  ;;   ;;create a temp target variable
  ;;   ;;in body, unpack that into the provided target variables
  
  ;;   (let* ((continue-for nil)
  ;;          (break-for nil)
  ;;          (code (using-context for (mapcar 'transform body)))
  ;;          (break-code (if break-for '(catch '__break__)
  ;;                        pyel-nothing))
  ;;          (continue-code (if continue-for '(catch '__continue__)
  ;;                           pyel-nothing)))
  ;;     (setq _x break-for)
  ;;     `(,@break-code
  ;;       (loop for ,(using-context for-loop-target
  ;;                                 (transform target))
  ;;             in (py-list ,(transform iter))
  ;;             do (,@continue-code
  ;;                 ,@(mapcar 'transform body)))
  ;;       ,@(mapcar 'transform orelse)))))
  
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def For(target, iter, body, orelse, lineno='nil', col_offset='nil'):
      return l_str(["for ", target, iter, ll_str(body), ll_str(orelse), lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defmacro py-for (&rest args)
    "(for <targets> in <iter> <body> else <body>)
  else is optional"
  
    ;;TODO: error checking for correct form
    (let* ((targets (pyel-split-list args 'in))
           (args (cdr targets))
           (targets (car targets))
           (iter (pop args)) ;;TODO: must iter be only one form?
  
           (body (pyel-split-list args 'else))
           (else-body (cdr body))
           (body (car body))
  
           (target (cond ((symbolp targets) ;;nil when there are multiple targets
                          targets)
                         ((= (length targets) 1)
                          (car targets))
                         (t nil)))
  
           (unpack-code (unless target
                          (let (ret)
                            (dotimes (i (length targets) (reverse ret))
                              (push `(setq ,(nth i targets)
                                           (nth ,i __target__))
                                    ret)))))
           (unpack-code (cons '(setq __target__ (nth __idx __tmp-list)) unpack-code))
  
           (current-transform-table (get-transform-table 'for-macro))
           __for-continue ;;these are set by the for-macro transforms
           __for-break
           )
      ;;TODO: when multiple targets, check that all lists are the same size
      (setq body (transform (setq _x body)))
  
      (setq body (cons '(setq __idx (1+ __idx))  body)
            body (if target
                     (cons `(setq ,target (nth __idx __tmp-list)) body)
                   (append unpack-code body)))
  
      (when __for-continue
        (setq body `((catch '__continue__ ,@body))))
  
      ;; ! This assumes that all iters are the same size
      (setq body `((while (< __idx __len)
                     ,@body)
                   ,@else-body))
  
      (when __for-break
        (setq body `((catch '__break__ ,@body))))
  
      `(let* ((__tmp-list ,iter)
              ;;      ,@iter-lets
              ;;      ,@next-function-lets
              (__len (length __tmp-list))
              (__idx 0)
              )
         ,@body)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests for-loop
                     "b = [1,2,3,4]
  c = 0
  for a in b:
   c = c + a
  assert c==10"

                     "for i in range(n):
   break"

                     "for i in range(n):
   continue"

                     "x = []
  for i in range(5):
   if i == 2:
    continue
   x.append(i)
  assert x == [0,1,3,4]"
                     )
#+END_SRC
** global
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform global pyel ()
    (lambda (names &optional line col)
      (if (context-p 'function-def)
          (progn (mapc (lambda (x) (add-to-list 'global-vars (_to- x))) names)
                 pyel-nothing)
        (pyel-not-implemented "'global' calls outside of function definitions"))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Global(names, lineno='nil', col_offset='nil'):
    return l_str(['global', l_str(names), lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests global

                     "def a():
   global x
   x = 3
   y = 1"

                     "x = 1
  y = 1
  def func():
   global x
   x = 7
   y = 7
  func()
  assert x == 7
  assert y == 1
  "
                     )
#+END_SRC
** nonlocal
DOC: 'nonlocal' is currently equivalent to 'global'
     It seems to be working fine...
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el

 #+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Nonlocal(names, lineno='nil', col_offset='nil'):
    return l_str(['global', l_str(names), lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** lambda
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform lambda pyel ()
    (lambda (args body &optional line col)
      (using-context lambda-def
                     (pyel-def "dkl" args body nil nil line col))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Lambda(args, body, lineno='nil', col_offset='nil'):
      return ll_str(["lambda", ll_str(args),'('+ll_str(body)+')', lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests lambda
                     "lambda x,y,z=4,*g: print(z);x()"
                     "x = range(2, 9)
  x2 = reduce(lambda a,b:a+b, x)
  assert x2 == 35"
                     )
#+END_SRC
** unary op, not, usub
TODO: tests!
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform unary-op pyel ()
    (lambda (op operand &optional line col)
      (call-transform op operand)))
  
  (pyel-dispatch-func not (x)
                      (object) -> (--not-- x) ;;?
                      (_) -> (not x))
  
  (pyel-dispatch-func usub (x)
                      (number) -> (- x)
                      (object) -> (--usub-- x) ;;?
                      )
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def UnaryOp(op, operand, lineno='nil', col_offset='nil'):
      return l_str(["unary-op ", op, operand, lineno, col_offset])

  def Not():
      return "not"

  def USub():
      return "usub"
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** augmented assignment
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform aug-assign pyel (target op value)
    (lambda (target op value &optional line col)
      (call-transform 'assign
                      `(,target)
                      (call-transform  op
                                       ;;TODO: what if this is something else
                                       ;;other then a simple name?
                                       ;;=> ok as long as nothing acknowledges
                                       ;;   the  force-load context
                                       (using-context force-load
                                                      (transform target))
                                       value))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def AugAssign(target, op, value, lineno='nil', col_offset='nil'):
      return l_str(['aug-assign', target, op, value, lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests aug-assign
                     "a += b"
                     "a -= b"
                     "a /= b"
                     "a *= b"
                     "a **= b"
                     "a ^= b"
                     "a |= b"
                     "a = 3
    b = 4
    a += b + 1
    assert a == 8"
  
                     "a.b += a[2]"
                     "a.b += 4"
                     "a.b += d.e"
                     )
  
#+END_SRC
** return
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform return pyel ()
    (lambda (value &optional line col)
  
      (if (context-p 'tail-context)
          (transform value)
        (setq return-middle t)
        `(throw '__return__ ,(transform value)))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Return(value, lineno='nil', col_offset='nil'):
      return "(return " + str(value) + " " + str(lineno) + " " + str(col_offset)+ ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** break and continue
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform break pyel ()
    (lambda (&optional line col)
      ;;TODO verify that it is ok to just use one inter-template var for this
      (context-switch
       (while (setq break-while t)
         '(throw '__break__ nil))
       (for (setq break-for t)
            '(break)))))
  
  (def-transform continue pyel ()
    (lambda (&optional line col)
      ;;TODO verify that it is ok to just use one inter-template var for this
      (context-switch
       (while (setq continue-while t)
         '(throw '__continue__ nil))
       (for (setq continue-for t)
            '(continue)))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Break(lineno=None, col_offset=None):
      return l_str(["break", lineno, col_offset])

  def Continue(lineno=None, col_offset=None):
      return l_str(["continue", lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** exception handler
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform except-handler pyel (type name body)
    ;;TODO: name?
    (lambda (type name body &optional line col)
      `(,(or (transform type) 'error)
        ,@(mapcar 'transform body))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def ExceptHandler(type, name, body, lineno='nil', col_offset='nil'):
      return l_str(["except-handler", type or 'nil', name or 'nil', l_str(body), lineno, col_offset])
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** try except
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform try pyel (body handlers orelse)
    ;;TODO: orelse
    (lambda (body handlers orelse &optional line col)
      `(condition-case nil
           ,@(mapcar 'transform body)
         ,@(mapcar 'transform handlers))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def TryExcept(body, handlers, orelse, lineno='nil', col_offset='nil'):
      return l_str(["try", l_str(body), l_str(handlers), l_str(orelse), lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests try
                     "x = ''
  try:
   1 / 0
   x = 'yes'
  except:
   x = 'no'
  assert x == 'no'"

                     "try:
   _a()
  except:
   try:
    _x()
   except:
    _b()"
                     )
#+END_SRC
** in, not in
TODO: tests!
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;;a not in b
  ;; function:    is_not(a, b)  (in the operator module)
  (pyel-dispatch-func not-in (l r)
                      (_ list) -> (not (member l r))
                      (_ vector) -> (not (vector-member l r))
                      (_ object) -> (--not-in-- r l) ;;?
                      )
  
  ;;a in b
  ;; function:    is_(a, b)
  (pyel-dispatch-func in (l r)
                      (_ list) -> (member l r)
                      (_ vector) -> (vector-member l r)
                      (_ object) -> (--in-- r l);;?
                      )
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun vector-member (elt vector)
    "Return non-nil if ELT is an element of VECTOR. Comparison done with `equal'."
    (let ((i 0)
          (len (length vector))
          found)
      (while (and (not found)
                  (< i len))
        (if (equal (elt vector i) elt)
            (setq found t)
          (setq i (1+ i))))
      found))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** comprehensions
DOC: generator expressions are translated to list comprehensions
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform comprehension pyel (target iter ifs)
    (lambda (target iter ifs) (pyel-comprehension target iter ifs)))
  
  (defun pyel-comprehension (target iter ifs)
    ;;this uses the inter-transform var 'comprehension-body'
    (assert (boundp 'comprehension-body)
            "`comprehension-body' must be defined for this transform")
    ;;TODO: ifs
    `(loop for ,(using-context for-loop-target
                               (transform target))
           in (py-list ,(transform iter))
           ,(if ifs
                (list '@ 'if
                         (cons (if (> (length ifs) 1)
                                   'and
                                 '@)
                               (mapcar 'transform ifs)))
              pyel-nothing)
           do ,comprehension-body))
  
  (def-transform list-comp pyel (elt generators)
    (lambda (elt generators &optional line col)
      (pyel-list-comp elt generators line col)))
  
  (defun pyel-list-comp (elt generators &optional line col)
    (let* ((list-var '__list__)
           (comprehension-body `(setq ,list-var (cons ,(transform elt) ,list-var)))
           (i (length generators))
           code)
      ;;`comprehension-body' is an inter-transform var
      (while (> i 0)
        (setq i (1- i))
        ;;'comprehension-body' holds the inner code, and each transform
        ;; is the inner code for the preceding generator in 'generators'
        ;; (loop ... collect ...) produces a list, so no additional work is needed
        (setq comprehension-body (transform (nth i generators))))
  
      `(let ((,list-var nil))
         ,comprehension-body
         (reverse ,list-var))))
  
  (def-transform dict-comp pyel (key value generators)
    (lambda (key value generators &optional line col)
      (pyel-dict-comp key value generators line col)))
  
  (defun pyel-dict-comp (key value generators &optional line col)
    (let* ((hash-var '__dict__)
           (comprehension-body (list 'puthash (transform key)
                                     (transform value)
                                     hash-var))
           (i (length generators))
           code)
      (while (> i 0)
        (setq i (1- i))
        (setq comprehension-body (transform (nth i generators))))
  
      `(let ((,hash-var (make-hash-table :test 'equal)))
         ,comprehension-body
         ,hash-var)))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def comprehension(target, iter, ifs):
      return l_str(["comprehension", target, iter, l_str(ifs)])

  def GeneratorExp(elt, generators, lineno='nil', col_offset='nil'):
      return l_str(["list-comp", elt, l_str(generators), lineno, col_offset])

  def ListComp(elt, generators, lineno='nil', col_offset='nil'):
      return l_str(["list-comp", elt, l_str(generators), lineno, col_offset])

  def DictComp(key, value, generators, lineno='nil', col_offset='nil'):
      return l_str(["dict-comp", key, value, l_str(generators), lineno, col_offset])

  def SetComp(elt, generators, lineno='nil', col_offset='nil'):
      return "(unimplemented \"set comprehension\")"
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests list-comprehensions
                     "[x*x for x in range(10)]"
                     "[x*x for x in range(10) if x > 5]"
                     "[x*x for x in range(10) if x > 5 if x < 8]"

                     "assert [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] == [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

                     "
  matrix = [[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],]
  _x = [[row[i] for row in matrix] for i in range(4)]
  assert _x == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

                     "
  transposed = []
  for i in range(4):
   transposed.append([row[i] for row in matrix])
  assert transposed == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
  "

                     "{x: [y*y for y in range(x)] for x in range(20)}"

                     "x = {x: number_to_string(x) for x in range(10)}
  assert hash_table_count(x) == 10
  assert x[1] == '1'
  assert x[9] == '9'
  "
                     )
#+END_SRC

** boolop, and, or
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform boolop pyel (op values)
    (lambda (op values &optional line col)
      (cons op (mapcar 'transform values))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def BoolOp(op, values, lineno='nil', col_offset='nil'):
      return l_str(["boolop", op, l_str(values), lineno, col_offset])
  def Or():
      return "or"
  def And():
      return "and"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests boolop
                     "a or b"
                     "a or b or c"
                     "a.c or b.c() or a[2]"
                     "a and b"
                     "a and b or c"
                     "a[2] and b.f() or c.e"
                     "a.e and b[2] or c.e() and 2 ")
#+END_SRC
** pass
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform pass pyel ()
    (lambda (&optional line col) nil))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Pass(lineno=None, col_offset=None):
      return l_str(["pass", lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** unimplemented
This will help notify the user when some syntax has not been implemented
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform unimplemented pyel (name)
    (lambda (name)
      (pyel-notify-error "Set comprehensions have not been implemented")
      pyel-error-string))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** conditional expressions
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform if-exp pyel ()
    (lambda (test body orelse &optional line col)
      (let ((tst (transform test)))
        `(if ,(if (equal tst []) nil tst)
             ,(transform body)
           ,(transform orelse)))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def IfExp (test, body, orelse, lineno='nil', col_offset='nil'):
      return l_str(["if-exp", test, body, orelse, lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests conditional-expressions
                     "1 if True else 0"
                     "true() if tst() else false()"
                     "a[1] if a[2:2] else a[2]"
                     )
#+END_SRC
** raise
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform raise pyel ()
    (lambda (exc cause &optional line col)
      `(py-raise ,(transform exc)))) ;;TODO: ignoring cause
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Raise(exc, cause, lineno='nil', col_offset='nil'):
      return l_str(["raise", exc, cause or "nil", lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-raise (exc &optional cause)
    "signal an error with the name of EXC, an class/object
  EXC must be derived from BaseException"
    (if (py-object-p exc)
           ;;;;TODO: after `issubclass' is implemented
        ;; (or (and (py-class-p exc)
        ;;          (issubclass exc BaseException))
        ;;     (and (py-instance-p exc)
        ;;          (issubclass (py-type exc) BaseException)))
        (signal (intern (getattr exc --name--)) exc)
      (signal 'TypeError "TypeError: exceptions must derive from BaseException")))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* function transforms
** simple name changes
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-translate-function-name 'map 'mapcar)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** len
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform len (thing)
                       (object) -> (call-method thing --len--)
                       (_)      -> (length thing))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   len-function
   ("a = [1,2,3,'5']
  b = []
  c = 'str'
  d = (1,2,3,4)"
    ("len(a)" 4)
    ("len(b)" 0)
    ("len(c)" 3)
    ("len(d)" 4))
   ("len('')" 0)
   ("len([3,4])" 2)
   )
#+END_SRC
** range
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (push '(range py-range) pyel-function-name-translations)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-range (start &optional end step)
   (unless end
    (setq end start
     start 0))
   (number-sequence start (1- end) step))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   range-function
   ("range(5)" '(0 1 2 3 4))
   ("range(2,7)" '(2 3 4 5 6))
   ("range(2,20,3)" '(2 5 8 11 14 17)))
#+END_SRC
** input
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'input 'read-string)
#+END_SRC
** list
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'list 'py-list)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list (object)
    "tries to be like python's list function"
    (cond
     ((stringp object)
      (split-string object "" :omit-nulls))
     ((py-object-p object) (pyel-object-to-list object))
     ((vectorp object)
      (mapcar 'identity object))
     ((hash-table-p object)
      (let (keys)
        (maphash (lambda (key value)
                   (setq keys (cons key keys))) object)
        keys))
     ((listp object) (copy-list object))))
  
  (defun pyel-object-to-list (object)
    "assumes that py-object(OBJECT) == t"
    (let ((iter (condition-case nil
                    (call-method object --iter--)
                  (AttributeError
                   (py-raise (TypeError (format
                                         "'%s' object is not iterable"
                                         (getattr object --name--)))))))
          list)
      (condition-case nil
          (while t
            (setq list (cons (call-method iter --next--) list)))
        (StopIteration (reverse list)))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   list-function
   ("list('string')" '("s" "t" "r" "i" "n" "g"))
   ("list([1,2,'3',(2,)])" '(1 2 "3" [2]))
   ("a = [1]
  b = [a,1]
  c = list(b)"
    ("c is b" nil)
    ("c == b" t)
    ("c[0] is a" t))
  
   ("a = [1]
  b = (a, 1)
  c = list(b)"
    ("c" '((1) 1))
    ("c[0] is a" t))
  
   ("list({1:'one', 2:'two', 3:'three'})" '(3 2 1))
  
   ("class a:
   x = 5
   def __iter__(self):
    return self
   def __next__(self):
    if self.x > 0:
     ret = str(self.x)
     self.x -= 1
     return ret
    raise StopIteration
  obj = a()"
    ("list(obj)" '("5" "4" "3" "2" "1"))))
#+END_SRC
** hasattr
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'hasattr 'obj-hasattr)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** isinstance
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'isinstance 'obj-isinstance)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** str
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform str (thing)
                       (number) -> (number-to-string thing)
                       (string) -> (format "\"%s\"" thing)
                       (function) -> (py-function-str thing)
                       (list) -> (py-list-str thing)
                       (object) -> (call-method thing --str--)
                       (vector) -> (py-vector-str thing)
                       (hash) -> (py-hash-str thing)
                       (symbol) -> (symbol-name thing))

  (pyel-translate-function-name 'str 'pyel-str)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun _py-str-sequence (seq)
    "convert SEQ to a string of its python representation
      does not include starting/ending parens or brackets"
    (if (vectorp seq)
        (setq seq (mapcar 'identity seq)))
    (if (listp seq)
        (if (listp (cdr seq))
            (mapconcat (lambda (x) (pyel-str-function x)) seq ", ")
          ;;cons cell
          ;;this should not happend from normal python
          ;;but maybe when interacting with lisp code from python
          (concat (pyel-str-function (car seq))
                  " . "
                  (pyel-str-function (cdr seq))))
      (error "invalid type")))
  
  (defun py-list-str (thing)
    (concat "[" (_py-str-sequence thing) "]"))
  (defun py-vector-str (thing)
    (concat "(" (_py-str-sequence thing) ")"))
  
  (defun py-function-str (func)
    "return a string representation of function FUNC"
    (let* ((obj (bound-method-p func))
           (obj-name (if obj (-to_ (getattr obj --name--)) nil)))
      (if obj
          (format "<bound method %s.%s of %s object at 0x18b071>"
                  obj-name
                  (-to_ (bound-method-name func))
                  obj-name)
        (format "<function %s at 0x18b071>" (if (and (listp func)
                                                     (or (eq (car func) 'lambda)))
                                                "<lambda>"
                                              (symbol-name func))))))
  
  (defun py-hash-str (ht)
    (let (str)
      (maphash (lambda (key value)
                 (push (concat (pyel-str-function key)
                               ": "
                               (pyel-str-function value))
                       str))
               ht)
  
      (concat "{" (mapconcat 'identity (reverse str) ", ") "}")))
  
  ;;temp fix for 'str' transform
  ;;The problem:
  ;; cannot pass a function name to the str transform because the tranform
  ;; treats it like a variable and it may not be bound as a variable
  ;;*This should be temporary because the 'str' transform cannot
  ;;expand this way to take advantage of known types
  (defmacro pyel-str (thing)
    (if (symbolp thing)
        (if (boundp thing)
            (list 'pyel-str-function thing)
          (if (functionp thing)
              `(py-function-str (quote ,thing))
            thing;;error
            ))
      (list 'pyel-str-function thing)))
  
  ;;Currently, the repr and str transforms are not not called directly
  ;;so they never have the change to expand.
  ;;The expanded functions are used so we force expansion here.
  ;;required functions are `pyel-str-function' and `pyel-repr-function'
  ;;;NOTE: this is also done in `pyel-run-tests'
  (let ((current-transform-table (get-transform-table 'pyel)))
    (call-transform (pyel-func-transform-name 'repr) nil)
    (call-transform (pyel-func-transform-name 'str) nil))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   str
   ("str('somestring')" "\"somestring\"")
   ("str(\"'dstring'\")" "\"'dstring'\"")
   ("str(342)" "342")
   ("x = [1,2,'hi']
  str(x)"
    "[1, 2, \"hi\"]")
   ("x = (1,'two',3)
  str(x)"
    "(1, \"two\", 3)")
   ("x = {1: 'one', 5: 'five', 12: 'telve'};
  str(x)"
    "{1: \"one\", 5: \"five\", 12: \"telve\"}")
   ("f = lambda : False
  str(f)"
    "<function <lambda> at 0x18b071>")
   ("def __ff_(): pass
  str(__ff_)"
    "<function --ff- at 0x18b071>"))
#+END_SRC
** repr
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform repr (thing)
                       (number) -> (number-to-string thing)
                       (string) -> (py-repr-string thing)
                       (function) -> (py-function-str thing)
                       (symbol) -> (pyel-symbol-str thing)
                       (list) -> (py-list-repr thing)
                       (object) -> (call-method thing --repr--)
                       (vector) -> (py-vector-str thing)
                       (hash) -> (py-hash-str thing))

  (pyel-translate-function-name 'repr 'pyel-repr)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;;temp function. see `pyel-str' for details
  (defmacro pyel-repr (thing)
    (if (stringp thing)
        (py-repr-string (py-repr-string thing))
      (if (symbolp thing)
          (if (boundp thing)
              (list 'pyel-repr-function thing)
            (if (functionp thing)
                `(py-function-str (quote ,thing))
              thing;;error
              ))
        (list 'pyel-repr-function thing))))
  
  (defsubst py-repr-string (thing)
    (prin1-to-string thing))
  
  (defun _py-repr-sequence (seq)
    (mapconcat (lambda (x) (pyel-repr-function x)) seq ", "))
  
  (defun py-list-repr (thing)
    (concat "[" (_py-repr-sequence thing) "]"))
  
  (defun py-vector-repr (thing)
    (concat "(" (_py-repr-sequence thing) ")"))
  
  (defun pyel-symbol-str (sym)
    (if (eq sym t)
        "True"
      (case sym
        (nil "False")
        (integer "<class 'int'>")
        (float "<class 'float'>")
        (string "<class 'str'>")
        (cons "<class 'list'>")
        (vector "<class 'tuple'>")
        (hash-table "<class 'dict'>")
        (t (symbol-name sym)))))
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   repr
   ("repr('somestring')" "\"\\\"somestring\\\"\"")
   ("repr(342)" "342")
   ("x = [1,2,'hi']
  repr(x)"
    "[1, 2, \"hi\"]")
   ("x = (1,'two',3)
  repr(x)"
    "(1, \"two\", 3)")
   ("x = {1: 'one', 5: 'five', 12: 'telve'}
  repr(x)"
    "{1: \"one\", 5: \"five\", 12: \"telve\"}")
   ("f = lambda : False
  repr(f)"
    "<function <lambda> at 0x18b071>")
   ("def __ff_(): pass
  repr(__ff_)"
    "<function --ff- at 0x18b071>"))
#+END_SRC
** hex
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'hex 'py-hex)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-hex (n)
    (format "0x%x" n))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   hex-function
   ("hex(23)" "0x17")
   ("hex(123232332)" "0x758604c"))
#+END_SRC
** bin
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'bin 'py-bin)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-bin (n) ;;Is there really no built in way to do this???
    (let (bin)
      (while (not (= n 0))
        (push (number-to-string (% n 2)) bin)
        (setq n (/ n 2)))
      (mapconcat 'identity (cons "0b" bin) "")))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   bin-function
   ("bin(123)" "0b1111011")
   ("bin(3456312)" "0b1101001011110100111000"))
#+END_SRC
** print
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;;(pyel-translate-function-name 'print 'py-print)
  (pyel-define-function-translation
   print
   `(py-print ,(cadr (assoc 'sep kwargs))
              ,(cadr (assoc 'end kwargs))
              nil ;;TODO: file=sys.stdout
              ,@args))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defvar pyel-print-function 'prin1
    "function that is used for printing by `py-print'")

  (defun py-print (sep end file &rest args)
    (let ((sep (or sep " "))
          (end (or end "\n")))
      (progn (mapc (lambda (x)
                     (funcall pyel-print-function x)
                     (funcall pyel-print-function sep))
                   (butlast args))
             (funcall pyel-print-function (car (last args)))
             (funcall pyel-print-function end)
             nil)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** pow
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-define-function-translation
   pow
   (case (length args)
     (3 (list 'mod (list 'expt (car args) (cadr args)) (caddr args)))
     (2 (list 'expt (car args) (cadr args)))
     (t "ERROR") ;;TODO
     ))
  
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   pow
   ("pow(2,5,5)" 2)
   ("pow(3,7,20)" 7)
   ("pow(3,7)" 2187)
   ("pow(2,2)" 4))
#+END_SRC
** eval
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'eval 'py-eval)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-eval (source &rest others)
    (if others
        (error "Only the first arg in `py-eval' is implemented"))
    (if (stringp source)
        (eval (pyel source))
      (py-raise (TypeError "eval() arg 1 must be a string, bytes or code object)"))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests eval
                     ("x = 23
  eval('x')" 23))
#+END_SRC
** type
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'type 'py-type)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;;TODO: when the built in type classes are finished and `py-type'
  ;;      returns them, the special cases for the types in
  ;;      `pyel-symbol-str' should be removed
  (defun py-type (object)
    (cond ((or (eq object nil)
               (eq object t))
           "<class 'bool'>") ;;TODO
          ((py-class-p object)
           "<class 'type'>") ;;TODO
          ((py-instance-p object)
           (aref object obj-class-index)) ;;FIX: should special implicit lookup
          (t (type-of object))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   type
   ("type(t)" "<class 'bool'>")
   ("type(3)" 'integer)
   ("type(3.3)" 'float)
   ("type('3')" 'string)
   ("type([3])" 'cons)
   ("type((3,))" 'vector)
   ("type({3:'3'})" 'hash-table)
   ("class testc: pass
  x = testc()
  y = type(x)"
    ("repr(type(x))" "<class 'testc'>")
    ("y is testc" t)))
#+END_SRC
** abs
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform abs (object)
                       (number) -> (abs object)
                       (object) -> (call-method object --abs--))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   abs-function
   ("abs(3)" 3)
   ("abs(-3)" 3)
   ("class C:
   def __abs__(self):
    'doc'
    return 'hi'
  obj = C()"
    ("abs(obj)" "hi")))
#+END_SRC  
** chr
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-translate-function-name 'chr 'byte-to-string)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   chr-function
   ("chr(70)" "F")
   ("chr(50)" "2"))
#+END_SRC

** ord
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-translate-function-name 'ord 'string-to-char)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   chr-function
   ("ord('F')" 70)
   ("ord('2')" 50))
#+END_SRC
** exit
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'exit 'pyel-exit)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
(defun pyel-exit ()
  (if pyel-interactive
      (progn (kill-buffer)
	     (message "you killed ipyel")
	     (throw 'ipyel-quit nil))
    ;;(kill-emacs)
    (save-buffers-kill-terminal)))
#+END_SRC
** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* method transforms
** doc  TODO: move or tangle
*Defining method transforms for build in types*
In python, primitive types such as the list and string are objects. We need to
define the way in which these method calls will be transformed to function
calls in Emacs Lisp. The macro `pyel-method-transform' is used for this.

Definition form is just like normal type transforms, with a few extra requirement
- The first argument is the potential object
- these transforms are responsible for creating the normal
  method call if obj is actually an object and not a primative type
  this must always be last with the type selector (_ _ ... _ ) ->
Example:
#+Begin_SRC emacs-lisp
  (pyel-method-transform append (obj thing)
                         (list _) -> (py-list-append obj thing)
                         (_ _)    -> (call-method obj append thing))
#+End_Src
** append
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform append (obj thing)
                         (list _) -> (py-list-append obj thing)
                         (_ _)    -> (call-method obj append thing))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list-append (list thing)
    "add THING to the end of LIST"
    (cond ;; ((eq (car list) 'py-empty-list)
          ;;  (setcar list thing))
          ((null list) (list thing))
          (t (while (not (null (cdr list)))
               (setq list (cdr list)))
             (setcdr list (list thing)))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   append
   ("a = [1,2,3]
  c = ['a','a']
  b = a
  a.append('hi')"
    ("a" '(1 2 3 "hi"))
    ("a is b" t)
    ("a.append(c)" ("a is b" t))
    ("a.append(c)" ("a[3] is c" t))))
#+END_SRC
** insert
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform insert (obj i x)
                         (list _) -> (py-insert obj i x)
                         (_ _) -> (call-method obj insert i x))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
(defun py-insert (list index object)
  "insert OBJECT into LIST at INDEX"
  (let ((i 0)
	(rest list)
	first)
    (while (< i index)
      (setq first rest)
      (setq rest (cdr rest))
      (setq i (1+ i)))
    (setcdr first (cons object rest)))
  nil)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(pyel-create-tests
 insert
 ("x = [1,2,3]
y = x
x.insert(1,'hi')"
  ("x" '(1 "hi" 2 3))
  ("x is y" t)))
#+END_SRC
** index
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
    (pyel-method-transform index (obj elem)
                           (list _) -> (list-index elem obj)
                           (string _) -> (py-string-index obj elem)
                           (object _) -> (call-method obj index elem)
                           (vector _) -> (vector-index elem obj))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun list-index (elem list)
    "return the index of ELEM in LIST"
    (let ((m (member elem list)))
      (when m
        (- (length list) (length m)))))
  
  (defun vector-index (elem vector)
    "return the index of ELEM in VECTOR"
    (let ((i 0)
          (len (length vector))
          found)
  
      (while (and (< i len)
                  (not found))
        (if (equal (aref vector i) elem)
            (setq found i)
          (setq i (1+ i))))
      found))
  
  (defsubst py-string-index (obj str)
    (string-match (regexp-quote str) obj))
  
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   index-method
   ;;lists
   ("x = [1,(1,2),'5']"
    ("x.index(1)" 0 )
    ("x.index((1,2))" 1)
    ("x.index('5')" 2))
   ;;strings
   ("x = 'importantstring'"
    ("x.index('t')" 5)
    ("x.index('or')" 3)
    ("x.index('g')" 14)
    ("x.index(x)" 0))
    ("x = 'str.ing'"
     ("x.index('.')" 3))
   ;;arrays
   ("x = (1,2,'tree',(3,))"
    ("x.index(1)" 0)
    ("x.index('tree')" 2)
    ("x.index((3,))" 3)))
#+END_SRC
** remove
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform remove (obj x)
                         (list _) -> (py-list-remove obj x)
                         (_ _) -> (call-method obj remove x))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list-remove (list item)
    "remove ITEM from LIST"
    (when (equal (car list) item)
      (setcar list (cadr list))
      (setcdr list (cddr list)))
    (let ((rest list)
          first)
      (while rest
        (if (equal (car rest) item)
            (progn (setcdr first (cdr rest))
                   (setq rest nil))
          (setq first rest
                rest (cdr rest))))
      nil))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   remove-method
   ("x = [1,'2','2',(1,)]
  y = x
  x.remove('2')"
    ("x is y" t))
   
   ("x = [1,'2','2',(1,)]
  x.remove('2')"
    ("x" '(1 "2" [1])))
   
   ("x = [1,'2','2',(1,)]
  x.remove(1)"
    ("x" '("2" "2" [1])))
   
   ("x = [1,'2','2',(1,)]
  x.remove((1,))"
    ("x" '(1 "2" "2"))))
#+END_SRC
** count
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform count (obj elem)
                         (string _) -> (count-str-matches obj elem)
                         (list _) -> (count-elems-list obj elem)
                         (object _)  -> (call-method obj count elem)
                         (vector _) -> (count-elems-vector obj elem))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;;;; this one is slower
  ;;;; maybe faster with a non-regexp search function?
  ;; (defun count-str-matches (string substr)
  ;;   "count number of occurrences of SUBSTR in STRING"
  ;;   (let ((quoted (regexp-quote substr))
  ;;      (start 0)
  ;;      (strlen (length string))
  ;;      (sublen (length substr))
  ;;      (count 0))
  ;;     (while (< start strlen)
  ;;       (setq start (string-match quoted string start))
  ;;       (if start (setq count (1+ count)
  ;;                    start (+ start sublen))
  ;;      (setq start strlen)))
  ;;     count))
  
  (defun count-str-matches (string substr)
    "count number of occurrences of SUBSTR in STRING"
    (with-temp-buffer
      (insert string)
      (goto-char 1)
      (how-many (regexp-quote substr))))
  
  (defun count-elems-list (list elem)
    "return how many times ELEM occurs in LIST"
    (let ((c 0))
      (dolist (x list)
        (if (equal x elem)
            (setq c (1+ c))))
      c))
  
  (defun count-elems-vector (vector elem)
    "return how many times ELEM occurs in VECTOR"
    (let ((c 0)
          (i 0)
          (len (length vector)))
      (while (< i len)
        (if (equal (aref vector i) elem)
            (setq c (1+ c)))
        (setq i (1+ i)))
      c))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(pyel-create-tests
 count-method
 ;;strings
 ("'xxxxx'.count('x')" 5)
 ("'xxxx'.count('xx')" 2)
 ("'xxxx'.count('xxxx')" 1)
 ("'x.xx'.count('.')" 1)
 ;;lists
 ("x = [1,2,3,3,[2],'s']"
  ("x.count(3)" 2)
  ("x.count(2)" 1)
  ("x.count([3,4])" 1)
  ("x.count('s')" 1))
 ;;vector
 ("x = (1,2,3,3,[2],'s')"
  ("x.count(3)" 2)
  ("x.count(2)" 1)
  ("x.count([3,4])" 1)
  ("x.count('s')" 1))
 ("(1,1,1).count(1)" 3))
#+END_SRC
** join
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform join (obj elem)
                         (string _) ->  (mapconcat 'identity elem obj)
                         (_ _)      -> (call-method obj join thing))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
    (pyel-create-tests
     join-method
     ("'X'.join(('f','g'))" "fXg")
     ("' '.join([str(x) for x in range(3)])" "0 1 2")
     ("''.join(['a','b']))" "ab"))
#+END_SRC
** extend
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform extend (obj elem)
                         (list _) ->  (py-list-extend obj elem)
                         (_ _)    ->  (call-method obj extend elem))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list-extend (list iterable)
    "Extend LIST by appending elements from the ITERABLE"
    (let ((rest list)
          prev)
  
      (while rest
        (setq prev rest
              rest (cdr rest)))
      
      (cond ((py-object-p iterable)
             (_py-list-extend-with-object prev iterable))
            ((listp iterable)
             (_py-list-extend-with-list prev iterable))
            ((stringp iterable)
             (_py-list-extend-with-string prev iterable))
            ((vectorp iterable)
             (_py-list-extend-with-vector prev iterable))
            (t (py-raise (TypeError (format "TypeError: '%s' object is not iterable"
                                            (type-of iterable))))))))
  
  (defun _py-list-extend-with-list (list extendlist)
    (while extendlist
      (setcdr list (list (car extendlist)))
      (setq list (cdr list)
            extendlist (cdr extendlist))))
  
  (defun _py-list-extend-with-vector (list vector)
    (let ((len (length vector))
          (index 0))
      (while (< index len)
        (setcdr list (list (aref vector index)))
        (setq list (cdr list)
              index (1+ index)))
      nil))
  
  (defun _py-list-extend-with-string (list string)
    (let ((len (length string))
          (index 0))
      (while (< index len)
        (setcdr list (list (char-to-string (aref string index))))
        (setq list (cdr list)
              index (1+ index)))
      nil))
  
  (defun _py-list-extend-with-object (list object)
    "assumes that py-object(OBJECT) == t"
    (let ((iter (condition-case nil
                    (call-method object --iter--)
                  (AttributeError
                   (py-raise (TypeError (format
                                         "'%s' object is not iterable"
                                         (getattr object --name--))))))))
      (condition-case nil
          (while t
            (setcdr list (list (call-method iter --next--)))
            (setq list (cdr list)))
        (StopIteration nil))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   extend-method
   ;;extend with list
   ("x = [1]
  y = x
  x.extend([1,'2',(3,)])"
    ("x is y" t)
    ("x" '(1 1 "2" [3])))
   ;;extend with vector
   ("x = [1]
  y = x
  x.extend((1,'2',(3,)))"
    ("x is y" t)
    ("x" '(1 1 "2" [3])))
   ;;extend with string
   ("x = [1]
  y = x
  x.extend('extended')"
    ("x is y" t)
    ("x" '(1 "e" "x" "t" "e" "n" "d" "e" "d")))
   ;;extend with object
   ("class a:
   x = 5
   def __iter__(self):
    return self
   def __next__(self):
    if self.x > 0:
     ret = str(self.x)
     self.x -= 1
     return ret
    raise StopIteration
  obj = a()
  x = [1]
  y = x
  x.extend(obj)"
    ("y is x" t)
    ("x" '(1 "5" "4" "3" "2" "1"))))
#+END_SRC
** pop
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform pop (obj &optional a)
                         (list _) -> (py-list-pop obj a)
                         (hash _) -> (py-hash-pop obj a)
                         (_ _)    -> (call-method obj pop a))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list-pop (list &optional index)
    "remove and return item at INDEX from LIST (default last)"
    (let ((rest list)
          (i 0)
          last ret)
      (if index
          (if (= index 0)
              (progn
                (setq ret (car list))
                (setcar list (cadr list))
                (setcdr list (cddr list))
                ret)
            ;; 0 < index < len(list)
            (while (< i index)
              (setq last rest
                    rest (cdr rest)
                    i (1+ i)))
            (setq ret (car rest))
            (setcdr last (cdr rest))
            ret)
        ;;pop last element
        (while (cdr rest)
          (setq prev rest
                rest (cdr rest)))
        (setq ret (car rest))
        (setcdr prev nil))
      ret))
  
  (defun py-hash-pop (ht key)
    (let ((ret (gethash key ht)))
      (remhash key ht)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   pop-method
   ("x = [[1],'s',(2,), 1, 4]
  y = x
  a = x.pop()
  b = x.pop(0)
  c = x.pop(2)
   "
    ("a" 4)
    ("b" '(1))
    ("c" 1)
    ("x is y" t))
  
   ("x = {1:'one',2:'two',3:'three'}
  y = x.pop(2)"
    ("y" "two") 
    ("repr(x)" "{1: \"one\", 3: \"three\"}"))
   )
#+END_SRC
** reverse
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform reverse (obj)
                         (list) ->  (pyel-list-reverse obj)
                         (_)    ->  (call-method obj reverse))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-list-reverse (list)
    "reverse LIST *IN PLACE*"
    (let ((reversed (reverse list))
          (rest list))
      (while reversed
        (setcar rest (car reversed))
        (setq reversed (cdr reversed)
              rest (cdr rest)))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   reverse-method
   ("x = [1,2,3]
  y = x
  x.reverse()"
    ("x" '(3 2 1))
    ("x is y" t)))
#+END_SRC
** lower
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform lower (obj)
                         (string) ->  (downcase obj)
                         (_)    ->  (call-method obj lower))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   lower-method
   ("x = 'aB'
  y = x
  y = x.lower()"
    ("y" "ab")
    ("x" "aB")))
#+END_SRC
** upper
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform upper (obj)
                         (string) ->  (upcase obj)
                         (_)    ->  (call-method obj upper))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   upper-method
   ("x = 'aB'
  y = x
  y = x.upper()"
    ("y" "AB")
    ("x" "aB")))
#+END_SRC
** split
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform split (obj &optional sep maxsplit)
                         (string) ->  (pyel-split obj sep maxsplit)
                         (_)    ->  (call-method obj split sep maxsplit))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-split (string &optional sep maxsplit)
    
    (let ((sep (or (and sep (regexp-quote sep)) "[ \f\t\n\r\v]+")) ;;correct default?
          (ret (split-string string sep t)))
      (if maxsplit
          ret ;;TODO
        ret)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   split-method
   ("x = 'a b c'
  y = x.split()"
    ("y" '("a" "b" "c")))
   ("'a b c'.split()" '("a" "b" "c"))
   ("y = 'a x b x d x'.split()"
    ("y" '("a" "x" "b" "x" "d" "x"))
    ("len(y)" 6)))
#+END_SRC
** strip
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform strip (obj &optional chars)
                         (string) ->  (pyel-strip obj chars)
                         (_)    ->  (call-method obj strip chars))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-strip-left (s &optional chars)
    "Remove whitespace or CHARS at the beginning of S."
    (let ((chars (if chars (format "\\`[%s]+" chars)
                   "\\`[ \t\n\r]+")))
      (if (string-match chars s)
          (replace-match "" t t s)
        s)))
  
  (defun pyel-strip-right (s &optional chars)
    "Remove whitespace or CHARS at the end of S."
    (let ((chars (if chars (format "[%s]+\\'" chars)
                   "[ \t\n\r]+\\'")))
      (if (string-match chars s)
          (replace-match "" t t s)
        s)))
  
  (defun pyel-strip (s &optional chars)
    "Remove whitespace or CHARS at the beginning and end of S."
    (pyel-strip-left (pyel-strip-right s chars) chars))
  
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   strip-method
   ("'\r\nhello \t'.strip('heo')" "hello")
   ("'hello'.strip('heo')" "ll")
   ("x = 'hello'"
    ("x.strip('hlo')" "e")))
#+END_SRC
** get
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform get (obj key &optional default)
                         (hash) ->  (gethash key obj default)
                         (_)    ->  (call-method-with-defaults obj get
                                                               (key) (default)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   get-method
   ("x = {1:'one',2:'two',3:'three'}"
    ("x[1]" "one")
    ("x[1] == x.get(1)" t)
    ("x.get(3, 'd')" "three")
    ("x.get(4, 'd')" "d")))
#+END_SRC
** items
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform items (obj)
                           (hash) -> (pyel-dict-items obj)
                           (_)    -> (call-method obj items))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-dict-items (dict)
    (let (ret)
      (maphash (lambda (key value)
                 (push (list key value) ret))
               dict)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   items-method
   ("x = {1:'one',2:'two',3:'three'}
  y = {8 : 88}
  z = {}"
    ("x.items()" '((3 "three") (2 "two") (1 "one")))
    ("y.items()" '((8 88)))
    ("z.items()" nil)))
#+END_SRC
** keys
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform keys (obj)
                             (hash) -> (pyel-dict-keys obj)
                             (_)    -> (call-method obj key))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-dict-keys (dict)
    (let (ret)
      (maphash (lambda (key value)
                 (push key ret))
               dict)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   keys-method
   ("x = {1:'one',2:'two',3:'three'}
  y = {8 : 88}
  z = {}"
    ("x.keys()" '(3 2 1))
    ("y.keys()" '((8)))
    ("z.keys()" nil)))
#+END_SRC
** values
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform values (obj)
                         (hash) -> (pyel-dict-values obj)
                         (_)    -> (call-method obj values))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-dict-values (dict)
    (let (ret)
      (maphash (lambda (key value)
                 (push value ret))
               dict)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   values-method
   ("x = {1:'one',2:'two',3:'three'}
  y = {8 : 88}
  z = {}"
    ("x.values()" '("three" "two" "one"))
    ("y.values()" '(88))
    ("z.values()" nil)))
#+END_SRC
** popitem
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform popitem (obj)
                         (hash) -> (pyel-hash-popitem obj)
                         (_)    -> (call-method obj popitem))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-hash-popitem (ht)
    (let* ((key (catch '_pop_
                  (maphash (lambda (k v)
                             (throw '_pop_ k))
                           ht)))
           (ret (list key (gethash key ht))))
      (remhash key ht)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   popitem-method
   ("x = {1:'one',2:'two',3:'three'}
  y = x.popitem()"
    ("y" '(1 "one"))
    ("repr(x)" "{2: \"two\", 3: \"three\"}")))
#+END_SRC
** copy
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform copy (obj)
                         (hash) -> (copy-hash-table obj)
                         (_)    -> (call-method obj popitem))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   copy-method
   ("x = {1:['one'],2:'two',3:'three'}
  y = x
  z = x.copy()"
    ("x is z" nil)
    ("x[1] is z[1]" t)))
#+END_SRC
** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
* macro transforms
macros and macroish primitives
** cond
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  ;;;;errors with these
  ;; (pyel-create-tests cond
  ;;                    "x = cond([1 > 2, 'first']
  ;;    [2 == 2, 'second']
  ;;    [5 == 7, 'third']
  ;;    [True, error('wtf')])
  ;; assert x == 'second'"
  ;;                    )
#+END_SRC
** lambda
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  ;;;;Errors with these
  ;; (pyel-create-tests lambda
  ;;                    "x = [2,3,4]
  ;; square = lambda([x]
  ;;  x*x)
  ;; y = mapcar(square,x)
  ;; assert y == [4,9,16]
  ;; "
  ;;                    "f = lambda([x,y]
  ;; if x > y:
  ;;  'x'
  ;; else:
  ;;  'y')
  ;; x=cl_mapcar(f, [1, 2, 3, 4, 5], [4, 2, 1, 6, 3])
  ;; assert x == ['y', 'y', 'x', 'y', 'x']")
#+END_SRC
** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp:tangle py-lib.el

#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC


* ---------------------
* misc
#+Begin_SRC emacs-lisp :tangle pyel.el
(defun char-split-string (string)
  "split a string into its charaters"
  (cdr (butlast (split-string string ""))))


(defun strip-end (string &optional char)
  "if CHAR occurs at the end of STRING, remove it"
  (let ((split (char-split-string string))
	(char (or char " ")))

    (while (string= char (car (last split)))
      (setq split (butlast split)))
    (mapconcat 'identity split "")))

(defun strip-start (string &optional char)
  "if CHAR occurs at the beginning of STRING, remove all occurrences"
  (let ((split (char-split-string string))
	(char (or char " ")))

    (while (string= char (car split))
      (setq split (cdr split)))
    (mapconcat 'identity split "")))

;;built-in equivalent?
(defun file-path-concat (&rest dirs)
  "concatenate strings representing file paths
prevents multiple/none '/' seporating file names"
  (let* ((first (strip-end (car dirs) "/"))
	 (last (strip-start (car (last dirs)) "/"))
	 (dirs (append (list first)
		       (mapcar '(lambda (x)  (strip-start (strip-end x "/") "/"))
			       (cdr (butlast dirs)))
		       (list last))))
    (mapconcat 'identity dirs "/")))
#+END_SRC

* EOF
** main
#+Begin_SRC emacs-lisp :tangle pyel.el
  (require 'transformer)
  (require 'pyel-transforms)
  (require 'pyel-tests-generated)
  (require 'pyel-preprocessor)
  
  (require 'pyel-mode)
  (require 'py-objects)
  (require 'py-lib)
  
  (pyel "this_fixes_a_bug") ;;prevents errors the first time pyel-run-tests is run
  ;;...I'm so sorry
  
  (provide 'pyel)
  ;;pyel.el ends here
#+END_SRC
** transforms
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(provide 'pyel-transforms)
;;pyel-transforms.el ends here
#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(provide 'pyel-tests)
;;pyel-tests.el ends here
#+END_SRC
** py-lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
(provide 'py-lib)
;;py-lib.el ends here
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
#py-ast.py ends here
#+END_SRC

* ------------------
* transform template
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC

** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* .emacs config (move)
#+Begin_SRC emacs-lisp :tangle pyel.el
(setq pyel-use-list-for-varargs t)
;;(setq pyel-directory "path/to/pyel/directory")
;;(require 'pyel)
#+END_SRC
