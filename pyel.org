* todo
** built-in methods
| method           | list? | tuple? | str? | dict? | tests | notes                       |
|------------------+-------+--------+------+-------+-------+-----------------------------|
| append           | X     | -      | -    | -     | X     |                             |
| count            | X     | X      | X    | -     | X     |                             |
| extend           | X     | -      | -    | -     | X     |                             |
| index            | X     | X      | X    | -     | X     |                             |
| insert           | X     | -      | -    | -     | X     |                             |
| pop              | X     | -      | -    | X     | X     |                             |
| remove           | X     | -      | -    | -     | X     |                             |
| reverse          | X     | -      | -    | -     | X     |                             |
| sort             |       | -      | -    | -     |       |                             |
| clear            | -     | -      | -    | X     |       |                             |
| copy             | -     | -      | -    | X     | X     |                             |
| fromkeys         | -     | -      | -    | X     |       |                             |
| get              | -     | -      | -    | X     | X     |                             |
| items            | -     | -      | -    | X     | X     |                             |
| keys             | -     | -      | -    | X     | X     |                             |
| popitem          | -     | -      | -    | X     | X     |                             |
| setdefault       | -     | -      | -    |       |       |                             |
| update           | -     | -      | -    |       |       |                             |
| values           | -     | -      | -    | X     | X     |                             |
| zfill            | -     | -      | X    | -     | X     |                             |
| upper            | -     | -      | X    | X     | X     |                             |
| translate        | -     | -      |      | -     |       |                             |
| title            | -     | -      | X    | -     | X     |                             |
| swapcase         | -     | -      | X    | -     | X     |                             |
| strip            | -     | -      | X    | X     | X     |                             |
| startswith       | -     | -      | X    | -     | X     |                             |
| splitlines       | -     | -      | X    | -     | X     |                             |
| split            | -     | -      | X    | X     | X     |                             |
| rstrip           | -     | -      | X    | -     | X     |                             |
| rsplit           | -     | -      | X    | -     | X     | equivalent to str.split     |
| rpartition       | -     | -      | X    | -     | X     | equivalent to str.partition |
| rjust            | -     | -      | X    | -     | X     |                             |
| rindex           | -     | -      | X    | -     |       |                             |
| rfind            | -     | -      | X    | -     | X     |                             |
| replace          | -     | -      | X    | -     |       |                             |
| partition        | -     | -      | X    | -     | X     |                             |
| lstrip           | -     | -      | X    | -     | X     |                             |
| lower            | -     | -      | X    | X     | X     |                             |
| ljust            | -     | -      | X    | -     | X     |                             |
| join             | -     | -      | X    | -     | X     |                             |
| isupper          | -     | -      | X    | -     | X     |                             |
| istitle          | -     | -      | X    | -     | X     |                             |
| isspace          | -     | -      |      | -     |       |                             |
| isprintable      | -     | -      | X    | -     |       |                             |
| isnumeric        | -     | -      |      | -     |       |                             |
| islower          | -     | -      | X    | -     | X     |                             |
| isidentifier     | -     | -      |      | -     |       |                             |
| isdigit          | -     | -      |      | -     |       |                             |
| isdecimal        | -     | -      |      | -     |       |                             |
| isalpha          | -     | -      | X    | -     | X     |                             |
| isalnum          | -     | -      | X    | -     | X     |                             |
| format-map       | -     | -      |      | -     |       |                             |
| format           | -     | -      |      | -     |       |                             |
| find             | -     | -      | X    | -     | X     |                             |
| expandtabs       | -     | -      |      | -     |       |                             |
| capitalize       | -     | -      |      | -     |       |                             |
| center           | -     | -      |      | -     |       |                             |
| encode           | -     | -      |      | -     |       |                             |
| endswith         | -     | -      |      | -     |       |                             |
| maketrans        | -     | -      |      | -     |       |                             |
| __add__          |       |        |      | -     |       |                             |
| __contains__     |       |        |      |       |       |                             |
| __delitem__      |       | -      | -    |       |       |                             |
| __eq__           |       | -      |      |       |       |                             |
| __ge__           |       | -      |      |       |       |                             |
| __getattribute__ |       |        |      |       |       |                             |
| __getitem__      |       |        |      |       |       |                             |
| __getnewargs__   | -     |        |      | -     |       |                             |
| __hash__         |       |        |      |       |       |                             |
| __gt__           |       |        |      |       |       |                             |
| __iadd__         |       | -      | -    | -     |       |                             |
| __imul__         |       | -      | -    | -     |       |                             |
| __init__         |       |        |      |       |       |                             |
| __iter__         |       |        |      |       |       |                             |
| __le__           |       |        |      |       |       |                             |
| __len__          |       |        |      |       |       |                             |
| __lt__           |       |        |      |       |       |                             |
| __mul__          |       |        |      | -     |       |                             |
| __ne__           |       |        |      |       |       |                             |
| __repr__         |       |        |      |       |       |                             |
| __rmul__         |       |        |      | -     |       |                             |
| __reversed__     |       | -      | -    | -     |       |                             |
| __rmul__         |       |        |      | -     |       |                             |
| __setitem__      |       | -      | -    |       |       |                             |
| __sizeof__       |       |        |      |       |       |                             |

** built-in functions
http://docs.python.org/2/library/functions.html

| function     | status | tests | notes                                    |
|--------------+--------+-------+------------------------------------------|
| abs          | x      | x     |                                          |
| divmod       | x      | x     |                                          |
| input        | x      |       |                                          |
| open         |        |       |                                          |
| staticmethod |        |       |                                          |
| all          |        |       |                                          |
| enumerate    | x      | x     |                                          |
| int          | x      | x     |                                          |
| ord          | x      | x     | strings > 1 char does not raise an error |
| str          | x      | x     |                                          |
| any          |        |       |                                          |
| eval         | x      | x     |                                          |
| isinstance   | x      |       |                                          |
| pow          | -      | x     | assumes numbers                          |
| sum          |        |       |                                          |
| basestring   |        |       |                                          |
| execfile     |        |       |                                          |
| issubclass   |        |       |                                          |
| super        |        |       |                                          |
| bin          | x      | x     |                                          |
| file         |        |       |                                          |
| iter         |        |       |                                          |
| property     |        |       |                                          |
| tuple        | x      | x     |                                          |
| bool         | x      |       |                                          |
| filter       |        |       |                                          |
| len          | x      | x     |                                          |
| range        | x      | x     |                                          |
| type         | x      | x     | non-standard but mostly compatible       |
| bytearray    |        |       |                                          |
| float        | x      | x     |                                          |
| list         | x      | x     |                                          |
| raw_input    |        |       |                                          |
| unichr       |        |       |                                          |
| callable     |        |       |                                          |
| format       |        |       |                                          |
| locals       |        |       |                                          |
| reduce       |        |       |                                          |
| unicode      |        |       |                                          |
| chr          | x      | x     |                                          |
| frozenset    |        |       |                                          |
| long         |        |       |                                          |
| reload       |        |       |                                          |
| vars         |        |       |                                          |
| classmethod  |        |       |                                          |
| getattr      | x      |       |                                          |
| map          | x      |       | ??? really equivalent?                   |
| repr         |        |       |                                          |
| xrange       |        |       |                                          |
| cmp          |        |       |                                          |
| globals      |        |       |                                          |
| max          |        |       |                                          |
| reversed     |        |       |                                          |
| zip          |        |       |                                          |
| compile      |        |       |                                          |
| hasattr      | x      |       |                                          |
| memoryview   |        |       |                                          |
| round        | x      | x     |                                          |
| __import__   |        |       |                                          |
| complex      |        |       |                                          |
| hash         |        |       |                                          |
| min          |        |       |                                          |
| set          |        |       |                                          |
| apply        |        |       |                                          |
| delattr      |        |       |                                          |
| help         |        |       |                                          |
| next         |        |       |                                          |
| setattr      |        |       |                                          |
| buffer       |        |       |                                          |
| dict         | x      | x     |                                          |
| hex          | x      | x     |                                          |
| object       | x      |       |                                          |
| slice        |        |       |                                          |
| coerce       |        |       |                                          |
| dir          |        |       |                                          |
| id           |        |       |                                          |
| oct          |        |       |                                          |
| sorted       |        |       |                                          |
| intern       |        |       |                                          |
| exit         | x      | no    | not of type Quitter, just a function     |

** bugs
*** X break in a while loop 
(cl-prettyprint (pyel "while True:
 if x == 3:
  break"))
(while t
  (if (pyel-== x 3) nil))

*** list augmented assignment
a = [1,2,3]; a += ['hello']
*** X if-else does not work - no else
(pyel "if a:
 b()
else:
 c()")
*** X return in while loop
return in a while loop should always break

def test():
 while True:
  return y
==> (def test nil nil (while t y))
*** X return in an 'if' statement
should remove context of all but last expression
except for the case in which there is only one.
currently:
 does not account for the single expression case

* documentation
TODO: how to export a heading as pdf or into a seporate file?

TODO: update most of this. tranforms have changed
** type switches
 pyel-switch forms are inserted in a backquoted form so an ',' unquote
 may be used. DO NOT UNQUOTE THE ARGUMENTS, they will be replaced later

** from py ast to e-lisp transform
#+Begin_SRC emacs-lisp
  ;;First, get the python ast:
  (py-ast "(a,b)")
  "Module(body=[Expr(value=Tuple(elts=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], ctx=Load()))])
  "
  
  ;;Second create any newly needed python AST interpretor.
  ;; Here we need Tuple(elts,ctx)
  
  def Tuple(elts, ctx):
      return l_str(["tuple ", ll_str(elts), ctx])
  
  ;;Third, define a tranform to convert the function to lisp
  (def-transform tuple pyel ()
    (lambda (elts ctx) ;;Ignoring ctx for now
      (concat "["
              (mapconcat 'transform elts " ")
              "]")))
  
  
  ;;Forth, create tests. Evaluate the expresstion, the test are sent to the kill ring
  (pyel-create-tests 'Tuple
                     "()"
                     "(a, b)"
                     "(a, (b, (c,d)))"
                     "((((((((a))))))))")
#+END_SRC
** ways to define new transforms
TODO:
 how to define a macro transform
TODO: pyel-define-function-translation
*** change a function name
Example:
#+Begin_SRC emacs-lisp
(pyel-translate-function-name 'range 'py-range)
(pyel-translate-function-name 'map 'mapcar)
#+END_SRC
*** change a variable name
Example:
#+Begin_SRC emacs-lisp
(pyel-translate-variable-name 'None 'nil)
#+END_SRC
*** define a general translation
Example:
#+Begin_SRC emacs-lisp
(def-transform assert pyel ()
    (lambda (test msg)
      `(assert ,(transform test) t ,(transform msg))))
#+END_SRC

*** define a method translation
$var replaces var with name of the original var
   (expands to ,var in the macro definition)
 other parameter references are evaluated and assigned to tmp variables
#+Begin_SRC emacs-lisp
(pyel-method-transform append (obj thing)
                  (list _) -> (setq $obj (append obj (list thing)))
                  (_ _)    -> (append obj thing))
#+END_SRC

*** define a function translation
#+Begin_SRC emacs-lisp
  (pyel-func-transform len (thing)
                       (object) -> (__len__ ,thing)
                       (_)      -> (length ,thing))
#+END_SRC
*** type switching transforms
  (pyel-dispatch-func ** (l r) ;;pow
                    (number number) -> (expt l r)
                    (object _ )
                    (_ object) -> (--pow-- l r))

*** declare a name to be a macro
(pyel-declare-macro "save_excursion")
** writing faster code
*** large difference
*** small difference
prevent pyel from converting *varargs to a vector. Instead manipulate it in python as if it were a list instead of a tuple like it normally is.
put the following line in your config:
  (setq pyel-use-list-for-varargs t)
  ==> NO! ALL CHANGES TO CODE TRANSFORMS SHOULD BE INDECATED IN THE PYTHON SOURCE

* headers
** main
#+Begin_SRC emacs-lisp :tangle pyel.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** transforms
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** py-lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  # This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC

* main
header
** require
#+Begin_SRC emacs-lisp :tangle pyel.el
  (add-to-list 'load-path "~/programming/pyel/")
  (add-to-list 'load-path "~/programming/code-transformer/")
  (require 'eieio)
  (require 'cl)
  ;;other requires are at the end
#+END_SRC
** main
#+Begin_SRC emacs-lisp :tangle pyel.el
;; This is a tangled file  -- DO NOT HAND-EDIT --
;;PYEL -> translate PYthon to Emacs Lisp
#+END_SRC

main
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defun mpp (code)
    (let ((pp (pp-to-string code)))
      (insert "\n" pp)))
  
  ;;TODO: more robust checking, return type of error as well
  (defun pyel-is-error (code)
    "return the line of the error in CODE, else nil"
    (let ((line))
      (if (string-match "^Traceback" code)
          (with-temp-buffer
            (insert code)
            (goto-char (point-max))
            (if (re-search-backward "line \\([0-9]+\\)")
                (setq line (match-string 1)))))
      ;;TODO: why is this the actual line number...it should be relative the a bunch of code it's appended to ...
      (and line (string-to-number line))))
  
  (defvar pyel-transform-status nil
    "indicate status (success/fail) of last pyel transform
  status types:
  nil for no error
  ('python ast transform error'  <line number>)
  ")
  
  (defvar pyel-error-string "PYEL ERROR"
    "string returned by `pyel' when it failed to transform")
  
  (defun pyel-py-ast-file-name ()
    "return the full file name of py-ast.el"
    (file-path-concat pyel-directory "py-ast.py"))
  
  (defun pyel (python &optional no-line-and-col-nums include-defuns py-ast-only)
    "translate PYTHON into Emacs Lisp.
  PYTHON is a string.
  include line and column nums in output unless NO-LINE-AND-COL-NUMS is non-nil
  If PY-AST-ONLY, return the un-evaled ast.
  If INCLUDE-DEFUNS, include the list of pyel defined functions in the output
    this is ignored if PY-AST-ONLY is non-nil"
    (assert (eq lexical-binding nil) "pyel requires dynamic scoping")
  
    (setq pyel-marked-ast-pieces nil)
    (setq pyel-transform-status nil) ;;so far so good...
  
    (setq pyel-last-python-code python)
  
    (let* (;;Q general way of replacing backslashes?
           (python (replace-regexp-in-string "\"" "\\\\\"" python))
                                          ;(python (replace-regexp-in-string "\n" "\\\\n" python nil :literal))
  
           ;; (pyel "x = 'x\n'")
           (py-ast "")
           (el-code "")
           (current-transform-table (get-transform-table 'pyel))
           (python (with-temp-buffer
                     (insert python)
                     (pyel-preprocess-buffer2)
                     (buffer-string)))
           (pyel-context nil)
           line ret
           )
  
      ;;?? setting the mark?
      (with-temp-buffer
        ;;    (find-file file)
        ;;    (erase-buffer)
        (insert-file-contents-literally (pyel-py-ast-file-name))
        (goto-char (point-max))
        (insert "\n")
        (setq line (line-number-at-pos))
        (insert (format "print(eval(ast.dump(ast.parse(\"\"\"%s\"\"\")%s)))"
                        python
                        (if no-line-and-col-nums "" ",include_attributes=True")))
        (write-region
         nil
         nil
         pyel-tmp-file nil 'silent))
  
      (setq py-ast (shell-command-to-string (format "python3 %s" pyel-tmp-file)))
      (setq _x py-ast)
      (if (setq py-error (pyel-is-error py-ast))
          (progn
            (setq pyel-python-error-line py-error)
            pyel-error-string)
        ;;else: no error
        (if py-ast-only
            py-ast
          ;;      (pyel-do-splices (transform (read py-ast))))))
          ;;read can only return one sexp so we need to put it in a progn or something
          ;;similar
  
          (setq ret (pyel-do-splices (if include-defuns
                                         (list '@ (cons '@ pyel-function-definitions)
                                                  (transform (read (format "(@ %s)" py-ast))))
                                       (transform (read  (format "(@ %s)" py-ast))))))
          ;;TODO: this is a temp solution for convenience
          (mapc 'eval pyel-function-definitions)
          ret
          ))))
  
  (defvar pyel-last-python-code nil
    "last python string `pyel' attempted to transform")
  
  (defun pyel-buffer-to-string (&optional ast-only)
    "transform python in current buffer and return a string"
    ;;THIS DOES NOT RETURN A STRING!
    (pyel (buffer-string) ast-only))
  
  (defvar pyel-pp-function 'pp-to-string
    "function that pretty prints pyel e-lisp code")
  
  (defun pyel-buffer (&optional out-buff)
    "transform python in current buffer and display in OUT-BUFF,
  OUT-BUFF defaults to *pyel-output*"
    (interactive)
    (let ((out (pyel-buffer-to-string)))
      (switch-to-buffer-other-window "*pyel-output*")
      (erase-buffer)
      (insert (funcall 'pyel-pp-function out))
      (emacs-lisp-mode)))
  
  (defun pyel-transform-ast (ast &optional no-splice)
    "transform a python AST to Emacs Lisp, AST must be a string
  AST can be generated by `pyel' with (pyel py-string t)"
    (with-transform-table 'pyel
                          (let ((code (transform (read  (format "(@ %s)" ast)))))
                            (if no-splice
                                code
                              (pyel-do-splices code)))))
  
  (defun pyel-file-ast (file-name)
    "return the ast from .py file FILE-NAME"
    )
  
  (defmacro pyel-with-known-types (known-types &rest code)
    "translate CODE while faking the known types"
    `(flet ((pyel-get-possible-types
             (&rest args)
             (mapcar* (lambda (arg type) (cons arg type))
                      args ,known-types)))
  
       (pyel ,@code)))
  
  (defun py-ast (code &optional pp include-attributes python2)
    "Return the python abstract syntax tree for python CODE
  useing python3 unless PYTHON2 is non-nil"
    (let ((py-ast "")
          (el-code "")
          ret)
  
      (with-temp-buffer
        (insert "import ast" "\n")
        (insert (format "print(ast.dump(ast.parse(\"\"\"%s\"\"\")%s))"
                        code
                        (if include-attributes ",include_attributes=True" "")))
        (write-region nil nil pyel-tmp-file nil 'silent))
  
      (setq ret (shell-command-to-string (format "python%s %s"
                                                 (if python2 "" "3")
                                                 pyel-tmp-file)))
      (if pp
          (mapconcat 'identity (split-string ret ",") ",\n")
        ret)))
  
  ;;'(a (@ b (c)))) => (a b (c))
  ;;'(a (@ b c)))   => (a b c)
  ;;'(@ a b c) => (progn a b c)
  ;;'(@ (a b)) = > (a b)
  ;;'(a (@) b) = > (a b)
  
  (defun pyel-do-splices (code)
    (if (listp code)
        (let (c)
          (if (eq (car code) '@) ;;special case: outer most list
              (if (> (length code) 2)
                  (pyel-do-splices `(progn ,code))
                (pyel-do-splices (cadr code)))
            (let ((ncode nil))
              (while code
                (setq c (pop code))
                (cond ((and (listp c) (not (listp (cdr c)))) ;;cons cell
                       (push (cons (pyel-do-splices (car c))
                                   (pyel-do-splices (cdr c))) ncode))
                      ((listp c)
                       (if (equal (car c) '@)
                           (setq ncode (append (reverse (pyel-do-splices (cdr c)))
                                               ncode))
                         (push (pyel-do-splices c) ncode)))
                      (t (push c ncode))))
              (if (listp ncode) (reverse ncode) ncode))))
      code))
  
  (defun pyel-reload ()
    (interactive)
    (pyel-reset)
    (dolist (f '(pyel
                 pyel-tests
                 pyel-transforms
                 pyel-mode
                 pyel-pp
                 pyel-preprocessor
                 pyel-tests-generated
                 py-lib
                 transformer))
      (setq features (remove f features)))
    (require 'pyel))
  
  (defun pyel-reset()
    "reset internal variables"
    (interactive)
    (setq pyel-method-name-arg-signature (make-hash-table :test 'eq)
          pyel-function-definitions nil
          pyel-defined-functions nil
          pyel-method-transforms nil
          pyel-context nil))
  
  (defvar pyel-method-name-format-string "_%s-method%s"
    "format string for the method transform names
  It must accept two args, the name of the method
  and its arg signature")
  
  (defun pyel-method-transform-name (method-name &optional arglist)
    "Return the name of the temlate that transform the method METHOD-NAME.
      template names are modified to avoid potential conflict with other templates
    the arglist must be placed in a list before passing so that the code can
     tell if the arglist is empty or not provided. 
    ARGLIST is used to generate a name that is unique to that arglist signature"
    (assert (and (listp arglist) (listp (car arglist)))
            "Invalid arglist. Expected a list of a list")
    (let* ((signature (if arglist (pyel-arglist-signature (car arglist)) "_"))
           (name (format pyel-method-name-format-string
                         (symbol-name method-name) signature)))
      (if arglist
          (assert (equal (pyel-extract-arg-descriptor signature)
                         (pyel-arg-descriptor (car arglist)))
                  "Invalid method name"))
      (intern name)))
  
  (defun pyel-func-transform-name (func-name &optional kwarg)
    "like `pyel-method-transform-name' for functions"
    (intern (format "_%s%s-function_"
                    (if kwarg "-kwarg" "")
                    (symbol-name func-name))))
  
  (defmacro push-back (val place)
    "Add VAL to the end of the sequence stored in PLACE. Return the new
  value."
    `(setq ,place (append ,place (list ,val))))
  
  (defun pyel-translate-function-name (name new-name)
    "translate python NAME to e-lisp NEW-NAME"
    (push (list name new-name) pyel-function-name-translations))
  
  (defun pyel-translate-variable-name (name new-name)
    "translate python  NAME to e-lisp NEW-NAME"
    (push (list name new-name) pyel-variable-name-translations))
  
  (defun pyel-not-implemented (message)
    "signify that a feature is not implemented"
    ;;TODO
    (message message) ;;tmp
    )
  
  (defmacro insert-at (list nth value)
    "insert VALUE at NTH index in LIST"
    `(setq ,list (append (subseq ,list 0 ,nth)
                         (list ,value)
                         (subseq ,list  ,nth))))
  
  (defun list-to-vector (list)
    (let ((v (make-vector (length list) nil))
          (i 0))
      (while list
        (aset v i (car list))
        (setq list (cdr list)
              i (1+ i)))
      v))
  
  (defun pyel-replace-in-thing (from to thing)
    "replace character FROM to TO in THING
  THING may be a symbol, string or list"
    (cond
     ;;tmp fix:
     ;;special case for numbers to handle being called
     ;;on the arg list in the def transform
     ;;(numbers are from the default values for kwonlyargs)
     ;;TODO: call _to- only on names, not such large lists
     ((numberp thing) thing)
  
     ((stringp thing)
      (replace-regexp-in-string from to  thing))
     ((symbolp thing)
      (intern (replace-regexp-in-string from to  (symbol-name thing))))
     ((and (listp thing) (listp (cdr thing)))
      (mapcar (lambda (x) (pyel-replace-in-thing from to x)) thing))
     ((listp thing) ;;cons cell
      (cons (pyel-replace-in-thing from to (car thing))
            (pyel-replace-in-thing from to (cdr thing))))
     (t (error "invalid thing"))))
  
  
  (defun _to- (thing)
    (pyel-replace-in-thing "_" "-" thing))
  (defun -to_ (thing)
    (pyel-replace-in-thing "-" "_" thing))
  
  (defun pyel-change-ctx (form ctx)
    "change ctx of form to CTX"
    (let ((type (and (listp form) (car form))))
      (cond ((eq type 'name)
             (list (car form) (cadr form) (list 'quote ctx)))
            ;;TODO: attribute and other forms (if needed)
            (t form))))
  
  (defun pyel-make-ast (type &rest args)
    "Generate pyhon ast.
  This is used when the ast form is needed by a transform that is manually
   called from another transform"
    (flet ((assert_n_args (type expect have)
                          (assert (= expect have)
                                  (format "pyel-make-ast -- ast type '%s'expects %s args. received %s args" type expect have)))
           (correct_ctx (ctx)
                        (if (symbolp ctx)
                            (pyel-make-ast ctx)
                          ctx))
           (correct_to_string (name)
                              (if (stringp name)
                                  name
                                (if (symbolp name)
                                    (symbol-name name)
                                  (error "invalid type for 'name'")))))
  
      ;;TODO: should have seporate functions to check
      ;;      the validity of the ast instead of having
      ;;      the correction functions do it
      (case type
  
        (subscript ;;args: value slice ctx
         (assert_n_args 'subscript 3 (length args))
  
         (let ((ctx (correct_ctx (car (last args)))))
           (list 'subscript (car args) (cadr args) ctx)))
  
        (name ;;args: name ctx
         (assert_n_args 'name 2 (length args))
         (let* ((name (correct_to_string (car args)))
  
                (ctx (correct_ctx (car (last args)))))
  
           (list 'name name ctx)))
        (load
         '(quote load))
        (store
         '(quote store)))))
  
  (defmacro macrop (sym)
    (if (boundp sym)
        (list 'macrop-1 sym)
      `(macrop-1 (quote ,sym))))
  
  (defun macrop-1 (function)
    ;;this is mostly taken from `describe-function-1'
    (let* ((advised (and (symbolp function) (featurep 'advice)
                         (ad-get-advice-info function)))
           ;; If the function is advised, use the symbol that has the
           ;; real definition, if that symbol is already set up.
           (real-function
            (or (and advised
                     (let ((origname (cdr (assq 'origname advised))))
                       (and (fboundp origname) origname)))
                function))
           ;; Get the real definition.
           (def (if (symbolp real-function)
                    (symbol-function real-function)
                  function)))
      (eq (car-safe def) 'macro)))
  
  (defun callable-p (object)
    (if (symbolp object)
        (or (fboundp object)
            (functionp object)) ;;necessary?
      (functionp object)))
  
  (defun pyel-split-list (lst sym)
    "split list LST into two sub-lists at separated by SYM
    The return value is the two sub-lists consed together"
    (let ((current (not sym))
          first)
      
      (while (and (not (eq current sym))
                  lst)
        (setq current (pop lst))
        (push current first)
        )
      
      (cons (reverse (if (eq (car first) sym) (cdr first) first)) lst)))
  
  
  (defun pyel-eval-last-sexp-1-function (eval-last-sexp-arg-internal)
    "Evaluate sexp before point; print value in minibuffer.
  With argument, print output into current buffer.
  
  This function is redefined to print python objects in a
  reasonable manner. The origional definition has been stored
  in `pyel-orig-eval-last-sexp-1'"
    (let ((standard-output (if eval-last-sexp-arg-internal (current-buffer) t))
          (val (eval (eval-sexp-add-defvars (preceding-sexp)) lexical-binding)))
      ;; Setup the lexical environment if lexical-binding is enabled.
      (if (and pyel-object-prettyprint
               (fboundp 'py-object-p)
               (py-object-p val))
          (setq val (pyel-repr val)))
      (eval-last-sexp-print-value val)))
  
  (fset 'pyel-orig-eval-last-sexp-1 'eval-last-sexp-1)
  (fset 'eval-last-sexp-1 'pyel-eval-last-sexp-1-function)
  
  (defvar pyel-object-prettyprint t
    "if non-nil, objects will be printed with their pyel repr value
  during interactive emacs-lisp sessions where possible")
          
  (defun pyel-toggle-object-prettyprint ()
    (interactive)
    (setq pyel-object-prettyprint (not pyel-object-prettyprint)))
  
  (defun pyel-get-generated-function (name)
    "return the generated function/macro definition for NAME"
    (get-matching-item pyel-function-definitions
                       (lambda (x) (eq (cadr x) name))))
  
  (defun pyel-strip-leading-nil (list)
    "remove all nil items from the front of LIST until the first non-nil item"
    (while (and (not (null list))
                (not (car list)))
      (setq list (cdr list)))
    list)
  
  (defun pyel-strip-trailing-nil (list)
    "remove all nil items from the back of LIST until the last non-nil item"
    (setq list (reverse list))
    (while (and (not (null list))
                (not (car list)))
      (setq list (cdr list)))
    (reverse list))
  
  (defun filter (func list)
    (let ((newlist ()))
      (dolist (e list)
        (if (funcall func e)
            (setq newlist (cons e newlist))))
      (reverse newlist)))
#+END_SRC
** variables
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defvar pyel-directory ""
    "Path to pyel files. must include py-ast.py, pyel.el etc")
  
  (defmacro vfunction-p (f)
    `(and (boundp ',f)
          (functionp ,f)))
  
  (defmacro pyel-empty-list-p (list)
    `(eq ,list 'py-empty-list))
  
  (set (defvar pyel-type-test-funcs nil
         "alist of types used in pyel-call-transform for the switch-type
              and the function used to test for that type")
       '((string stringp)
         (number numberp)
         (integer integerp)
         (int integerp)
         (float floatp)
         (vector vectorp)
         (empty-list pyel-empty-list-p)
         (list listp)
         (cons consp)
         (hash hash-table-p)
         (hash-table hash-table-p)
         (symbol symbolp)
         (array arrayp)
         ;;         (object object-p)
         (class py-class-p)
         (instance py-instance-p)
         (object py-object-p)
         (function functionp)
         (func fboundp)
         (vfunction vfunction-p)
         (vfunc vfunction-p)
         (callable callable-p)))
  
  (defvar pyel-negated-function-tests nil
    "A list of automatically created negated functions from `pyel-type-test-funcs'
    stored here just for convenient inspection")
  
  ;;create negated test functions
  (let (new func fname)
    (setq pyel-negated-function-tests nil)
    (mapc (lambda (x)
            (setq name (cadr x)
                  !name (intern (concat "!" (symbol-name name)))
                  func `(defsubst ,!name (x) (not (,name x))))
            (add-to-list 'pyel-negated-function-tests func)
            (eval func)
            (push (list (intern (concat "!" (symbol-name (car x))))
                        !name)
                  new))
          pyel-type-test-funcs)
    (setq pyel-type-test-funcs (append pyel-type-test-funcs new)))
  
  (defvar pyel-defined-classes nil
    "list of call class names defined by pyel")
  
  (defvar pyel-defined-functions nil
    "list of some functions defined pyel
            used by some templates to determine if a needed function has been defined yet")
  
  (defvar pyel-function-definitions nil
    "used to store function definitions created by pyel, not the user.")
  
  (defvar pyel-replace-args nil
    "if non-nil, pyel-do-call-transform will replace the arg symbols with their
            value, used if the code is to be inlined
            TODO: the option to replace the args should probably be obsoletede")
  
  (defvar pyel-unique-obj-names nil
    "if non-nil, uniquely name object instantces")
  
  (defvar pyel-context-groups nil ;;TODO: still used?
    "groups of contexts that cannot exist at the same time.
          `context-p' will stop at the first one in the list,")
  
  (setq pyel-context-groups
        '((assign-target assign-value)))
  
  (defvar pyel-function-name-translations nil
    "alist of function name translations, python->e-lisp.
      
          Entries in `pyel-function-name-translations' are applied before
          checking for function transforms.
          If a translation len->length is defined then the function transform for
          'len' will not be detected because the name is now 'length'
          ")
  
  (defvar pyel-variable-name-translations nil
    "alist of variable name translations, python->e-lisp.")
  
  (setq pyel-function-name-translations `(
                                          
                                          ))
  ;;TODO: list, vector, etc
  ;;      map?
  
  (setq pyel-variable-name-translations '((True t)
                                          (False nil)
                                          (None nil)))
  
  (defvar pyel-method-transforms nil
    "List of names of methods for which a transform has been defined
          For internal use only--do not modify by hand"
    )
  
  (defvar pyel-func-transforms nil
    "list of function names that have transforms defined for them")
  
  (defvar pyel-func-kwarg-transforms nil
    "list of function names that have kwarg transforms defined for them")
  
  (defconst pyel-nothing '(@)
    "value to return from a function/transform when it should
          not contribute to the output code")
  
  (defconst pyel-python-version "3.2.3"
    "python interpreter version whose ast pyel is written for")
  
  (defvar test-variable-values nil
    "variables values for running tests")
  
  (setq test-variable-values
        '((pyel-defined-classes nil)
          (pyel-function-definitions nil)
          (pyel-defined-functions nil)
          (pyel-obj-counter 0)
          (pyel-unique-obj-names nil)
          (pyel-fully-functional-functions nil)
          ;;(pyel-method-transforms nil)
          ;;(pyel-func-transforms nil)
          (pyel-marker-counter 0)))
  
  (defvar pyel-marker-counter 0)
  
  (defvar pyel-tmp-file  "/tmp/pyel-ast.py"
    "Name of temp file to use for AST generation")
  
  (defvar pyel-interactive nil
    "non-nil during interactive session translation and evaluation")
#+END_SRC
** syntax output variables
variables that effect the form of the output code
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defvar pyel-default--init--method
    "(defmethod --init-- ((self %s))
       \"Default initializer\"
      )"

    "default initializer for pyel objects.")

  (defvar pyel-use-list-for-varargs nil
    "Determines if *varargs will be passed to function as a list or a vector,
    non-nil for list, otherwise vector.
    To be like python (vectors), this should be nil
    To be consistent with Emacs-Lisp (lists), this should be t.
       On the python side, this means that *varargs is a list instead of a tuple")
#+End_SRC
** pyel-block
This will have to be removed after the code is generated
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defmacro pyel-block (&rest code)
    `(progn ,@ code))
#+END_SRC
** context
#+Begin_SRC emacs-lisp :tangle pyel.el
  ;;TODO: this should be generalized and added to the transform code
  (defvar pyel-context nil
    "list of current expansion contexts")
  
  (defmacro using-context (context &rest code)
    `(progn
       (push ',context pyel-context)
       (let (ret)
         (condition-case err
             (setq ret (progn ,@code))
           (error (pop pyel-context)
                  (error (format "using-context: %s" err))))
         (pop pyel-context)
         ret)))
  
  (def-edebug-spec using-context (symbolp &rest form))
  
  (defmacro remove-context (context &rest code)
    "remove CONTEXT and translate CODE, then restore context"
    `(let ((pyel-context (remove ',context pyel-context)))
       ,@code))
  (def-edebug-spec remove-context (symbolp &rest form))
  
  (defmacro context-switch (&rest forms)
    `(cond ,@(mapcar (lambda (x)
                       `(,(let ((context (car x)))
                            (if (eq context t) t
                              `(member ',context pyel-context))) ,@(cdr x)))
                     forms)))
  
  (defun get-context-group (context)
    (let ((groups pyel-context-groups)
          (found nil)
          group)
      (while groups
        (setq group (car groups)
              groups (cdr groups))
        (dolist (g group)
          (when (equal g context)
            (setq found group
                  groups nil))))
      found))
  
  ;; (defun context-p (context)
  ;;   (member context pyel-context))
  (defun context-p (context)
      ;;;;TODO: the extra features that this provides is probably not being used anywere...
    (let ((group (get-context-group context))
          (cont pyel-context)
          (ret nil)
          c)
      (while cont
        (setq c (car cont)
              cont (cdr cont))
        ;;if the context is in a group only return t if it is the first one in pyel-context
        (if (member c group)
            (setq ret (equal c context)
                  cont nil)
          (when (equal c context)
            (setq ret t
                  cont nil))))
      ret))
  
  (defun context-depth (context)
    "get the depth of CONTEXT in `pyel-context'"
    ;;TODO:
    )
#+end_src
** type inference
#+Begin_SRC emacs-lisp :tangle pyel.el
  ;;this is all temp for testing
  (setq known-types '((number object ) (number string)))
  
  ;;prevents error: "Wrong type argument: listp, string"
  ;;TODO: this is a bit of a mess now. types 'func' and 'function' in type
  ;;transforms result in different tests but func/function still kind of mean the
  ;;same thing when it comes to python. if func is known type, function should
  ;;also be know. need some kind of an alias mechanism
  (setq known-types
        '((number list vector string object hash function func symbol vfunc class instance int float)
          (number list vector string object hash function func symbol vfunc class instance int float)
          (number list vector string object hash function func symbol vfunc class instance int float)
          (number list vector string object hash function func symbol vfunc class instance int float)
          (number list vector string object hash function func symbol vfunc class instance int float)
          (number list vector string object hash function func symbol vfunc class instance int float)
          (number list vector string object hash function func symbol vfunc class instance int float)
          (number list vector string object hash function func symbol vfunc class instance int float)
          (number list vector string object hash function func symbol vfunc class instance int float)
          (number list vector string object hash function func symbol vfunc class instance int float)))
  (push (list 'known-types known-types) test-variable-values)
  
  (defun pyel-get-possible-types (&rest args)
    "return a list in the form (arg types).
    The car is the argument and the cdr is a list of possible types"
  
    ;;FOR TESTING
    (let ((types (if (>= (length known-types) (length args))
                     known-types
                   (append known-types '(string number list vector integer float))))
          (args (filter (lambda (x) (not (or (eq x '&optional)
                                             (eq x '&rest)))) args)))
  
      (mapcar* (lambda (arg type) (cons arg type))
               args types)))
#+end_src
** type dispatching transforms
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defun pyel-filter-non-args(args)
    "remove '&optional' and '&rest' from ARGS list"
    (filter (lambda (x) (not (or (eq x '&optional)
                                 (eq x '&rest))))
            args))
  
  (defmacro pyel-dispatch-func (name args &rest type-switches)
    "Define a transform that creates a runtime function that
  dispatches on argument type as defined by TYPE-SWITCHES.
  The transform will have the same NAME and ARGS and must be called with a
  function like `call-transform', it will return a call to
  the function it creates.
  After the resulting transform is called, it adds the name of the
  created function in `pyel-defined-functions' and adds the function 
  definition to `pyel-function-definitions'
  
  Use `pyel-func-transform' to define transforms for functions that
  will be automatically called.
  
  NOTE: if the name of the function to be created is already in
   `pyel-defined-functions', the function will not be updated
  "
    ;;temp solution: does not check types etc
    (let* ((striped-args (mapcar 'strip_ args))
           (args-just-vars (pyel-filter-non-args striped-args))
           (rest-arg (if (eq (car (last striped-args 2)) '&rest)
                         (car (last striped-args)) nil)))
  
      `(def-transform ,name pyel ()
         (lambda ,striped-args
           (let ((fsym ',(intern (concat "pyel-" (symbol-name name) "")))
                 (body (pyel-do-call-transform (pyel-get-possible-types
                                                ,@args-just-vars)
                                               ',args
                                               ',type-switches))) 
             (unless (member fsym pyel-defined-functions)
               (push (list 'defmacro fsym ',striped-args
                           body)
                     pyel-function-definitions)
               (push fsym pyel-defined-functions)
               (fset fsym (lambda () nil)))
             (cons fsym ,(if rest-arg
                             `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
                           (cons 'list args-just-vars))))))))
  
  (defmacro pyel-method-transform (name args &rest type-switches)
    "Defines a transform for methods that dispatches on NAME and ARG length.
  The syntax and the function creation is the same as with `pyel-dispatch-func'.
  These transforms are automatically called for methods during translation time.
  The transform will be dispatched on NAME and the possible number
  of arguments that ARGS allows.
  During translation time, if no transform is found for a method call that
  matches NAME and has the proper arg length then no transform will be called."
    (add-to-list 'pyel-method-transforms name)
  
    ;;temp solution: does not check types etc
    (let* ((striped-args (mapcar 'strip_ args))
           (args-just-vars (pyel-filter-non-args striped-args))
           (rest-arg (if (eq (car (last striped-args 2)) '&rest)
                         (car (last striped-args)) nil))
           (fsym (intern (format "pyel-%s-method%s"
                                 (symbol-name name)
                                 (pyel-arglist-signature args))))
           (transform-name (pyel-method-transform-name name (list args))))
  
      (pyel-add-method-name-sig name args)
      
      `(def-transform ,transform-name pyel ()
         (lambda ,striped-args
           (let ((body (pyel-do-call-transform (pyel-get-possible-types
                                                ,@args-just-vars)
                                               ',args
                                               ',type-switches))) 
  
             (unless (member ',fsym pyel-defined-functions)
               (push (list 'defmacro ',fsym ',striped-args
                           body)
                     pyel-function-definitions)
               (push ',fsym pyel-defined-functions)
               (fset ',fsym (lambda () nil)))
             (cons ',fsym ,(if rest-arg
                               `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
                             (cons 'list args-just-vars))))))))
  
  (defmacro pyel-func-transform (name args &rest type-switches)
    (add-to-list 'pyel-func-transforms name)
    ;;TODO: should name be modified to avoid conflicts ?
    `(pyel-func-transform-1 ,name ,args nil ,@type-switches))
  
  (defmacro pyel-func-kwarg-transform (name args &rest type-switches)
    (add-to-list 'pyel-func-kwarg-transforms name)
    `(pyel-func-transform-1 ,name ,args t ,@type-switches))
  
  (defmacro pyel-func-transform-1 (name args is-kwarg-transform &rest type-switches)
    "Define a transform for function calls.
  This is just like `pyel-method-transform' except that the
  ARG signature has no effect on the transform dispatch"
    
    (let* ((striped-args (mapcar 'strip_ args))
           (args-just-vars (pyel-filter-non-args striped-args))
           (rest-arg (if (eq (car (last striped-args 2)) '&rest)
                         (car (last striped-args)) nil))
           (fsym (intern (concat "pyel-"
                                 (symbol-name name) "-"
                                 (if is-kwarg-transform "kwarg-" "")
                                 "function"))))
      `(def-transform ,(pyel-func-transform-name name is-kwarg-transform) pyel ()
         (lambda ,striped-args
           (let ((body (pyel-do-call-transform (pyel-get-possible-types
                                                ,@args-just-vars)
                                               ',args
                                               ',type-switches)))
             (unless (member ',fsym pyel-defined-functions)
               (push (list 'defmacro ',fsym ',striped-args
                           body)
                     pyel-function-definitions)
               (push ',fsym pyel-defined-functions)
               (fset ',fsym (lambda () nil)))
             (cons ',fsym ,(if rest-arg
                               `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
                             (cons 'list args-just-vars))))))))
  
  (defvar pyel-func-transforms2 nil
    "list of functions whose translations are defined
  with the macro `pyel-define-function-translation'")
  
  (defmacro pyel-define-function-translation (name &rest body)
    "BODY will form the body of a function that is called during transform time
  to tranlate a call to NAME, variables 'args' and 'kwargs'  are available at
  this point. 'args' will be a list and 'kwargs will be an alist
  This is called at the same time `pyel-func-transform' would be called"
    (add-to-list 'pyel-func-transforms2 name)
  
    `(def-transform ,(pyel-func-transform-name name) pyel ()
       (lambda (args kwargs)
         ,@body
         )))
  
  ;;TODO: this should be more general to allow for things like subscript to use it
  
  (defmacro pyel-def-funcall (name args &rest type-switches)
    "Define how to call the function NAME.
        NAME is a function that is called differently based on its argument types.
        An attempt will be made to test the least possible number of types.
  
        This defines a transforms in the pyel transform table with NAME and ARGS"
    `(def-transform ,name pyel ()
       (lambda ,args
         (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                 ',args
                                 ',type-switches))))
  
  ;;TODO: rename pyel-def-funcall -> pyel-def-type-transform
  (defmacro pyel-def-type-transform (name args &rest type-switches)
    "Define a transform NAME that produces code based on the types of ARGS
      TYPE-SWITCHES
  
      This defines a transforms in the pyel transform table with NAME and ARGS"
    `(def-transform ,name pyel ()
       (lambda ,args
         (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                 ',args
                                 ',type-switches))))
  
  ;; (defmacro pyel-def-call-func (name args &rest type-switches)
  ;;   "like `pyel-def-call-template' except that it generates a macro that
  ;; is called directly, because of this NAME must be unique"
  ;;   `(defun ,name ,args
  ;;      ;;   (let (,(mapcar (lambda (arg) `(,arg ',arg)) args))
  ;;      (pyel-do-call-transform (pyel-get-possible-types ,@args)
  ;;                              ',args
  ;;                              ',type-switches)))
  
  (defun pyel-expand-type-switch (type-switch)
    "expands the types switch form to a list of cond clauses"
    (flet ((helper (arg form)
                   (let ((type (car form))
                         (varlist (cadr form))
                         mod types ret and-or)
                     (if (consp type)
                         (progn
                           ;;TODO: this can never be 'and'
                           (setq and-or (car type))
                           (dolist (tp (cdr type))
                             (push `((,arg ,tp) ,varlist) ret))
                           `(,and-or ,@(reverse ret)))
                       `((,arg ,type) ,varlist))))
           (expander (type-switch)
  
                     (let ((args (car type-switch))
                           (forms (cdr type-switch))
                           and-or ret inner tmp tests)
                       (if (consp args)
                           (progn
                             (setq and-or (car args)) ;;TODO: verify and/or
                             (if (eq and-or 'and)
                                 (dolist (form forms)
                                   (setq tests nil)
                                   (dolist (arg (cdr args))
                                     (push (car (helper arg form)) tests))
                                   (push `(and ,(reverse tests) ,(cadr form)) ret))
                               ;;else == or
                               (dolist (form forms)
                                 (dolist (arg (cdr args))
                                   (setq tmp (helper arg form))
                                   (if (equal (car tmp) 'or)
                                       (dolist (x (cdr tmp))
                                         (push x ret))
                                     (push (helper arg form) ret))))))
  
                         ;;else single arg
                         (dolist (form forms)
                           (setq tmp (helper args form))
                           (if (equal (car tmp) 'or)
                               (dolist (x (cdr tmp))
                                 (push x ret))
                             (push tmp ret))))
                       (reverse ret))))
      (let ((ret nil))
        (dolist (ts type-switch)
          (dolist (e (expander ts))
            (push e ret)))
        (reverse ret))))
  
  ;;TODO: fix bug with  `pyel-expand-type-switch-2'
  ;;      the arg pattern (x x) should not expand unless
  ;;      x is a possible type of both args
  
  (defun pyel-expand-type-switch-2 (arglist patterns)
    "has output identical to `pyel-expand-type-switch' just translates
        different syntax"
    (let ((group nil)
          (groups nil)
          (ngroups nil)
          (ret nil)
          code)
  
      ;;stage1: collect into groups
      (while patterns
        (setq p (pop patterns))
  
        (if (not (eq p '->))
            (push-back p group)
          (push-back (pop patterns) group)
          (push-back group groups)
          (setq group nil)))
  
      (dolist (g groups)
        (let* ((g (reverse g))
               (code (car g))
               (g (cdr g))
               ;;      (param-types (make-vector (length (car g)) nil))
               type)
  
          (dolist (arg-pattern (reverse g)) ;;for each arg pattern
            (setq group-patterns nil)
            (dotimes (i (length arg-pattern)) ;;for each type or '_
              (setq type (nth i arg-pattern))
              (if  (not (eq type '_))
                  (push `((,(nth i arglist) ,type) ,code) group-patterns)))
            (if (null group-patterns) ;;all types where _
                (setq ret (append ret (list (list t code))))
              (if (= (length group-patterns) 1)
                  (setq ret (append ret (reverse group-patterns)))
                (setq ret (append ret (list (cons 'and
                                                  (list (mapcar 'car
                                                                (reverse group-patterns))
                                                        code))))))))))
      ret))
  
  (defun pyel-remove-nil (list)
    "remove all nil items from LIST"
    (let ((new nil))
      (dolist (e list)
        (when e
          (setq new (cons e new))))
      (reverse new)))
  
  (defun pyel-do-call-transform (possible~types args type-switch)
    "This is responsible for  producing a call to NAME in the most
        efficient way possible with the known types"
  
    ;; the args of the type transform are evaled here so there must
    ;; be no conflicts with the naming of internal variables
    ;; To avoid such conflicts, the let bound variables are all
    ;; defined with a tilde
  
    (let* ((possible~types (let (ret arg)
                             ;;get entries in form (arg . type)
                             (dolist (p-t possible~types)
                               (setq arg (car p-t))
                               (dolist (type (cdr p-t))
                                 (push (cons arg type) ret)))
                             ret))
  
           (args~just~vars (pyel-filter-non-args (mapcar 'strip_ args)))
           (new~args (loop for a in args
                           collect (if (or (eq a '&optional)
                                           (eq a '&rest)
                                           (string-match-p "\\(^_\\)\\(.+\\)"
                                                           (symbol-name a))) nil
                                     (intern (format "__%s__" (symbol-name a))))))
           (arg~replacements4 (let (ar)
                                (mapcar (lambda (x) (if (string-match-p "\\(^_\\)\\(.+\\)"
                                                                        (symbol-name x))
                                                        (push (list (strip_ x) (list '\, (strip_ x))) ar)))
  
                                        args)
                                ar))
           ;;list of symbols to replace
           ;;format: (symbol replace)
           (let~vars (let (lv) (mapcar* (lambda (a b) (if b
                                                          (push (list a b) lv)))
                                        args new~args)
                          lv))
           ;;strip any leading underscores
           (args~ (mapcar (lambda (a)
                            (if (string-match "\\(^_\\)\\(.+\\)" (symbol-name a))
                                (intern (match-string 2 (symbol-name a))) a))
                          args))
  
           ;;the __x__ type replacements interfere with the (\, x) type replacements
           ;;so they must be seporated and done one at a time
           (arg~replacements1 let~vars)
           (arg~replacements2 (mapcar (lambda (x)
                                        (list  (intern (format "$%s" x)) (list '\, x)))
                                      args~just~vars))
           (arg~replacements3 (mapcar (lambda (x)
                                        (list (intern (format "$$%s" x)) (list 'quote (list '\, x))))
                                      args~just~vars))
           (arg~replacements (append arg~replacements1 arg~replacements2))
  
           (arg~quote~replacements (mapcar (lambda (x)
                                             (list x (list '\, x)))
                                           args~just~vars))
           (current~replace~list nil)
           ;; (arg~replacements (append let~vars
           ;;                           (mapcar (lambda (x)
           ;;                                     (list  (intern (format "$%s" x)) (list '\, x)))
           ;;                                   args~)))
  
           (c~ 0)
           valid~ ;;list of valid arg--types
           found~ all~good len~)
  
      ;;collect all the arg-type--code pairs that are valid possibilities,
      ;;that is, members of possible~types.
      ;;This essentially throws out all the arg types that have been ruled out.
      (dolist (t~s (pyel-expand-type-switch-2 args~just~vars type-switch))
        (if (equal (car t~s) 'and)
            (progn (setq all~good t
                         found~ nil)
                   (dolist  (~x (cadr t~s)) ;;for each 'and' member type-switch
                     (dolist (pos~type possible~types) ;;for each arg type
                       (if (and (equal (eval (car ~x)) (car pos~type))
                                (equal (cadr ~x) (cdr pos~type)))
                           (setq found~ t)))
                     (setq all~good (if (and all~good found~) t nil)))
                   (when all~good
                     (push t~s valid~)))
          ;;else
          (if (eq (car t~s) t) ;;when all types are _
              (push t~s valid~)
            ;;otherwise check if the type is one of the valid types
  
            (dolist(pos~type possible~types)
              (when (and (equal (eval (caar t~s)) (car pos~type))
                         (equal (strip$ (cadar t~s)) (cdr pos~type)))
                (push t~s valid~))))));;TODO: break if found?
  
      ;;generate code to call NAME
      ;;if there is 2 posible types, use IF. For more use COND
      (setq len~ (length valid~))
  
      (flet ((replace (code replacements)
                      (let ((ret nil)
                            found)
  
                        (dolist (c code)
                          (setq found nil)
                          (dolist (r replacements)
                            (if (consp c)
                                (setq c (replace c replacements))
                              (if (and (equal c (car r))
                                       (not found))
                                  (progn (push (cadr r) ret)
                                         (setq found t)))))
                          (unless found
                            (push c ret)))
                        (reverse ret)))
  
             (type-tester (x) (cadr (assoc x pyel-type-test-funcs)))
             (and-type-tester (x) (cadr (assoc (car x) pyel-type-test-funcs)))
             (get-replacement (arg) ;;returns arg replacement
                              (cadr (assoc arg current~replace~list)))
             ;;bug fix maybe...
             (get-replacement-OLD (arg) ;;returns arg replacement
                                  (or (cadr (assoc arg arg~replacements))
                                      (cadr (assoc arg arg~replacements4))))
             ;;replaces the vars, one type at a time
             (replace-vars (code)
                           (let* ((current-replace-list arg~replacements1)
                                  (code (replace code arg~replacements1))
                                  (current-replace-list arg~replacements2)
                                  (code (replace code arg~replacements2))
                                  (current-replace-list arg~replacements3))
                             (replace code arg~replacements3)))
             (gen-cond-clause (t-s--c) ;;Type-Switch--Code
                              (if (equal (car t-s--c) 'and)
                                  (progn `((and ,@(mapcar '(lambda (x)
                                                             ;;TODO: test
                                                             `(,(type-tester (cadr x))
                                                               ,(get-replacement-OLD
                                                                 (car x))))
                                                          (cadr t-s--c)))
                                           ,(replace-vars (caddr t-s--c))))
  
                                ;;TODO
                                (progn (if (equal (car t-s--c) t) ;;all types where _
                                           `(t ,(replace-vars (cadr t-s--c)))
                                         (let* ((str (symbol-name (cadar t-s--c)))
                                                (quote-arg-p (string-match-p "\\(^\\$\\)\\(.+\\)"
                                                                             str))
                                                (type (if quote-arg-p (intern (match-string 2 str)) (cadar t-s--c)))
                                                (tester (type-tester type))
                                                (body (replace-vars (cadr t-s--c)))
                                                (arg (get-replacement-OLD (caar t-s--c))))
                                           `((,tester ,(if quote-arg-p (list 'quote (list '\, (caar t-s--c))) arg))
                                             ,body))))))
             (gen-varlist ()
                          (mapcar (lambda (x) `(,(cadr x) ,(list '\, (car x))))
                                  let~vars)))
  
        (cond ((<= len~ 0) "ERROR: no valid type")
              ((= len~ 1)
               (if (eq (caar valid~) 'and)
                   (caddar valid~)
                 ;;there is only one possibility, so replace the args with their quoted counterpart
                 ;;instead of replacing with the let bound vars
                 (list 'backquote (replace (cadar valid~) arg~quote~replacements))))
              ;;?TODO: are there possible problems with evaluating the arguments
              ;;       multiple times? Maybe they should be put in a list
              (t (let* ((clauses (mapcar 'gen-cond-clause valid~))
                        (clauses (if (eq (caar clauses) t)
                                     clauses
                                   (cons
                                    '(t (error "invalid type, expected <TODO>"))
                                    clauses)))
                        (varlist (gen-varlist)))
                   `(backquote ,(if varlist
                                    `(let ,varlist
                                       (cond ,@(reverse clauses)))
                                  `(cond ,@(reverse clauses))))))))))
  
  (defun call-transform (template-name &rest args)
    "expand TEMPLATE-NAME with ARGS in the same way that `transform' would
  if was called as (transform '(template-name args))
  NOTE: this calls `transform' on all ARGS, but not TEMPLATE-NAME"
    (eval `(transform '(,template-name ,@(mapcar 'transform args)))))
  
  (defun strip$ (sym)
    (let ((str (symbol-name sym)))
      (if (string-match "\\(^\\$\\)\\(.+\\)" str)
          (intern (match-string 2 str))
        sym)))
  (defun strip_ (sym)
    (let ((str (symbol-name sym)))
      (if (string-match "\\(^_\\)\\(.+\\)" str)
          (intern (match-string 2 str))
        sym)))
  
  (defun pyel-arg-descriptor (arglist)
    "return the number of values that may be passed to ARGLIST
  If ARGLIST contains &optional or &rest then return a cons of
  the min and max values that may be passed.
  
  This does not check if ARGLIST has a valid form"
  
    (let ((min 0)
          (max 0)
          optional)
      (when arglist
        (if (member '&rest arglist)
            (setq max 'I
                  arglist (subseq arglist 0 -2)))
        (if (member '&optional arglist)
            (setq optional (pyel-split-list arglist '&optional)
                  min (length (car optional)) ;;positional args
                  max (if (eq max 'I) max
                        (+ min (length (cdr optional))))) ;;optional args
          (setq min (length arglist)
                max (if (eq max 'I)
                        max
                      min))))
      (if (or (equal min max)
              (and (= min 0)
                   (eq max 'I)))
          max
        (cons min max))))
  
  (defun pyel-arglist-signature (arglist)
    (let ((num (pyel-arg-descriptor arglist)))
      (format "->%s<-" (if (or (numberp num)
                               (eq num 'I))
                           num
                         (format "%s~%s" (car num) (cdr num))))))
  
  (defun pyel-extract-arg-descriptor (name)
    "extract the arglist descriptor from name"
  
    (assert (stringp name) "Name must be a string")
    (if (symbolp name) (setq name (symbol-name name)))
    (let (min max I?)
      (cond ((string-match "->\\([0-9I]+\\)<-" name)
             (setq min (match-string 1 name)
                   max min))
  
            ((string-match "->\\([0-9]+\\)~\\([0-9I]+\\)<-" name)
             (setq min (match-string 1 name)
                   max (match-string 2 name))))
  
      (if min
          (setq I? (intern max)
                max (if (eq I? 'I) 'I (string-to-number max))
                min (string-to-number min)))
  
      (cond ((null min) nil)
            ((or (equal min max)
                 (and (= min 0)
                      (eq max 'I)))
             max)
            (t (cons min max)))))
  
  (defun pyel-arg-descriptor-to-signature (descriptor)
    (format "->%s<-" (if (or (numberp descriptor)
                             (eq descriptor 'I))
                         descriptor
                       (format "%s~%s" (car descriptor) (cdr descriptor)))))
  
  (defvar pyel-method-name-arg-signature (make-hash-table :test 'eq)
    "mapping of method transform names to a list of argument signatures")
  
  (defun pyel-add-method-name-sig (name args)
    "Add the argument signature of ARGS to NAME in `pyel-method-name-arg-signature'"
    (let* ((signatures (gethash name pyel-method-name-arg-signature)))
      (add-to-list 'signatures (pyel-arg-descriptor args))
      (puthash name signatures pyel-method-name-arg-signature)))
  
  (defun pyel-find-method-transform-name (name num-args)
    "find a matching method transform for NAME with NUM-ARGS
  will return the name of the first match"
    (let ((signatures (gethash name pyel-method-name-arg-signature))
          found min max)
      (if signatures
          (progn (while signatures
                   (setq sig (car signatures)
                         signatures (cdr signatures))
  
                   (if (or (and (numberp sig)
                                (= sig num-args))
  
                           (eq sig 'I)
  
                           (and (consp sig)
                                (setq min (car sig)
                                      max (cdr sig))
                                (and (>= num-args min)
                                     (or (<= num-args max)
                                         (eq max 'I)))))
                       (setq signatures nil
                             found sig)))
                 (if found
                     (intern (format pyel-method-name-format-string
                                     name
                                     (pyel-arg-descriptor-to-signature found)))))
        (error "method transform %s does not exist in the signature table"
               name))))
  
  
#+END_SRC
*** example usage
(pyel-def-call-func pyel+ (lhs rhs)
		    ((or lsh rhs)
		     (string (concat lhs rhs))
		     (number (+ lhs rhs))
		     (list (append lhs rhs)
			   (vector (ldk lhs rhs)))))


(setq known-types '((string list) (number vector)))

(pyel+ 'a 'b)
==>  (cond
      ((listp a)
       (append a b))
      ((numberp b)
       (+ a b))
      ((stringp a)
       (concat a b))
      (t
       (error "invalid type, expected <TODO>")))


TODO: describe alternative syntax
==> look at the bin-op heading for examples
(pyel-def-funcall * (l r)
                    (number number) ->  (* l r)
                    (object _)
                    (_ object)  -> (--mul-- l r)
                    (_ string)
                    (string _)  -> (pyel-mul-num-str l r))

*** tests
auto generated tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;
#+END_SRC
hand written
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-test-expand-type-switch ()
    (should (equal (pyel-expand-type-switch-2 '(l r)
                                              '((number number) ->  (* l r)
                                                (object _)
                                                (_ object)  -> (--mul-- l r)
                                                (_ string)
                                                (string _)  -> (pyel-mul-num-str l r)))
                   '((and ((l number) (r number)) (* l r)) ((l object) (--mul-- l r)) ((r object) (--mul-- l r)) ((r string) (pyel-mul-num-str l r)) ((l string) (pyel-mul-num-str l r))))))
#+END_SRC

** translation messages
#+Begin_SRC emacs-lisp :tangle pyel.el
(defvar pyel-translation-messages nil
  "collects messages during pyel translations")

(defvar pyel-message-formats '((error "ERROR: %s")
			       (warn "WARNING: %s")
			       (recommend "RECOMMENDATION: %s"))
  "alist of message type and their format strings")

(defun pyel-notify (type msg)
  "add MSG to `pyel-translation-messages', TYPE specifies the format string
in `pyel-message-formats'"
  (push (format (or (cadr (assoc type pyel-message-formats))
		    (format "[%s]: %%s" (upcase (symbol-name type))))
		msg) pyel-translation-messages))

#+END_SRC
** line/column numbers
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defun pyel-skip-whitespace ()
    (skip-chars-forward " \t\n\r"))
  
  (defun char-at-point ()
    (buffer-substring-no-properties (point) (1+ (point))))
  
  (defun read-tree-positions ()
    "Create a tree of buffer positions corresponding to the source tree at the point
  format [start end list-of-sub-trees] list-of-sub-trees is nil for leaves"
    (pyel-skip-whitespace)
    (let ((start (point))
          inner)
      (goto-char (1+ start))
      (setq inner (read-list-positions)) ;;asssumes we start on a list
      (vector start (point) inner)))
  
  (defun read-list-positions ()
    (let (start end elems)
      (condition-case nil
          (while t
            (pyel-skip-whitespace)
            (setq start (point))
            (if (string= (char-at-point) "(")
                (push (get-tree-positions) elems)
              (setq end (scan-sexps start 1))
              (push (vector start end nil) elems)
              (goto-char end)))
        (scan-error (goto-char (1+ start))))
      (reverse elems)))
#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-test-do-splices ()
    (should (equal (pyel-do-splices '(a (@ b (c)))) '(a b (c))))
    (should (equal (pyel-do-splices '(a (@ b c)))  '(a b c)))
    (should (equal (pyel-do-splices '(a (@ b (c (@ 2 (n (x 1 (@ 2))) 3 (@ 3) (@ a b (2)))))))
                   '(a b (c 2 (n (x 1 2)) 3 3 a b (2)))))
  
    (should (equal (pyel-do-splices '(@ (a b (@ d (e 2 (@ a b c ))))))
                   '(a b d (e 2 a b c))))
  
    (should (equal (pyel-do-splices '(@ (a b (@ d (e 2 (@ a b c )))) last))
                   '(progn (a b d (e 2 a b c)) last)))
  
    (should (equal (pyel-do-splices '(@)) nil))
    )
#+END_SRC

* python preprocessor
The preprocessor is no longer tangled

(lambda (a b) (print a))
lambda((a,b)
       print(a))

(cond ((> a b) (print a))
      (t (print b)))
cond([a > b, print(a)]
     [true, print(b)])

(py-ast "lambda([a,b],
print(a)) " t)

preprocessor expand separately
  scan for regex
  copy form to seporate file and expand to pyel-ast
    store in hash table with unique ID
  in py-ast replace with variable that matches some regex and contains that id
  in pyel expanstion match names, when match found, transform ast from hash table

* transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(make-transform-table 'pyel)
#+END_SRC
** tests
* python ast
This is for all non template specific code.
#+Begin_SRC python :tangle py-ast.py
  import ast
  
  #TODO: use *args
  
  def l_str(x):
      return "(" + " ".join(map(str,x)) + ")"
  
  def ll_str(x):
      if x == []:
          return "nil"
      elif type(x) == str:
          return x
      return "(" + " ".join(map(str,x)) + ")"
  #    return " ".join(map(str,x))
  #    return "(list " + " ".join(map(str,x)) + ")"
  # commented out for 'assign'. cause problems elsewhere?
  
  def untuple(x):
      return ll_str(x)
      if x == []:
          return "nil"
      elif type(x) == str:
          return x
  
  def Module(body):
      return "\n".join(body)
  
  def keyword(arg, value, lineno='nil', col_offset='nil'):
      return l_str(["(keyword ", arg, " ", value, lineno, col_offset, ")"])

  def Param():
      return "'param"
  
  def Load():
      return "'load"
  
  def Store():
      return "'store"
  
  def Expr(value, lineno='nil', col_offset='nil'): #?
      return value
  
  def Import(names, lineno=None, col_offset='None'):
      return l_str(["import ",ll_str(names), lineno, col_offset])
  
  def alias(name, asname):
      if asname: asname = "\"" + asname + "\""
      return l_str(["alias ", "\"" + name + "\"", asname or "nil"])
  
  def ImportFrom(module, names, level, lineno=None, col_offset='None'):
      return l_str(["import-from ","\"" + module + "\"", ll_str(names), level, lineno, col_offset])
#+END_SRC

* ---------------------
* ast transforms
** assign
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;; should not fset functions because the effect takes place globally
  ;; even when the name being set is let bound.
  (pyel-dispatch-func set (_sym _val)
                      (_ $function) -> (setq $sym $$val)
                      (_ _) -> (setq $sym $val)) ;;TODO: other?
  
  (def-transform assign pyel ()
    (lambda (targ val &optional line col) (py-assign targ val line col)))
  
  ;;TODO: put all setq's in a single form: (setq a 1 b 2) etc
  
  (defun py-assign (targets values &optional line col)
  
    (let ((wrap-values t)
          unpack i)
      ;;make sure targets and lists are both in a list form
      ;;the 'unpack' flag is needed because it leaves no difference
      ;;between a,b=c and a=b=c
      (if (and (listp (car targets))
               (eq (caar targets) 'tuple))
          (progn
  
            (if (eq (car values) 'tuple)
                (progn
  
                  (setq values (cadr values))
                  (setq wrap-values nil))
              (setq unpack t) ;;targets is a tuple and values is not
              ;;(setq values (list values))
              )
  
            (setq targets (cadar targets)))
        )
  
      (when wrap-values
        (setq values (list values)))
  
  
      ;;py-sssign2 does the main transforms
      ;;TODO: check for the special case a,b=b,a and create temp variables
      ;;TODO: check that legnth of the lists are the same
  
      ;;TODO:
      (cond (unpack
             ;;TODO: pyel error unless: (and (> (length targets) 1)  (= (length values) 1)
  
             (let ((code '(@)))
               `(let ((__value__ ,(transform (car values))))
  
                  ,(dotimes (i (length targets) (reverse code))
                   ;;;TODO: will have to help the transform know what type __value__ is
                     (push (py-assign2 (nth i targets)
  
                                       (pyel-make-ast 'subscript '__value__ i 'load))
                           code))
                  )))
  
            ((= (length targets) 1)
             ;;form: a=b
             (py-assign2 (car targets)
                         (car values))) ;;if this is the second call of a "a,b = c" type form, then the ctx of values will be store instead of load which leads to an error
  
            ;;form: a = b = c
            ((and (> (length targets) 1) (= (length values) 1))
             ;; (list '@ (py-assign2 (car (last targets)) (car values))
             ;;          (py-assign  (butlast targets)
             ;;                      (pyel-change-ctx (car (last targets)) 'load))))
             (let ((out (py-assign2 (car (last targets)) (car values))))
               (setq values (car (last targets))
                     targets (butlast targets))
               (while targets
                 (setq out (py-assign2 (car (last targets)) out)
                       targets (butlast targets)))
               out))
  
  
            ;;form: a,b = x,y
            (t (let* ((tmp-vars (loop for i from 1 to (length targets)
                                      collect (intern (format "__%s__" i))))
                      (let-vars (mapcar* (lambda (a b)
                                           (list a (transform b)))
                                         tmp-vars values)))
                 `(let ,let-vars
                    ,(cons '@ (mapcar* 'py-assign2 targets tmp-vars))))))))
  
  ;;DOC: tranforms must be carefull not to transform code multiple times
  
  (defun py-assign2 (target value)
    ;;access line and col values from `py-assign' calling env.
    (let ((ctx (eval (car (last target))))
  
          (assign-value value))
  
      ;;the target code is responsible for providing the correct assign function
      ;;
  
      ;;TODO:     is context-value still used?
      ;; (using-context assign-target
      ;;             (setq t-target (transform target)))
      ;; (using-context assign-value
      ;;             (setq t-value (transform value)))
  
      ;;The target transform is responsible for generating the code
      ;;The value being assigned to the target is available to the
      ;;target transform via the variable assign-value.
      ;;assign-value is untransformed, the target transform must tranform it
  
      ;; (using-context assign-value
      ;;             (setq assign-value (transform value)))
      ;;problem: code was being transformed multiple times
      (setq assign-value value)
      (using-context assign-target
                     (transform target))
      ;;    (list assign-func t-target t-value)
  
      ))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Assign(targets, value, lineno='nil', col_offset='nil'):
      #    print("targets: ", targets)
      return l_str(["assign ", untuple(targets), value, lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   assign
   ("a = 1" ("a" 1))
   ("class a: pass
  a.b = 1" ("a.b" 1))
   "a.b = c"
   "a.b.c = 1"
   "a.b = d.c"
   ("a,b = 1,2"
    ("a" 1)
    ("b" 2))
   ("x = [1,0,9]
  f = lambda: 3
  class C: pass
  C.a = 3
  a, C.v, x[2] = C.a,1.1, x[x[1]]"
    ("a" 3)
    ("C.v" 1.1)
    ("x[2]" 1))
  
   ("a = 1
  b = 2
  a,b= b,a"
    ("a" 2)
    ("b" 1))
   ("a = [1,2]
  b = (3,4)
  x,y = a
  xx,yy = b"
    ("x" 1)
    ("y" 2)
    ("xx" 3)
    ("yy" 3))
   ("class C:
   a = [11,22,33]
  x,y,z = C.a"
    ("x" 11)
    ("y" 22)
    ("z" 33))
   ("a = 1
  b = 2
  c = 3
  d = a,b,c"
    ("d" [1 2 3]))
  
   "a,b = a.e.e()"
  
   "a[1:4], b[2], a.c = c"
  
   "a = b = c"
   "a = b = c.e"
   "a = b = c.e()"
   ("class x:
   a = 1
  xx = x()
  l = [1,2,3]
  a = xx.a = l[1] = b = c = 9
  z = l[2] = xx.a"
    ("a" 9)
    ("b" 9)
    ("c" 9)
    ("xx.a" 9)
    ("l[1]" 9)
    ("z" 9)
    ("l[2]" 9))
    )
#+END_SRC
** attribute
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform attribute pyel ()
    (lambda (value attr ctx &optional line col)
      (pyel-attribute value attr ctx line col)))
  
  (defun pyel-attribute (value attr ctx &optional line col)
    (setq ctx (cond ((context-p 'force-load) 'load)
                    ((context-p 'force-store) 'store)
                    (t (eval ctx))))
    (let ((t-value (transform value))
          (attr (read (_to- (transform attr)))))
  
      ;;create slot for this attribute if it does not already exist
      (when (and (context-p 'method-def)
                 (not (assoc attr class-def-slots)))
        (push `(,attr :initarg ,(intern (concat ":"
                                                (symbol-name attr)))
                      :initform nil)
  
              class-def-slots))
      (if (and (context-p 'method-call)
               (not (context-p 'method-call-override)))
          (using-context method-call-override
                         ;;ctx?
                         `(@ call-method ,(transform value) ,attr))
  
        ;; (if (context-p 'assign-target)
        ;;          (setq assign-func 'oset))
  
        ;;check the presumption:
        (when (and (eq ctx 'store)
                   (not (context-p 'assign-target))
                   nil);;for this to work, this function need to set context as well
          (error "`pyel-attribute': Presumption failed: ctx==store but not in assign context"))
        (when (and (eq ctx 'store)
                   (not (boundp 'assign-value)))
          (error "`pyel-attribute': Presumption failed: ctx==store but assign-value is unbound"))
  
        (cond
         ((eq ctx 'store)
          ;;(list 'oset t-value attr (transform assign-value)) ;;assign target
          (list 'setattr t-value attr (transform assign-value)))
         ((eq ctx 'load) ;;assign value
          ;;(list 'oref t-value attr)
          (list 'getattr t-value attr))
         (t "Error in attribute-- invalid ctx"))
        )))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Attribute(value, attr, ctx, lineno='nil', col_offset='nil'):
      return l_str(["attribute ", value, "\"" + attr + "\"", ctx, lineno, col_offset])
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests attribute
                     "a.b"
                     "a.b.c"
                     "a.b.c.e"
                     "a.b()"
                     "a.b.c()"
                     "a.b.c.d()"
                     "a.b.c.d(1,3)"
                     "a.b = 2"
                     "a.b.e = 2"
                     "a.b.c = d.e"
                     "a.b.c = d.e.f"
                     "a.b.c = d.e()"
                     "a.b.c = d.e.f()"
                     "a.b.c = d.e.f(1,3)"
                     "a.b, a.b.c = d.e.f(1,3), e.g.b"
                     "a.b(x.y,y)"
                     "a.b(x.y(g.g()),y.y)")
  
#+END_SRC
** num
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform num pyel ()
    (lambda (n &optional line col)
      n 
      ))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Num(n, lineno='nil', col_offset='nil'):
      return "(num " + str(n) +" " + str(lineno) + " " + str(col_offset) + ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   num
   ("3" 3)
   ("4.23" 4.23)
   ("3e2" 300.0))
#+END_SRC
** name
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform name pyel ()
    (lambda (id ctx &optional line col)
      (pyel-name id ctx line col)))
  
  (defun pyel-name (id ctx &optional line col)
    (let ((new-id)
          (id (read id))
          piece code)
  
      ;;TODO: id should be string. verify?
      (setq ctx (cond ((context-p 'force-load) 'load)
                      ((context-p 'force-store) 'store)
                      (t (eval ctx))))
  
  
      (if (assoc id pyel-marked-ast-pieces)
          ;;this id is a marker, insert the corresponding macro
          (progn
            (setq piece (assoc id pyel-marked-ast-pieces))
            ;;'piece' has form: (marker macro-name macro-body)
            (using-context macro-call
                           (list (second piece)
                                 (pyel-transform-ast (third piece) :nosplice))))
  
        ;;else: normal name
        (setq id (_to- id))
        (when (and (context-p 'assign-value) ;;checking assumption
                   (not (equal ctx 'load)))
          (error (format "In transform name: context is 'assign-value' but ctx is not 'load'.
            ctx = %s" ctx)))
  
        (when (and (not (context-p 'function-call))
                   (setq new-id (assoc id pyel-variable-name-translations)))
          (setq id (cadr new-id)))
  
        (when (and (eq ctx 'store)
                   (context-p 'function-def)
                   (context-p 'assign-target))
          (add-to-list 'let-arglist id))
  
        (cond
         ((eq ctx 'load) id)
         ((eq ctx 'store)  (if (context-p 'for-loop-target)
                               id
                             (call-transform 'set id assign-value)))
         (t  "<ERROR: name>"))
        )))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Name(id, ctx, lineno='nil', col_offset='nil'):
      return l_str(["name ", "\"" + id + "\"", ctx, lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-test-name ()
   (should (eq (pyel "testName") 'testName)))
#+END_SRC
** list
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform list pyel ()
    (lambda (elts ctx &optional line col)
      (pyel-list elts ctx line col)))
  
  (defun pyel-list (elts ctx &optional line col)  ;;IGNORING CTX
    (if (context-p 'macro-call)
        (mapcar 'transform elts)
      (cons 'list (mapcar 'transform elts))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def List(elts, ctx, lineno='nil', col_offset='nil'):
      return "(list " + ll_str(elts) + " " + ctx + " " + str(lineno) + " " +str(col_offset) +")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   list
   ("[]" nil)
   ("['a',1,2]" '("a" 1 2))
   ("a = [1,2,'b']
  b = [1,[1,'3',a,[],3]]"
    ("a" '(1 2 "b"))
    ("b" '(1 (1 "3" (1 2 "b") nil 3))))
   ("[[[1]]]" '(((1)))))
#+END_SRC
** dict
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (defvar pyel-dict-test 'equal "Test function for dictionaries")
  
  (def-transform dict pyel ()
    (lambda (keys values &optional line col)
      (pyel-dict keys values line col)))
  
  (defun pyel-dict (keys values line col) ;;TODO: move to lambda in template and create template vars
    (cons 'py-dict (mapcar* (lambda (key value)
                              (list key value))
                            (mapcar 'transform  keys)
                            (mapcar 'transform  values))))
  
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Dict(keys, values, lineno='nil', col_offset='nil'):
      return "(dict " + ll_str(keys) + " " + ll_str(values) + " " + str(lineno) + " " + str(col_offset) + ")"
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defmacro py-dict (&rest pairs)
    (if pairs
        `(let ((__h__ (make-hash-table :test ',pyel-dict-test))) ;;default length??
           ,@(mapcar (lambda (pair)
                       `(puthash ,(car pair) ,(cadr pair) __h__))
                     pairs)
           __h__)
      `(make-hash-table :test ',pyel-dict-test)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   dict
   ("a = {'a':2, 'b':4}
  b = {2:a, 'b':4}
  c = {'a':2, 'b':4, 'c' : {'d' : 1,'e': 2,'f':{'g':3}}}
  d = {}"
    ("repr(a)" "{\"a\": 2, \"b\": 4}")
    ("repr(b)" "{2: {\"a\": 2, \"b\": 4}, \"b\": 4}")
    ("repr(c)" "{\"a\": 2, \"b\": 4, \"c\": {\"d\": 1, \"e\": 2, \"f\": {\"g\": 3}}}")
    ("repr(d)" "{}")
  
    ("repr(c['c'])" "{\"d\": 1, \"e\": 2, \"f\": {\"g\": 3}}")
    ("repr(c['c']['f'])" "{\"g\": 3}")
    ("c['c']['f']['g']" 3)))
#+END_SRC

** tuple
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform tuple pyel ()
    (lambda (elts ctx &optional line col) ;;Ignoring ctx for now
      (cons 'vector (mapcar 'transform elts))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Tuple(elts, ctx, lineno='nil', col_offset='nil'):
      return l_str(["tuple ", ll_str(elts), ctx, lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests Tuple
                     "()"
                     "(a, b)"
                     "(a, (b, (c,d)))"
                     "((((((((a))))))))")
#+END_SRC
** string
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform str pyel ()
    (lambda (s &optional line col)
      ;;    (format "\"%s\"" s)
      s
      ))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Str(s, lineno='nil', col_offset='nil'):
      return "(str \"" + str(s) +"\"" + " " + str(lineno) + " " + str(col_offset) + ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests string
                     "'a'"
                     "x = 'a'"
                     "['a','b']")
#+END_SRC
** comparisons: >, <, ==, !=, <=, >=
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform compare pyel ()
    (lambda (left ops comparators &optional line col)
      ;;what if comparators has multiple items?
      (pyel-compare left ops comparators :outer line col)))
  
  ;;TODO: assign comparators to temp variables to prevent repeated evaluation
  (defun pyel-compare (left ops comparators &optional outer line col)
    ;;if outer is non-nil, then we use 'and' to combine the seporate tests
    (if (> (length ops) 1)
        (list (if outer 'and '@)
              (pyel-compare left (list (car ops)) (list (car comparators)))
              (pyel-compare (car comparators) (cdr ops) (cdr comparators)))
      
      (call-transform (read (car ops)) left (car comparators))))
  
  (pyel-dispatch-func == (l r)
                      (number number) -> (= l r)
                      (string string) -> (string= l r)
                      ;;                       (object _) -> (--eq-- l r)
                      
                      (_ _) -> (equal l r))
  
  (pyel-dispatch-func > (l r)
                      (number number) -> (> l r)
                      ;;TODO: macro for this
                      (string string) -> (pyel-string> l r)
                      (list list) -> (pyel-list-> l r)
                      (object _) -> (call-method l __gt__ r)
                      (vector vector) -> (pyel-vector-> l r)
                      )
  
  ;;TODO: other py types?
  
  ;;::Q does `string<' behave like < for strings in python?
  (pyel-dispatch-func < (l r)
                      (number number) -> (< l r)
                      (string string) -> (string< l r)
                      (list list) -> (pyel-list-< l r)
                      (object _) -> (call-method l __lt__ r)
                      (vector vector) -> (pyel-vector-< l r))
  
  (pyel-dispatch-func >= (l r)
                      (number number) -> (>= l r)
                      (string string) -> (pyel-string>= l r)
                      (list list)     ->  (pyel-list>= l r)
                      (object _) -> (call-method l __ge__ r)
                      (vector vector) -> (pyel-vector->= l r))
  
  (pyel-dispatch-func <= (l r)
                      (number number) -> (<= l r)
                      (string string) -> (pyel-string<= l r)
                      (list list)     -> (pyel-list<= l r)
                      (object _) -> (call-method l __le__ r)
                      (vector vector) -> (pyel-vector-<= l r))
  
  (pyel-dispatch-func != (l r)
                      (number number) -> (pyel-number!= l r)
                      (string string) -> (pyel-string!= l r)
                      (object _) -> (call-method l __ne__ r)
                      (_ _) -> (!equal l r))
  
  ;;this is defined as a transform because `pyel-compare' expects
  ;;all comparison functions to be transforms
  (pyel-dispatch-func is (l r)
                      (_ _) -> (eq l r))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Compare (left, ops, comparators, lineno='nil', col_offset='nil'):
        return l_str(["compare ", left, ll_str(ops), ll_str(comparators), lineno, col_offset ])

  def Gt():
        return "\">\""
  def Lt():
        return "\"<\""
  def Eq():
        return "\"==\""
  def NotEq ():
        return "\"!=\""
  def LtE():
        return "\"<=\""
  def GtE():
        return "\">=\""
  def In():
        return "\"in\""
  def NotIn():
        return "\"not-in\""
  def Is():
        return "\"is\""
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defsubst pyel-string> (a b)
    (and (not (string< a b)) (not (string= a b))))
  
  (defsubst pyel-string<= (a b)
    (or (string< a b) (string= a b)))
  
  (defsubst pyel-string!= (a b)
    (not (string= a b)))
  
  (defsubst pyel-number!= (a b)
    (not (= a b)))
  
  (defun pyel-list-< (a b)
    "a < b"
    (let ((greator nil)
          e1 e2)
      (while (and a b (equal e1 e2))
        (setq e1 (car a)
              e2 (car b)
              a (cdr a)
              b (cdr b)))
      (pyel-< e1 e2)))
  (defun pyel-list-> (a b)
    "a > b"
    (let ((greator nil)
          e1 e2)
      (while (and a b (equal e1 e2))
        (setq e1 (car a)
              e2 (car b)
              a (cdr a)
              b (cdr b)))
      (pyel-> e1 e2)))
  
  (defsubst pyel-list>= (a b)
    (or (equal a b) (pyel-list-> a b)))
  
  (defsubst pyel-list<= (a b)
    (or (equal a b) (pyel-list-< a b)))
  
  (defun pyel-vector-> (a b)
    (let* ((greator nil)
           (len-a (length a))
           (len-b (length b))
           (len (min len-a len-b))
           (i 0)
           e1 e2)
      (while (and (< i len)
                  (equal e1 e2))
        (setq e1 (aref a i)
              e2 (aref b i)
              i (1+ i)))
      (or (pyel-> e1 e2)
          (and (= i len)
               (equal e1 e2)
               (> len-a len-b)))))
  (defun pyel-vector-< (a b)
    (let* ((greator nil)
           (len-a (length a))
           (len-b (length b))
           (len (min len-a len-b))
           (i 0)
           e1 e2)
      (while (and (< i len)
                  (equal e1 e2))
        (setq e1 (aref a i)
              e2 (aref b i)
              i (1+ i)))
      (or (pyel-< e1 e2)
          (and (= i len)
               (equal e1 e2)
               (< len-a len-b)))))
  
  (defsubst pyel-vector-<= (a b)
    (or (equal a b) (pyel-vector-< a b)))
  
  (defsubst pyel-vector->= (a b)
    (or (equal a b) (pyel-vector-> a b)))
  
  (defsubst !equal (a b)
    (not (equal a b)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests compare
                     "a=='d'"
                     "a==b"
                     "a>=b"
                     "a<=b"
                     "a<b"
                     "a>b"
                     "a!=b"
                     "(a,b) == [c,d]"
                     "[a == 1]"
                     "((a == 1),)"
                     "a<b<c"
                     "a<=b<c<=d"
                     "a.b<=b.c()<c<=3")
#+END_SRC
** if
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform if pyel ()
    (lambda (test body orelse &optional line col)
      (pyel-if test body orelse line col)))
  
  (defun pyel-if (test body orelse &optional line col)
    (let* ((tst (transform test))
           (true-body (if (> (length body) 1)
                          (append (remove-context tail-context
                                                  (mapcar 'transform
                                                          (or (subseq body 0 -1)
                                                              (list (car body)))))
                                  (list (transform (car (last body)))))
                        (mapcar 'transform body)))
           (false-body (if (> (length orelse) 1)
                          (append (remove-context tail-context
                                                  (mapcar 'transform
                                                          (or (subseq body 0 -1)
                                                              (list (car orelse)))))
                                  (list (transform (car (last orelse)))))
                        (mapcar 'transform orelse))) 
           (progn-code (if (> (length true-body) 1)
                           '(@ progn)
                         '@)))
  
      `(if  ,(if (equal tst []) nil tst)
  
           (,progn-code ,@true-body)
         ,@false-body)))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def If (test, body, orelse, lineno='nil', col_offset='nil'):
      return l_str(["if ",test, ll_str(body), ll_str(orelse), lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   if
   ("if True:
   x = 1
  else:
   x = 2"
    ("x" 1))
   ("if False:
   x = 3
  else:
   x = 4"
    ("x" 4))
   ("if len([1,2,3]) == 3:
   y = 1
   x = 5
  else:
   y = 1
   x = 6"
    ("x" 5))
  
   ("def a():
   if True:
    return 1
   else:
    return 2
  
  def b():
   if True:
    return 1
    x()
   else:
    y()
    return 2
  
  def c():
   if 1 == 2:
    return 1
    x()
   else:
    y()
    return 2
  
  def d():
   if 1 == 2:
    return 4
   else:
    if True:
     return 1.1
     x()
    return 2
  
  def e():
   if 1 == 1:
    if True:
     if [0][0] == 0:
      return 12
     x()
   else:
    y()
    return 2"
    ("a()" 1)
    ("b()" 1)
    ("c()" 2)
    ("c()" 1.1)
    ("e()" 12))
  
   ("def test():
   if 1 == 3:
    return 12
   elif 3 == 5:
    return 123
   elif 2 == 2:
    return 234
   else:
    return 33"
   ("test()" 234)))
  
#+END_SRC
** call
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (defvar pyel-obj-counter 0)
  
  (defun pyel-next-obj-name ()
    (if pyel-unique-obj-names
        (format "obj-%d" (setq pyel-obj-counter (1+ pyel-obj-counter)))
      "obj"))
  
  ;; (pyel-dispatch-func fcall (_func &rest args)
  ;;                      ($func _) -> ($func ,@args)
  ;;                      (_ _) -> (funcall $func ,@args))
  
  ;; functions set to variables override those defined with `defun'
  ;; this allows locally defined functions to override their global
  ;; counterparts without defining themselves globally
  (pyel-dispatch-func fcall (_func &rest _args)
                      (vfunc _) -> (funcall $func ,@(pyel-sort-kwargs args))
                      ;;($function _) -> ($func ,@(pyel-sort-kwargs args))
                      (class _) -> (call-method $func --new--
                                                ,@(pyel-sort-kwargs args))
  
                      (instance _) -> (call-method $func --call--
                                                   ,@(pyel-sort-kwargs args))
                      (_ _) -> ($func ,@(pyel-sort-kwargs args))
                      )
  
  (def-transform keyword pyel ()
    (lambda (arg value &optional line col)
      (if (context-p 'keywords-alist)
          (list (_to- arg) (transform value))
        (list '@ (_to- arg)  '= (transform value)))))
  
  (def-transform call pyel ()
    ;;TODO: some cases funcall will need to be used, how to handle that?
    (lambda (func args keywords starargs kwargs &optional line col)
      (pyel-call-transform func args keywords starargs kwargs line col)))
  
  (defun pyel-call-transform (func args keywords starargs kwargs &optional line col)
    (let ((t-func (using-context function-call
                                 (transform func)))
          (keyword-args (using-context keywords-alist
                                       (mapcar (lambda (x) (transform (car x)))
                                               keywords)))
          new-func m-name f-name star-args kw-args)
      ;; (if (member t-func pyel-defined-classes)
      ;;     ;;instantiate an object and call its initializer
      ;;     `(let ((__c (,t-func ,(pyel-next-obj-name))))
      ;;        (--init-- __c ,@(mapcar 'transform args))
      ;;        __c)
      
      (if (eq (car func) 'attribute);;method call
          (if (and (member (setq m-name (read (caddr func)))
                           pyel-method-transforms)
                   (setq m-name (pyel-find-method-transform-name
                                 m-name
                                 (1+ (length args)))));;1+ because args does not include the object
  
              ;;this methods transform is overridden
              (progn
                ;;dynamic scoping saves the day again!
                (setq keyword-args keywords
                      star-args starargs
                      kw-args kwargs)
  
                (eval `(call-transform ',m-name
                                       ',(transform (cadr func))
                                       ,@(mapcar '(lambda (x) `(quote ,x)) args))))
            ;;normal method call
            (remove-context method-call-override
                            (using-context method-call
                                           `(,(transform func) ,@(remove-context method-call
                                                                                 (mapcar 'transform args))))))
  
        (when (setq new-func (assoc t-func pyel-function-name-translations));;function call
          ;;translate name
          (setq t-func (cadr new-func)))
  
        ;;call function transform if one was defined
        (cond ((and keyword-args
                    (member t-func pyel-func-kwarg-transforms))
               ;;transform defined with `pyel-func-kwarg-transform'
               (eval `(call-transform ',(pyel-func-transform-name t-func t)
                                      ',keyword-args
                                      ,@(mapcar '(lambda (x) `(quote ,x)) args))))
              ((member t-func pyel-func-transforms)
               ;;transform defined with `pyel-func-transform'
               (eval `(call-transform ',(pyel-func-transform-name t-func)
                                      ;;',(transform (cadr func))
                                      ,@(mapcar '(lambda (x) `(quote ,x)) args))))
              
  
              ((member t-func pyel-func-transforms2)
               ;;transform defined with `pyel-define-function-translation'
               (eval `(call-transform ',(pyel-func-transform-name t-func)
                                      ;;,(mapcar '(lambda (x) `(quote ,x)) args)
                                      (mapcar 'transform args)
                                      keyword-args)))
  
               ;;normal function call
               ;;`(,t-func ,@(mapcar 'transform args))
               ;;TODO: this is dumb, convert `call-transform' to a macro?
               (t (eval `(call-transform 'fcall ,@(cons 't-func
                                                        (mapcar (lambda (x)
                                                                  `(quote ,x))
                                                                (append args
                                                                        (mapcar 'car
                                                                                keywords))
                                                                )))))))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Call(func, args, keywords, starargs, kwargs, lineno='nil', col_offset='nil'):
      return l_str(["call ", func, ll_str(args), ll_str(keywords), starargs or "nil" , kwargs or "nil", lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests call
                     "aa()"
                     "aa(b,c(1,2))"
                     ;;"aa()()" does not work yet
                     "aa=b()"
                     ;;"aa.b()"
                     ;;"[aa.b()==4]"
                     "aa(3,b(c(),[2,(2,3)]))"
                     "aa.b()"
                     "aa.b(1,2)"
                     "aa.b(1,a.b(1,2,3))"

                     "a.b().c()"
                     "a.b().c().d()"
                     "a.b(x.y().e()).c()"

                     )
#+END_SRC
** while loop
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform while pyel ()
    (lambda (test body orelse &optional line col)
      (pyel-while test body orelse line col)))
  
  ;;doc: context macro-call
  (defun pyel-while (test body orelse &optional line col)
    ;;pyel-while is special. it gets to handle the macro definitions
    (let* ((tst (transform test))
           (else (mapcar 'transform orelse))
           break-code
           continue-code
           macro-name
           t-body
           t-last
           break-code
           continue-code
           wile
           ;;inter-transform variables
           continue-while
           break-while )
  
      (if (and (symbolp tst)
               (string-match (format "^%s\\([A-Za-z0-9_]+\\)$" pyel-py-macro-prefix)
                             (symbol-name tst)))
          (using-context
           macro-call
           ;;expand as a macro call
           `(,(intern (replace-regexp-in-string "_" "-"
                                                (match-string 1 (symbol-name tst))))
             ;;TODO: if macro name is an alias, replace with actual
             ,@(mapcar 'transform body)))
  
        ;;expand as a normal while loop
        (using-context
         while
  
         (setq code (remove-context tail-context (mapcar 'transform body))
               ;;^ no tail calls from while loop
                ;; t-body (remove-context tail-context
                ;;                        (mapcar 'transform (subseq body 0 -1)))
                ;; t-last (transform (car (last body)))
                ;; code (append t-body (list t-last))
  
  
               break-code (if break-while '(catch '__break__)
                            pyel-nothing)
               continue-code (if continue-while '(catch '__continue__)
                               pyel-nothing)
               wile `(,@break-code
                      (while
                          ,(if (equal tst []) nil tst)
                        (,@continue-code
                         ,@code)))))
        (if else
            `(@ ,wile ,@else)
          wile))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def While(test, body, orelse, lineno='nil', col_offset='nil'):
      return l_str(["while ", test, ll_str(body), ll_str(orelse), lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests 
   while
   ("x = 1
  a = 0
  while x < 10:
   a += x
   x += 1"
    ("a" 45))
  
   ;;return from tail context
   ("def f():
   x = 1;
   while x < 10:
    return x
    x+=1
   return x
  
  def g():
   x = 1;
   while x < 10:
    x+=1
    return x
   return x"
    ("f()" 1)
    ("g()" 2))
  
   ;;break
   ("x = 1
  while x < 10:
   if x == 3:
    break
   x+=1"
    ("x" 3))
  
   ;;continue
   ("x = 0
  a=0
  while x < 10:
   x+=1
   if x%2 == 0:
    continue
   a+=1"
    ("a" 5)))
#+END_SRC
** arguments
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform arguments pyel ()
    (lambda (args vararg varargannotation kwonlyargs kwarg kwargannotation
                  defaults kw_defaults)
      (pyel-arguments args vararg varargannotation kwonlyargs kwarg kwargannotation
                      defaults kw_defaults)))
  
  (defun pyel-arguments (args vararg varargannotation
                              kwonlyargs kwarg kwargannotation
                              defaults kw_defaults)
    ;;TODO: other args
  
    (let* ((args (mapcar 'transform args))
           (defaults (mapcar 'transform defaults)))
  
      ;;&optional
      (when defaults
        (setq defaults (mapcar* (lambda (arg default)
                                  (setq arg (_to- arg))
                                  (cons arg default))
                                (reverse args) (reverse defaults)))
          (setq args (append (subseq args 0 (- (length args) (length defaults)))
                             '(&optional)
                             defaults)))
  
      ;;&rest
      (when vararg
        (setq args (append args (list '&rest vararg)))
        (when (and (not pyel-use-list-for-varargs)
                   (context-p 'function-def))
          (push `(setq, vararg (list-to-vector ,vararg)) assign-defaults)))
  
      ;;&kwonly
      (when kwonlyargs
        (setq args (append args (cons '&kwonly
                                      (mapcar* 'cons
                                               (mapcar 'transform kwonlyargs)
                                               (mapcar 'transform kw_defaults))))))
                                      
      ;;&kwarg
      (when kwarg
        (setq args (append args (list '&kwarg kwarg))))
  
      args))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def arguments(args=None, vararg=None, varargannotation=None, kwonlyargs=None,
                kwarg=None, kwargannotation=None,defaults=None, kw_defaults=None):
      return ll_str(["(arguments ",
                     ll_str(args) or "nil",
                     vararg or "nil",
                     varargannotation or "nil",
                     ll_str(kwonlyargs) if kwonlyargs else "nil",
                     kwarg or "nil",
                     kwargannotation or "nil",
                     ll_str(defaults) or "nil",
                     ll_str(kw_defaults) if kw_defaults else "nil", ")"])
      #return l_str(["_arguments ",ll_str(args) or "nil",vararg or "nil",varargannotation or "nil", kwonlyargs or "nil", kwarg or "nil", kwargannotation or "nil", defaults or "nil", kw_defaults or "nil"])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-test-arguments ()
    (with-transform-table 'pyel
                          (and
                           (should (equal (transform '(arguments ((arg "b" nil)
                                                                  (arg "c" nil)) nil nil nil nil nil nil nil))
  
                                          '(b c)))
                           ;;other tests here
                           )))
#+END_SRC
** function def
includes 'arg' transformation
*** python ast expansion example
"def a(b,c):
  print('ok')
  return c+a"

FunctionDef(name='a',
	    args=arguments(args=[arg(arg='b', annotation=None), arg(arg='c', annotation=None)],
				vararg=None,
				varargannotation=None,
				kwonlyargs=[],
				kwarg=None,
				kwargannotation=None,
				defaults=[],
				kw_defaults=[]),

	    body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='ok')], keywords=[], starargs=None, kwargs=None)), Return(value=BinOp(left=Name(id='c', ctx=Load()), op=Add(), right=Name(id='a', ctx=Load())))],

	    decorator_list=[],
	    returns=None)

*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform arg pyel ()
    (lambda (arg annotation) ;;Ignoring annotation
      (read arg)))
  
  (def-transform def pyel ()
    (lambda (name args body decoratorlist returns &optional line col)
      (pyel-def name args body decoratorlist returns line col)))
  
  (defun transform-last-with-context (context code)
    ;;TODO: this does not work: fix and replace code in `pyel-def
    (let*  ((last-line (using-context context
                                      (transform (car (last code)))))
            (first (mapcar 'transform (subseq code 0 (1- (length code))))))
      (append first (list last-line))))
  
  (defun pyel-def (name args body decoratorlist returns &optional line col)
    (let ((name (read (_to- name))))
  
      (when (context-p 'function-def)
        (push name let-arglist)) ;;do this before the let-arglists gets overridden for this transform
  
      (let* ((func 'def)
             t-body
             arglist
             first
             last-line
  
             ;;trans-template vars
             (assign-defaults (list pyel-nothing));;holds assignment code set by the arguments transform
             return-middle
             let-arglist
             global-vars
             docstring
             interactive
  
                ;;;
             (ret pyel-nothing)
             (args (_to- (using-context function-def (transform (car args)))))
             (inner-defun (context-p 'function-def))
             (orig-name name)
             (decorators (mapcar 'transform decoratorlist))
             setq-code
             )
  
        (when (or (context-p 'lambda-def)
                  (and inner-defun
                       (not (member '&kwarg args))))
  
          (setq decorators (cons 'pyel-lambda decorators)
                name nil))
  
        (using-context
         function-def
         (cond
  
          ;; ((context-p 'class-def) (using-context method-def
          ;;                           (setq last-line (using-context tail-context
          ;;                                                          (transform (car (last body))))
          ;;                                 first (mapcar 'transform (subseq body 0 (1- (length body))))
          ;;                                 t-body (append first (list last-line)))
  
          ;;                           ;;TODO: let-arlist for methods like
          ;;                           ;;      and *args ...
          ;;                           (push `(defmethod ,name
          ;;                                    ((,(car args) ,class-def-name)
          ;;                                     ,@(cdr args))
  
          ;;                                    ,@t-body)
          ;;                                 class-def-methods)))
  
          (t (setq last-line (using-context tail-context
                                            (transform (car (last body))))
                   first (subseq body 0 (1- (length body)))
                   first (if first
                             (mapcar 'transform first)
                           nil)
                   t-body (append first (list last-line)))
  
             ;;(setq t-body (transform-last-with-context
             ;;                'tail-context body))
  
             ;;remove variables from the let arglist that have been declared global
             (setq let-arglist (let (arglist) (mapcar (lambda (x)
                                                        (unless (or (member x global-vars)
                                                                    (member x args))
                                                          (push x arglist)))
                                                      let-arglist)
                                    arglist))
             ;;      ?remove variables that are defined in emacs?
  
             (setq docstring
                   (if (stringp (car t-body))
                       (pop t-body)
                     pyel-nothing))
  
             (setq ret (if return-middle '(catch '__return__)
                         '(@)))
  
             (if let-arglist
                 (setq let-arglist (list '@ 'let let-arglist))
               (setq let-arglist '@))
  
             (if inner-defun
                 (progn
                   (if (and (member '&kwarg args)
                            (not (member 'pyel-lambda decorators)))
                       (setq decorators
                             (cons 'pyel-lambda decorators)))
                   (setq setq-code (list '@ 'setq orig-name)))
               (setq setq-code '@))
  
             (if interactive
                 (push 'interactive decorators))
  
             `(,setq-code (,func ,name ,args ,decorators
                                 ,docstring
                                 ,@assign-defaults
                                 (,let-arglist
                                  (,@ret
                                   ,@t-body
                                   ))))
             ))))))
  
  (defun pyel-sort-kwargs (args)
    "Organize args in the format required by functions that accept keyword args
  Returns a list whose first element has an alist containing the keyword args
  in the cdr and ':kwargs' in the car position.
  and whose second element is a list of all non-keyword args
  Recognizes keyword args in the form 'arg = value'."
    ;;for use in the 'fcall' transform
    (if (member '= args)
        (let ((current args)
              kwargs
              normal)
          (when (eq (car current) '=) (error "invalid keyword arg syntax"))
          (while current
            (if (eq (car current) '=)
                (progn
                  (when (null (cdr current)) (error "invalid keyword arg syntax"))
                  (push (cons (pop normal) (cadr current)) kwargs)
                  (setq current (cddr current)))
              (push (car current) normal)
              (setq current (cdr current))))
          (list (list 'quote (cons :kwargs kwargs)) (list 'quote (reverse normal))))
      args))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-alist-to-hash (alist)
    "Turn ALIST a hash table.
  Each element in ALIST must have for form (a . b)"
    (let ((ht (make-hash-table
               :test 'equal
               :size (length alist))))
      (mapc (lambda (x)
              (puthash (car x) (cdr x) ht))
            alist)
      ht))
  
  (defmacro def (name args decorator-list &rest body)
    ;;TODO: apply decorators
  
    (if (and (= (length body) 1)
             (stringp (car body)))
        (push nil body))
  
    (using-context
     function-def
     ;; (if (or (member '&kwarg args)
     ;;         (member '&kwonly args))
     (let* ((n -1)
            (func-name (if (member 'pyel-lambda decorator-list)
                           (progn
                             (setq decorator-list
                                   (remove 'pyel-lambda
                                           decorator-list))
                             '(lambda))
                         (list 'defun name)))
            (interactive (when (member 'interactive decorator-list)
                           (setq decorator-list
                                 (remove 'interactive
                                         decorator-list))
                           t))
           optional optional-defaults
           pos+optional rest kwarg kwonly
           npositional nargs arg-index
           kw-only-args kw-only-defaults)
  
       (when (member '&kwarg args)
         (setq kwarg (car (last args))
               args (subseq args 0 -2)
               args-without-kwarg args))
       (when (member '&kwonly args)
         (setq kwonly (pyel-split-list args '&kwonly)
               args (car kwonly)
               kwonly (cdr kwonly)
               kw-only-args (mapcar 'car kwonly)
               kw-only-defaults (mapcar 'cdr kwonly)
               args-without-kwarg args))
       (when (member '&rest args)
         (setq rest (car (last args))
               args (subseq args 0 -2)))
       (if (member '&optional args)
           (setq optional (pyel-split-list args '&optional)
                 positional (car optional)
                 optional (cdr optional)
                 optional-defaults (mapcar 'cdr optional)
                 optional (mapcar 'car optional)
                 )
         (setq positional args))
  
       (setq npositional (length positional)
             nargs (+ (length positional) (length optional))
             arg-index-alist (mapcar (lambda (x)
                                       (setq n (1+ n))
                                       (cons x n))
                                     (append positional optional)))
  
       `(,@func-name (&rest __pyel_args)
                     ,@(if interactive '((interactive)) nil)
                     (let* (,@(if rest (list rest) nil)
                            ,@(if kwarg (list kwarg) nil)
                            ,@positional
                            ,@optional
                            ,@kw-only-args)
                       
                       (if (and (listp (car __pyel_args))
                                (eq (caar __pyel_args) :kwargs))
                           ;;if this is called with keyword args they will be
                           ;;the in an alist in the car position.                         
                           (let*  ((__pyel_kwargs (cdar __pyel_args))
                                   (__pyel_args (cadr __pyel_args))
                                   (__pyel_len (length __pyel_args))
                                   (__pyel_kwarglen (length __pyel_kwargs))
                                   (__pyel_kwargs-used 0)
                                   (__pyel_values_provided (make-vector ,nargs nil))
                                   __pyel_error)
                             
                             ;;set *rest arg
                             ,(if rest
                                  `(if (> __pyel_len ,nargs)
                                       (setq ,rest (subseq __pyel_args ,nargs))))
                             
                             ;;set positional arg values
                             (setq __pyel_tmp __pyel_args)
                             
                             ,(if positional
                                   `(setq 
                                     ,@(reduce 'append (mapcar (lambda (arg)
                                                                `(,arg (car __pyel_tmp)
                                                                       __pyel_tmp (cdr __pyel_tmp)))
                                                              positional))))
                             ,(if optional
                                   `(setq 
                                     ,@(reduce 'append (mapcar* (lambda (arg default)
                                                                 `(,arg (or (car __pyel_tmp) ,default)
                                                                        __pyel_tmp (cdr __pyel_tmp)))
                                                               optional optional-defaults))))
  
                             ;;set positional and optional arg values that are provided as keywords
                             ;;(optional arg default values are set elsewhere)
                             ,@(let* ((i 0)
                                      (args (append positional optional))
                                      code arg)
                                 (while args
                                   (setq arg (car args)
                                         args (cdr args)
                                         code `((if (= __pyel_kwarglen 0)
                                                    nil
                                                  (if (setq __pyel_val (assoc (quote ,arg) __pyel_kwargs))
                                                      (if (or (<= ,(setq i (1+ i)) __pyel_len)
                                                              (aref __pyel_values_provided ,(1- i)))
                                                          ;;the value for this arg has already been provided
                                                          (setq __pyel_error (quote ,arg))
                                                        ;;else:
                                                        (aset __pyel_values_provided ,(1- i) t)
                                                        (setq ,arg (cdr __pyel_val)
                                                              __pyel_kwargs (remove __pyel_val __pyel_kwargs)
                                                              __pyel_kwargs-used (1+ __pyel_kwargs-used)
                                                              __pyel_kwarglen (1- __pyel_kwarglen))))
                                                  ,@code))))
                                 code)
  
  
                             (if __pyel_error
                                 (signal 'TypeError
                                         (format ,(format "%s() got multiple values for keyword argument '%%s'"
                                                          name)
                                                 __pyel_error)))
  
                             ;;set kwonly arg values
                             ,@(mapcar* (lambda (arg default)
                                          `(if (setq __pyel_val (assoc (quote ,arg) __pyel_kwargs))
                                               (progn
                                                 (setq ,arg (cdr __pyel_val))
                                                 (setq __pyel_kwargs (remove __pyel_val __pyel_kwargs))
                                                 )
                                             (setq ,arg ,default)))
                                        kw-only-args kw-only-defaults)
  
                             ;;verify that minimum required arguments have been passed
                             ,(if (or rest optional)
                                  `(if (< (+ __pyel_kwargs-used __pyel_len) ,npositional)
                                       (signal 'TypeError (format ,(format "%s() takes at least %s arguments (%%s given)"
                                                                           name npositional)
                                                                  (+ __pyel_kwargs-used __pyel_len))))
                                `(if (not (= (+ __pyel_kwargs-used __pyel_len) ,npositional))
                                     (signal 'TypeError (format ,(format "%s() takes exactly %s arguments (%%s given)"
                                                                         name npositional)
                                                                (+ __pyel_kwargs-used __pyel_len)))))
                             
                             ,(if kwarg
                                  `(setq ,kwarg (pyel-alist-to-hash __pyel_kwargs)))
                             ;;NOTE: dont have to worry about repeated keywords because that is a syntax error
                             )
                         
                         ;;else: called without keyword args
                         ,(if (or rest optional)
                              `(if (< (length __pyel_args) ,npositional)
                                   (signal 'TypeError (format ,(format "%s() takes at least %s arguments (%%s given)"
                                                                       name npositional)
                                                              (+ __pyel_kwargs-used __pyel_len))))
                            `(if (not (= (length __pyel_args) ,npositional))
                                 (signal 'TypeError (format ,(format "%s() takes exactly %s arguments (%%s given)"
                                                                     name npositional)
                                                            (+ __pyel_kwargs-used __pyel_len)))))
                         
                         ,@(mapcar (lambda (arg-value) ;;set kwarg defaults
                                     (list 'setq (car arg-value)
                                           (cdr arg-value)))
                                   kwonly)
  
                         ,(if (or positional optional) ;;set arg values
                              `(setq 
                                ,@(append (reduce 'append (mapcar (lambda (arg)
                                                            `(,arg (car __pyel_args)
                                                                   __pyel_args (cdr __pyel_args)))
                                                           positional))
                                          (reduce 'append (mapcar* (lambda (arg default)
                                                                    `(,arg (or (car __pyel_args) ,default)
                                                                           __pyel_args (cdr __pyel_args)))
                                                                   optional optional-defaults)))
                                          ))
                         
                         ,(if rest ;;set *rest arg
                              `(setq ,rest __pyel_args)
                            ;;TODO: verify that __pyel_args is null here (else case)
                            )
  
                         ,(if kwarg `(setq ,kwarg (make-hash-table :size 0))))
                       
                       ,@body)))))
  
  
  ;;tmp fix (default values for kwonly args are not getting translated)
  (setq None nil)
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def FunctionDef(name, args, body, decorator_list, returns, lineno='nil', col_offset='nil'):
      return " ".join(map(str, ["(def \"", name,"\"", ll_str(args), ll_str(body), ll_str(decorator_list) or "nil",returns or "nil", lineno, col_offset, ")"]))
  
  def arg(arg, annotation):
      return "(arg \"" + arg + "\" " + " " + (annotation or "nil") + ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   def
   ("def a():
    return 0
  
  def b(a):
   return a
  
  def c(a,b,c):
   return a+b+c
  
  def d(a):
   if True:
    return a
   return 5
   somethingelse()
  
  def e(a=1.1):
   return a
  def f(*a):
   return a
  "
    ("a()" 0)
    ("b(1)" 1)
    ("c(1,2,3)" 6)
    ("d(2)" 2)
    ("e()" 1.1)
    ("e(22)" 22)
    ("f(1,3,5,6,8)" [1, 3, 5, 6, 8]))
   
   ;;test interactively
   ("def a():
   'docstring'
   interactive()
   x = 1
   return 'hi'
  
  def b():
   return 2"
    ("commandp(quote(a))" t)
    ("commandp(quote(b))" nil)))
  
  (pyel-create-tests
   function-arguments
   ("def func(__a,__b,c=1,d='two',*rest,**kwargs):
   return [__a,__b,c,d,rest,kwargs]"
    ("repr(func(1,2))"
     "[1, 2, 1, \"two\", [], {}]")
    ("repr(func(1,2,3))"
     "[1, 2, 3, \"two\", [], {}]")
    ("repr(func(1,2,3,4))"
     "[1, 2, 3, 4, [], {}]")
    ("repr(func(1,2,3,4,5))"
     "[1, 2, 3, 4, [5], {}]")
    ("repr(func(1,2,3,4,5,6))"
     "[1, 2, 3, 4, [5, 6], {}]")
    ("repr(func(1,2,3,4,5,6,x = 's'))"
     "[1, 2, 3, 4, [5, 6], {x: \"s\"}]")
    ("repr(func(1,2,3,4,5,6,x = 's',y = 23))"
     "[1, 2, 3, 4, [5, 6], {y: 23, x: \"s\"}]")
    ("repr(func(x = 's',__b = 324,__a = 'n',))"
     "[\"n\", 324, 1, \"two\", [], {x: \"s\"}]")
    ("repr(func(x = 's',__b = 324,__a = 'n',d = 2))"
     "[\"n\", 324, 1, 2, [], {x: \"s\"}]"))
   ;;tests with kwonlyargs
   ("def test(a, *b, c=1, d, **e):
   return [a, b, c, d, e]"
    ("repr(test('x',1,2,3,_d=1.1,_xx=2.2,_yy=3.3))"
     "[\"x\", [1, 2, 3], 1, nil, {-yy: 3.3, -xx: 2.2, -d: 1.1}]")
  
    ("repr(test('x',d=1.1))"
     "[\"x\", nil, 1, 1.1, {}]")
  
    ("repr(test('x'))"
     "[\"x\", nil, 1, nil, {}]")
  
    ("repr(test(d=1,c=2,a='x',e=4))"
     "[\"x\", (), 2, 1, {e: 4}]")
  
    ("repr(test(1,2,3,4,5,6))"
     "[1, (2, 3, 4, 5, 6), 1, nil, {}]"))
  
   ("def test(a,b):
       return [a,b]"
    ("test(1,2)" '(1 2))
    ("test(b=4,a='s')" '("s" 4)))
  
   ;;check that default values for optional args get set with or without kwargs
   ("def test(a,b,c,d=1,dd=2,ddd=4,*restst, x=1,xx=32,xxx=43,**kwargs_):
   return [a,b,c,d,dd,ddd,restst,x,xx,xxx,kwargs_]"
    ("repr(test(1,2,3,999,888,777,1,2,3,43,4,5,x=3))"
     "[1, 2, 3, 999, 888, 777, [1, 2, 3, 43, 4, 5], 3, 32, 43, {}]")
    ("repr(test(1,2,3,999,888,777,1,2,3,43,4,5))"
     "[1, 2, 3, 999, 888, 777, [1, 2, 3, 43, 4, 5], 1, 32, 43, {}]"))
   )
  
  (ert-deftest pyel-test-sort-kwargs ()
    (equal (pyel-sort-kwargs '(a b = 1 5 12 x = 1 3))
           '((a 5 12 3) ((x . 1) (b . 1))))
    (equal (pyel-sort-kwargs '(b = 1 x = 1))
           '(nil ((x . 1) (b . 1))))
    (equal (pyel-sort-kwargs '(b = 1))
           '(nil ((b . 1))))
    (equal (pyel-sort-kwargs '(a b c d))
           '((a b c d) nil))
    (equal (pyel-sort-kwargs '(a b = (b 1 2) 5 12 x = 1 (+ 1 3 ) y = "s"))
           '((a 5 12 (+ 1 3)) ((y . "s") (x . 1) (b b 1 2)))))
#+END_SRC
** bin-op, +, -, *, /, **, |, &
::Q can an overloaded + operator obj be used like:  3+obj
    these transforms assume you can
TODO: FIX: most of these are wrong.
      if one arg is a number, then the other may still be an object
overloadable operators: http://rgruet.free.fr/PQR26/PQR2.6.html#SpecialMethods

emacs bitwise operators: http://www.gnu.org/software/emacs/manual/html_node/elisp/Bitwise-Operations.html

*** transform
TODO: tests!
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform bin-op pyel ()
    (lambda (left op right &optional line col)
      (call-transform op left right)))
  
  (pyel-dispatch-func * (l r)
                      (object _)  -> (call-method l --mul-- r)
                      (string _)
                      (_ string)  -> (pyel-mul-num-str l r)
                      (_ _)       -> (* l r))
  
  (pyel-dispatch-func + (lhs rhs)
                      (number _) -> (+ lhs rhs)
                      (string _) -> (concat lhs rhs)
                      (list _)   -> (append lhs rhs)
                      (object _) -> (call-method lhs --add-- rhs)
                      (_ number)  -> (+ lhs rhs)
                      (vector _)
                      (_ vector)  -> (vconcat lhs rhs)
                      (_ string) -> (concat lhs rhs)
                      (_ list)   -> (append lhs rhs))
  
  (pyel-dispatch-func - (l r)
                      (number _) -> (- l r)
                      (object _) -> (call-method l --sub-- r)
                      (_ number) -> (- l r))
  
  (pyel-dispatch-func ** (l r) ;;pow
                      (number _) -> (expt l r)
                      (object _) -> (call-method l --pow-- r)
                      (_ number) -> (expt l r))
  
  (pyel-dispatch-func / (l r)
                      (number _) -> (pyel-div l r)
                      (object _) -> (call-method l --truediv-- r)
                      (_ number) -> (pyel-div l r))
  
  (pyel-dispatch-func // (l r) ;;floored (normal) division
                      (number _) -> (/ l r)
                      (object _) -> (call-method l --floordiv-- r)
                      (_ number) -> (/ l r))
  
  (pyel-dispatch-func ^ (l r) ;;bit xor
                      (number _) -> (logxor l r)
                      (object _) -> (call-method l --xor-- r)
                      (_ number) -> (logxor l r))
  
  (pyel-dispatch-func & (l r) ;;bit and
                      (number _) -> (logand l r)
                      (object _) -> (call-method l --and-- r)
                      (_ number) -> (logand l r))
  
  (pyel-dispatch-func | (l r) ;;bit or
                      (number _) -> (logior l r)
                      (object _) -> (call-method l --or-- r)
                      (_ number) -> (logior l r))
  
  (pyel-dispatch-func % (l r)
                      (number _) -> (% l r)
                      (object _) -> (call-method l --mod-- r))
  
  
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def BinOp(left, op, right, lineno='nil', col_offset='nil'):
      return l_str(["bin-op ", left, op, right, lineno, col_offset])

  def Add():
      return "+"
  def Mult():
      return "*"
  def Sub():
      return "-"
  def Div():
      return "/"
  def FloorDiv():
      return "//"
  def Pow():
      return "**"
  def BitXor():
      return "^"
  def BitOr():
      return "|"
  def BitAnd():
      return "&"
  def Mod():
      return "%"
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-mul-num-str (left right)
    (let ((c 0)
          (ret "")
          num str)
      (if (numberp left)
          (setq num left
                str right)
        (setq num right
              str left))
      (while (< c num)
        (setq ret (concat ret str)
              c (1+ c)))
      ret))
  
  (defmacro pyel-div (l r)
    (cond ((or (floatp l)
               (floatp r))
           `(/ ,l ,r))
          ((integerp l)
           `(/ ,(* 1.0 l) ,r))
          ((integerp r)
           `(/ ,l ,(* 1.0 r)))
          (t `(/ (* ,l 1.0) ,r))))
#+END_SRC
*** tests TODO
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   add-op
   ("1 + 2" 3)
   ("'a' + 'b'" "ab")
   ("n1 = 2
  n2 = 5
  s1 = 'asd'
  s2 = 'df'
  l1 = [1]
  l2 = [3,'a']
  v1 = (1,2)
  v2 = (3,)"
    ("n1 + n2" 10)
    ("s1 + s2" "asddf")
    ("l1 + l2" '(1 3 "a"))
    ("v1 + v2" [1 2 3]))
   
   ("class test:
   def __init__(self, n):
    message('init')
    self.n = n*2
   def __add__(self, o):
    message('adding')
    return self.n + o.n
  x = test(5)
  y = test(2)"
    ("x + y" 14)))
  
  (pyel-create-tests
   sub-op
   ("3 - 2" 1)
   ("n1 = 5
  n2 = 3"
    ("n1 - n2" 2)))
  
  (pyel-create-tests
   mult-op
   ("3 * 4" 12)
   ("'a' * 3" "aaa")
   ("4*'b'" "bbbb")
   ("n1 = 2
  n2 = 4
  s = 's'"
    ("n1 * n2" 8)
    ("s * n1" "ss")
    ("n1 * s" "ss"))
   )
  
  (pyel-create-tests
   pow-op
   ("3 ** 4" 81)
   ("n1 = 2
  n2 = 4"
    ("n1 ** n2" 16)))
  
  (pyel-create-tests
   div-op
   ("9 / 4" 2.25)
   ("9 // 4" 2)
   ("a = 9
  b = 4"
    ("a / b" 2.25)
    ("a // b" 2))
   )
  
  (pyel-create-tests
   bin-ops
   ("3 & 5" 0)
   ("3 | 5" 7)
   ("3 ^ 5" 6)
   ("a = 3
  b = 5"
    ("a & b" 0)
    ("a | b" 7)
    ("a ^ b" 6)))
  
  (pyel-create-tests
   mod-op
   ("5 % 3" 2)
   ("a = 3
  b = 5"
    ("b % a" 2)))
#+END_SRC
** subscript,index,slice
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (defclass PySlice nil ;;TODO: name?
    ((start :initarg :start)
     (end :initarg :end)
     (step :initarg :step)))
  
  (def-transform index pyel ()
    (lambda (value &optional line col)
      (transform value)))
  
  (def-transform slice pyel ()
    (lambda (lower upper step)
      (PySlice "slice"
               :start (transform lower)
               :end (transform upper)
               :step (transform step))))
  
  (def-transform subscript pyel ()
    (lambda (value slice ctx &optional line col)
      (pyel-subscript value slice ctx line col)))
  
  (pyel-dispatch-func subscript-load-index (name value)
                      (list _) -> (nth value name)
                      (object _) -> (--getitem-- name value)
                      (vector _) -> (aref name value)
                      (string _) -> (char-to-string (aref name value))
                      (hash _) -> (gethash value name))
  
  (pyel-dispatch-func subscript-load-slice (name start end step)
                      (object _ _ _) -> (--getitem-- name (PySlice "slice"
                                                                   :start start
                                                                   :end  end
                                                                   :step  step))
                      ;;TODO implement step
                      (_ _ _ _) -> (subseq name start end))
  
  (pyel-dispatch-func subscript-store-slice (name start end step assign)
                      (object _ _ _) -> (--setitem-- name
                                                     (PySlice "slice"
                                                              :start start
                                                              :end  end
                                                              :step  step)
                                                     assign)
  
                      ;;TODO implement step
                      (_ _ _ _) -> (setf (subseq name start end) assign))
  
  (pyel-dispatch-func subscript-store-index (name value assign)
                      (list _) -> (setf (nth value name) assign)
                      (object _) -> (--setitem-- name value assign)
                      (vector _) -> (setf (aref name value) assign)
                      (hash _) -> (puthash value assign name))
  ;;                  (string _) -> not supported in python
  
  (defun pyel-subscript (value slice ctx &optional line col)
    (let* (;(value (transform value))
           (slice (transform slice))
           (ctx (cond ((context-p 'force-load) 'load)
                      ((context-p 'force-store) 'store)
                      (t (eval ctx))))
           start stop step)
  
      (when (object-p slice)
        (setq start (oref slice start)
              stop (oref slice end)
              step (oref slice step)))
      (if (eq ctx 'load)
          (if (object-p slice)
              (call-transform 'subscript-load-slice value start stop step) ;;load slice
            (call-transform 'subscript-load-index value slice)) ;;load index
        ;;else: store
        (if (object-p slice)
            (call-transform 'subscript-store-slice value start stop step assign-value)
          (call-transform 'subscript-store-index value slice assign-value)) ;;load index
  
        ;;      (test value start stop step assign-value)
        )))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Slice(lower, upper, step):
      step = step or "nil"
      lower = lower or 0
      upper = upper or "nil"
      return l_str(["slice", lower, upper, step])

  def Index(value, lineno='nil', col_offset='nil'):
      return "(index " + value + " " + str(lineno) + " " + str(col_offset) + ")"

  def Subscript(value, slice, ctx, lineno='nil', col_offset='nil'):
      return ll_str(["subscript", value, slice, ctx, lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
  subscript
   ;;load index====
   ;;string
   "a = '1X23'
  assert a[1] == 'X'"
   ;;list
   "a = [1,2,3,4]
  assert a[1] == 2"
   ;;vector
   "a = (1,2,3,4)
  assert a[1] == 2"
   ;;object
   "class a:
   def __getitem__ (self, value):
    return value + 4
  x = a()
  assert x[1] == 5"
   ;;=load slice====
   ;;vector
   "a = (1,2,3,4,5)
  assert a[1:4] == (2,3,4)
  assert a[:4] == (1,2,3,4)
  assert a[2:] == (3,4,5)
  assert a[:] == (1,2,3,4,5)"
   ;;list
   "a = [1,2,3,4,5]
  assert a[1:4] == [2,3,4]
  assert a[:4] == [1,2,3,4]
  assert a[2:] == [3,4,5]
  assert a[:] == [1,2,3,4,5]"
   ;;strings
   "a = '012345678'
  assert a[1:4] == '123'
  assert a[:4] == '0123'
  assert a[2:] == '2345678'
  assert a[:] == '012345678'"
   ;;object
   "class a:
   def __getitem__ (self, value):
    return value.start + value.end
  x = a()
  assert x[1:2] == 3
  assert x[5:7] == 12"

   ;;store index
   ;; list
   "def __add(a,b):
   return a+b
  a = [1,2,3,4]
  a[0] = __add(a[1],a[2])
  assert a[0] == 5
  a[2] = 'str'
  assert a[2] == 'str'"
   ;;vector
   "a = (1,2,3,4)
  a[0] = a[1] + a[2]
  assert aa[0] == 5
  a[2] = 'str'
  assert a[2] == 'str'"
   ;;object
   "class a:
   def __setitem__ (self, index, value):
    self.index = index
    self.value = value
  x = a()
  x[3] = 5
  assert x.index == 3
  assert x.value == 5"

   ;;store slice
   ;;list
   "a = [1,2,3,4,5,6]
  a[1:4] = [5,4,'f']
  assert a == [1,5,4,'f',5,6]
  a[:3] = ['a',4,2.2]
  assert a == ['a',4,2.2,'f',5,6]
  a[3:] = [3,3]
  assert a == ['a', 4, 2.2, 3, 3, 6]#TODO: should == ['a', 4, 2.2, 3, 3]"
   ;;vector
   "a = (1,2,3,4,5,6)
  a[1:4] = (5,4,'f')
  assert a == (1,5,4,'f',5,6)
  a[:3] = ('a',4,2.2)
  assert a == ('a',4,2.2,'f',5,6)
  a[3:] = (3,3)
  assert a == ('a', 4, 2.2, 3, 3, 6)#TODO: should == ('a', 4, 2.2, 3, 3)"
   ;;string
   "a = '123456'
  a[1:4] = '54f'
  assert a == '154f56'
  a[:3] = 'a42'
  assert a == 'a42f56'
  a[3:] = '33'
  assert a == 'a42336'#TODO: should == 'a4233'"
   ;;object
   "class a:
   def __setitem__ (self, index, value):
    self.start = index.start
    self.end = index.end
    self.step = index.step
    self.value = value
  x = a()
  x[2:3] = [1,2,3]
  assert x.start == 2
  assert x.end == 3
  assert x.value == [1,2,3]"

  "a[2] += 3"
  "a[2] += b[3]"

  "[2,3,3][2]"
  "assert [1,2,(3,2,8)][2][2] == 8"
   )
#+END_SRC

** class
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform classdef pyel ()
    (lambda (name bases keywords starargs kwargs
                  body decorator_list &optional line col)
      (pyel-defclass name bases keywords starargs kwargs
                     body decorator_list line col)))
  
  (defun pyel-defclass (name bases keywords starargs kwargs
                             body decorator_list &optional line col)
    (let ((class-def-methods nil) ;; list of methods that are part of this class
          (class-def-slots nil) ;;list of slots that are part of this class
          (class-def-name (transform name))
          (t-bases (mapcar 'transform bases)))
      ;;transform body with the class-def context, the transformed code
      ;;will store its methods and slots in class-def-methods and class-def-slots
      ;;respectively.
      (when (context-p 'function-def)
        (push name let-arglist)
        (push '__defined-in-function-body t-bases))
      (remove-context
       function-def
       (using-context class-def
                      (add-to-list 'pyel-defined-classes name)
                      `(define-class ,name ,t-bases
                         ,@(mapcar 'transform body)
                         )))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def ClassDef (name, bases, keywords, starargs, kwargs, body, decorator_list, lineno='nil', col_offset='nil'):
    return ll_str(["classdef",
                   name,
                   ll_str(bases),
                   ll_str(keywords),
                   starargs or "nil",
                   kwargs or "nil",
                   ll_str(body),
                   ll_str(decorator_list),
                   lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   objects
   ("class tclass():
   '''a test class'''
   cvar = 12
   def __init__(self, x):
    self.a = x + 10
   def get(self):
    return self.a
   def set(self,n):
    self.a = n
  x = tclass(4)"
    ("tclass.__name__" "tclass")
    ("tclass.get" (lambda (self) (getattr self a)))
    ("tclass.set" (lambda (self n) (setattr self a n)))
    ("tclass.cvar" 12)
    ("tclass.v = 'hi'" ("tclass.v" "hi"))
    ("tclass.set(tclass, 23)" ("tclass.a" 23))
    ("tclass.set(tclass, 19)" ("tclass.get(tclass)" 19))
    ("tclass.add5 = lambda self: self.cvar + 5" ("tclass.add5" (lambda (self) nil (pyel-+ (getattr self cvar) 5))))
    ("repr(x)" "<class 'object'>")
    ("x.__class__ == tclass" t)
    ("x.__class__.__name__" "tclass")
    ("x.a" 14)
    ("x.a = 2" ("x.a" 2))
    ("x.cvar = 4" (" x.cvar, tclass.cvar" [4 12]))
    ("x.set(10); y = x.get" ("y()" 10))
    ("tclass.sixmore = lambda self: self.a + 6
  y = x.sixmore
  x.a = 2"
     ("y()" 8)))

   ("class one:
   def __init__(self,x):
    self.n = x
   def m(self):
    return self.n + 1
  class two:
   def __init__(self):
    self.other = one(5)
  x = two()"
    ("x.other.n" 5)
    ("x.other.m()" 6)))

  (pyel-create-tests
   special-method-lookup
   ( "class adder:
   def __init__(self, n):
    self.x = n
   def __call__ (self, n):
    return self.x + n
  c = adder(10)
  d = adder(10)
  d.__call__ = lambda : 'hi'"
     ("c(6)" 16)
     ("repr(c.__call__)"
      "<bound method adder.__call__ of adder object at 0x18b071>")
     ("d.__call__" (lambda nil nil "hi"))))
#+END_SRC
** assert
*** transform
;;TODO: have custom option for t/nil value of assert's 2nd parameter

;;TODO: fix this case:
  (pyel "assert (True,1), 'message'")
   -> (assert (vector True 1) t "message")
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform assert pyel ()
    (lambda (test msg &optional line col)
      (pyel-assert test msg line col)))
  
  (defun pyel-assert (test msg &optional line col)
    `(assert ,(transform test) t ,(transform msg)))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Assert(test, msg, lineno='nil', col_offset='nil'):
      return ll_str(["assert ", test , msg or "nil", lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests assert
                     "assert sldk()"
                     "assert adk,'messsage'")
#+END_SRC
** for loop
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform for pyel ()
    (lambda (target iter body orelse &optional line col)
      (pyel-for target iter body orelse line col)))
  
  ;;TODO: for a,y in thing: ...
  ;;TODO: check if iter is an object, then do the iterator thing
  
  (defun pyel-for (target iter body orelse &optional line col)
    (let ((target (using-context for-loop-target
                                 (if (eq (car target) 'tuple)
                                     (mapcar 'transform (cadr target))
                                   (list (transform target)))))
          (body (using-context for (mapcar 'transform body)))
          (else (mapcar 'transform orelse))) ;;break/continue for else?
      (when else
        (setq body (append body (cons 'else else))))
  
      `(py-for ,@target in ,(transform iter) ,@body)))
  
  ;; (if (eq (car target) 'tuple)
  ;;     "TODO: var unpacking"
  ;;   ;;create a temp target variable
  ;;   ;;in body, unpack that into the provided target variables
  
  ;;   (let* ((continue-for nil)
  ;;          (break-for nil)
  ;;          (code (using-context for (mapcar 'transform body)))
  ;;          (break-code (if break-for '(catch '__break__)
  ;;                        pyel-nothing))
  ;;          (continue-code (if continue-for '(catch '__continue__)
  ;;                           pyel-nothing)))
  ;;     (setq _x break-for)
  ;;     `(,@break-code
  ;;       (loop for ,(using-context for-loop-target
  ;;                                 (transform target))
  ;;             in (py-list ,(transform iter))
  ;;             do (,@continue-code
  ;;                 ,@(mapcar 'transform body)))
  ;;       ,@(mapcar 'transform orelse)))))
  
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def For(target, iter, body, orelse, lineno='nil', col_offset='nil'):
      return l_str(["for ", target, iter, ll_str(body), ll_str(orelse), lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (setq pyel-for-loop-code-fns '((cons . pyel-for-loop-list-code)
                                 (vector . pyel-for-loop-vector-code)
                                 (string . pyel-for-loop-string-code)
                                 (object . pyel-for-loop-object-code)))
  
  (defsubst pyel-type-of (obj)
    (if (py-object-p obj)
        'object
      (type-of obj)))
  
  (defmacro py-for (&rest args)
    "(for <targets> in <iter> <body> else <body>)
  else is optional"
    
    ;;TODO: error checking for correct form
    (let* ((targets (pyel-split-list args 'in))
           (args (cdr targets))
           (targets (car targets))
           (iter (pop args)) ;;TODO: must iter be only one form?
           
           (body (pyel-split-list args 'else))
           (else-body (cdr body))
           (body (car body))
           
           (target (cond ((symbolp targets) ;;nil when there are multiple targets
                          targets)
                         ((= (length targets) 1)
                          (car targets))
                         (t nil)))
           
           (unpack-code (unless target
                          (let (ret)
                            (dotimes (i (length targets) (reverse ret))
                              (push `(setq ,(nth i targets)
                                           (nth ,i __target__))
                                    ret)))))
           (unpack-code (cons '(setq __target__ (nth __idx __tmp-list)) unpack-code))
           
           (current-transform-table (get-transform-table 'for-macro))
           __for-continue ;;these are set by the for-macro transforms
           __for-break
           )
      ;;TODO: when multiple targets, check that all lists are the same size
      (setq body (mapcar 'transform body))
      
      ;;TODO: expand to simpler cases when types are known
      
      `(let* ((__iter ,iter)
              (func (cdr (assoc (setq _t (pyel-type-of __iter)) pyel-for-loop-code-fns))))
         (if (null func)
             (error "invalid type")
           (eval (funcall func ',targets __iter ',body ',else-body
                          ,__for-break ,__for-continue) :lexical)))))
  
  
  (defun pyel-for-loop-list-code (targets iter body else-body
                                          &optional break continue)
    (let* ((loop-body `(,@(if (= (length targets) 1)
                              `((setq ,(car targets) (nth __idx __tmp-lst)))
                            ;;unpack-code
                            (cons '(setq __target__ (nth __idx __tmp-lst))
                                  (let (ret)
                                    (dotimes (i (length targets) (reverse ret))
                                      (push `(setq ,(nth i targets)
                                                   (pyel-nth ,i __target__))
                                            ret)))))
                        (setq __idx (1+ __idx))
                        
                        ,@body))
           (loop-body (if continue
                          `((catch '__continue__ ,@loop-body))
                        loop-body))
           
           (while-loop `(while (< __idx __len)
                          ,@loop-body))
           
           (while-loop (if break
                           `(catch '__break__ ,while-loop)
                         while-loop)))
      
      `(let* ((__tmp-lst ',iter)
              ;;      ,@iter-lets
              ;;      ,@next-function-lets
              (__len (length __tmp-lst))
              (__idx 0))
         ,while-loop
         ,@else-body)))
  
  
  (defun pyel-for-loop-string-code (target iter body else-body
                                           &optional break continue)
    (let* ((loop-body `(,@(if (= (length target) 1)
                              `((setq ,(car target)
                                      (pyel-string-nth __tmp-str __idx)))
                            (error "ValueError: need more than 1 value to unpack"))
                        (setq __idx (1+ __idx))
                        ,@body))
           (loop-body (if continue
                          `((catch '__continue__ ,@loop-body))
                        loop-body))
           
           (while-loop `(while (< __idx __len)
                          ,@loop-body))
           
           (while-loop (if break
                           `(catch '__break__ ,while-loop)
                         while-loop)))
      
      `(let* ((__tmp-str ',iter)
              (__len (length __tmp-str))
              (__idx 0))
         ,while-loop
         ,@else-body)))
  
  ;;yes, I'm aware how repetitive it's getting
  
  (defun pyel-for-loop-vector-code (targets iter body else-body
                                            &optional break continue)
    (let* ((loop-body `(,@(if (= (length targets) 1)
                              `((setq ,(car targets) (aref __tmp-lst __idx )))
                            ;;unpack-code
                            (cons '(setq __target__ (aref __tmp-lst __idx))
                                  (let (ret)
                                    (dotimes (i (length targets) (reverse ret))
                                      (push `(setq ,(nth i targets)
                                                   (pyel-nth ,i __target__))
                                            ret)))))
                        (setq __idx (1+ __idx))
  
                        ,@body))
           (loop-body (if continue
                          `((catch '__continue__ ,@loop-body))
                        loop-body))
  
           (while-loop `(while (< __idx __len)
                          ,@loop-body))
  
           (while-loop (if break
                           `(catch '__break__ ,while-loop)
                         while-loop)))
  
      `(let* ((__tmp-lst ',iter)
              ;;      ,@iter-lets
              ;;      ,@next-function-lets
              (__len (length __tmp-lst))
              (__idx 0))
         ,while-loop
         ,@else-body)))
  
  
  (defun pyel-for-loop-object-code (targets object body else-body
                                            &optional break continue)
    (let* ((loop-body `(,@(if (= (length targets) 1)
                              `((setq ,(car targets) (call-method __iter__ --next--)))
                            ;;unpack-code
                            (cons '(setq __target__ (call-method __iter__ --next--))
                                  (let (ret)
                                    (dotimes (i (length targets) (reverse ret))
                                      (push `(setq ,(nth i targets)
                                                   (pyel-nth ,i __target__))
                                            ret)))))
                        ,@body))
           (loop-body (if continue
                          `((catch '__continue__ ,@loop-body))
                        loop-body))
  
           (while-loop `(condition-case nil
                            (while t
                              ,@loop-body)
                          (StopIteration nil)))
  
           (while-loop (if break
                           `(catch '__break__ ,while-loop)
                         while-loop)))
  
      ;;variable __iter is set by calling function
      `(let* (;;(__iter ,object)
              (__iter__ (condition-case nil
                            (call-method __iter --iter--)
                          (AttributeError
                           (py-raise (TypeError (format
                                                 "'%s' object is not iterable"
                                                 (getattr __iter --name--))))))))
         ,while-loop
         ,@else-body)))
  
  
  
  (make-transform-table 'for-macro)
  
  (def-transform break for-macro ()
    (lambda () (setq __for-break t)
      '(throw '__break__ nil)))
  
  (def-transform continue for-macro ()
    (lambda () (setq __for-continue t)
      '(throw '__continue__ nil)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   for-loop
  
   ("x = []
  for a in range(5):
   x.append(a)"
    ("x" '(0 1 2 3 4)))
  
   ;;lists
   ("x = []
  for a,b in [[1,2],'34',(5,6)]:
   x.append([a,b])"
    ("x" '((1 2) ("3" "4") (5 6))))
  
   ("x = []
  for a,b,c,d in [[1,2,1,1],'34xa',(5,6,'a',1)]:
   x.append([a,b,c,d,a])"
    ("x" '((1 2 1 1 1) ("3" "4" "x" "a" "3") (5 6 "a" 1 5)))) 
  
   ("n = 0
  for a in range(5):
   for b in range(5):
    n = n + a + b"
    ("n" 100))
   
   ("x = []
  for a in range(100):
   if (a % 2 == 0):
    continue
   if a > 10:
    break
   x.append(a)"
    ("x" '(1 3 5 7 9)))
  
   ;;vectors
   ("x = []
  for a in (1,2,3,4):
   x.append(2*a)"
    ("x" '(2 4 6 8)))
  
   ("x = []
  for a,b in ([1,2],'34',(5,6)):
   x.append([a,b])"
    ("x" '((1 2) ("3" "4") (5 6))))
   ("tup = make_vector(20,0)
  for i in range(10):
   tup[i] = i
  x = []
  tup = make_vector(20,0)
  for i in range(20):
   tup[i] = i;
  for a in tup:
   if (a % 2 == 0):
    continue
   if a > 10:
    break
   x.append(a)"
    ("x" '(1 3 5 7 9)))
  
   ("x = []
  for a in 'string':
   x.append(a)"
    ("x" '("s" "t" "r" "i" "n" "g")))
  
   ;;strings
   ("x = []
  c = 0
  def getstr():
   global c
   c+=1
   return 'qwerty'
  for a in getstr():
   x.append(a)"
    ("x" '("q" "w" "e" "r" "t" "y"))
    ("c" 1))
  
   ;;objects
   ("class a:
   x = 5
   def __iter__(self):
    return self
   def __next__(self):
    if self.x > 0:
     ret = str(self.x)
     self.x -= 1
     return ret
    raise StopIteration
  obj = a()
  x = []
  for n in obj:
   x.append(n)"
    ("x" '("5" "4" "3" "2" "1"))))
  
#+END_SRC
** global
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform global pyel ()
    (lambda (names &optional line col)
      (if (context-p 'function-def)
          (progn (mapc (lambda (x) (add-to-list 'global-vars (_to- x))) names)
                 pyel-nothing)
        (pyel-not-implemented "'global' calls outside of function definitions"))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Global(names, lineno='nil', col_offset='nil'):
    return l_str(['global', l_str(names), lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests global

                     "def a():
   global x
   x = 3
   y = 1"

                     "x = 1
  y = 1
  def func():
   global x
   x = 7
   y = 7
  func()
  assert x == 7
  assert y == 1
  "
                     )
#+END_SRC
** nonlocal
DOC: 'nonlocal' is currently equivalent to 'global'
     It seems to be working fine...
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el

 #+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Nonlocal(names, lineno='nil', col_offset='nil'):
    return l_str(['global', l_str(names), lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** lambda
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform lambda pyel ()
    (lambda (args body &optional line col)
      (using-context lambda-def
                     (pyel-def "dkl" args body nil nil line col))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Lambda(args, body, lineno='nil', col_offset='nil'):
      return ll_str(["lambda", ll_str(args),'('+ll_str(body)+')', lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   lambda
   ("f = lambda x,y: x+y
  f2 = lambda x,*rest: [x,rest]
  f3 = lambda x, *rest, **k : [x, rest, k]"
    ("f(1,2.3)" 3.3)
    ("f2(1,2,3,4,'asd')" '(1 (2 3 4 "asd")))
    ("repr(f3(1,2,3,4,5,a__=1,b__=2))"
     "[1, [2, 3, 4, 5], {b--: 2, a--: 1}]"))
   ("reduce(lambda a,b:a+b, range(2, 9))" 35))
  
#+END_SRC
** unary op, not, usub
TODO: tests!
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform unary-op pyel ()
    (lambda (op operand &optional line col)
      (call-transform op operand)))
  
  (pyel-dispatch-func not (x)
                      (object) -> (--not-- x) ;;?
                      (_) -> (not x))
  
  (pyel-dispatch-func usub (x)
                      (number) -> (- x)
                      (object) -> (--usub-- x) ;;?
                      )
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def UnaryOp(op, operand, lineno='nil', col_offset='nil'):
      return l_str(["unary-op ", op, operand, lineno, col_offset])

  def Not():
      return "not"

  def USub():
      return "usub"
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** augmented assignment
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform aug-assign pyel (target op value)
    (lambda (target op value &optional line col)
      (call-transform 'assign
                      `(,target)
                      (call-transform  op
                                       ;;TODO: what if this is something else
                                       ;;other then a simple name?
                                       ;;=> ok as long as nothing acknowledges
                                       ;;   the  force-load context
                                       (using-context force-load
                                                      (transform target))
                                       value))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def AugAssign(target, op, value, lineno='nil', col_offset='nil'):
      return l_str(['aug-assign', target, op, value, lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   aug-assign
   ("x = 2"
    ("x += 3" ("x" 5))
    ("x *= 3" ("x" 6))
    ("x -= 1" ("x" 1))
    ("x /= 4" ("x" 0.5)))
  
   ("x = [2]"
    ("x[0] += 3" ("x[0]" 5))
    ("x[0] *= 3" ("x[0]" 6))
    ("x[0] -= 1" ("x[0]" 1))
    ("x[0] /= 4" ("x[0]" 0.5)))
  
   ("class a:
   x = 2"
    ("a.x += 3" ("a.x" 5))
    ("a.x *= 3" ("a.x" 6))
    ("a.x -= 1" ("a.x" 1))
    ("a.x /= 4" ("a.x" 0.5)))
   )  
#+END_SRC
** return
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform return pyel ()
    (lambda (value &optional line col)
  
      (if (context-p 'tail-context)
          (transform value)
        (setq return-middle t)
        `(throw '__return__ ,(transform value)))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Return(value, lineno='nil', col_offset='nil'):
      return "(return " + str(value) + " " + str(lineno) + " " + str(col_offset)+ ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** break and continue
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform break pyel ()
    (lambda (&optional line col)
      ;;TODO verify that it is ok to just use one inter-template var for this
      (context-switch
       (while (setq break-while t)
         '(throw '__break__ nil))
       (for (setq break-for t)
            '(break)))))
  
  (def-transform continue pyel ()
    (lambda (&optional line col)
      ;;TODO verify that it is ok to just use one inter-template var for this
      (context-switch
       (while (setq continue-while t)
         '(throw '__continue__ nil))
       (for (setq continue-for t)
            '(continue)))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Break(lineno=None, col_offset=None):
      return l_str(["break", lineno, col_offset])

  def Continue(lineno=None, col_offset=None):
      return l_str(["continue", lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   break
   ("x = 0
  while x < 10:
   x = x + 1
   if x == 3:
    break"
    ("x" 3))
  
   ("x = [0]
  c = 0
  while c < 3:
   c = c + 1
   y = 0
   while y < 10:
    y = y + 1
    x.append(y)
    if y == 3:
     x.append('b')
     break"
    ("x" '(0 1 2 3 "b" 1 2 3 "b" 1 2 3 "b"))))
  
  (pyel-create-tests 
   continue
   ("l = [0]
  y = 8;
  while y > 0:
   y = y -1
   if y % 2 == 0:
    continue
   l.append(y)"
    ("l"  '(0 7 5 3 1)))
  
   ("x = [0]
  c = 0
  while c < 3:
   c = c + 1
   y = 0
   while y < 5:
    y = y + 1
    if y % 2 == 0:
     x.append('c')
     continue
    x.append(y)"
    ("x" '(0 1 "c" 3 "c" 5 1 "c" 3 "c" 5 1 "c" 3 "c" 5))))
#+END_SRC
** exception handler
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform except-handler pyel (type name body)
    ;;TODO: name?
    (lambda (type name body &optional line col)
      `(,(or (transform type) 'error)
        ,@(mapcar 'transform body))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def ExceptHandler(type, name, body, lineno='nil', col_offset='nil'):
      return l_str(["except-handler", type or 'nil', name or 'nil', l_str(body), lineno, col_offset])
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** try except
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform try pyel (body handlers orelse)
    ;;TODO: orelse
    (lambda (body handlers orelse &optional line col)
      (let ((body (mapcar 'transform body)))
        (if (> (length body) 1)
            (setq body (cons 'progn body))
          (setq body (car body)))
        `(condition-case nil
             ,body
             ,@(mapcar 'transform handlers)))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def TryExcept(body, handlers, orelse, lineno='nil', col_offset='nil'):
      return l_str(["try", l_str(body), l_str(handlers), l_str(orelse), lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   try
   ("a = ''
  try:
   1 / 0
   a = 'yes'
  except:
   a = 'no'
  
  b = ''
  try:
   b = 'a'
   [1,3][23]
  except:
   try:
    1/0
   except:
    b = 'ok'
  
  c = ''
  try:
   c = 'y'
  except:
   c = 'n'
  
  try:
   raise IndexError
   d = 2
  except IndexError:
   d = 2233
  except:
   d = 'no'
  
  "
    ("a" "no")
    ("b" "ok")
    ("c" "y")
    ("d" 2233)))
#+END_SRC
** in, not in
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;;a not in b
  ;; function:    is_not(a, b)  (in the operator module)
  (pyel-dispatch-func not-in (l r)
                      (_ list) -> (not (py-list-member l r))
                      (_ string) -> (not (py-string-member l r))
                      (_ object) -> (not (py-object-member l r))
                      (_ vector) -> (not (py-vector-member l r)))
  
  ;;a in b
  ;; function:    is_(a, b)
  (pyel-dispatch-func in (l r)
                      (_ list) -> (py-list-member l r)
                      (_ string) -> (py-string-member l r)
                      (_ object) -> (py-object-member l r)
                      (_ vector) -> (py-vector-member l r))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-vector-member (elt vector)
    "Return non-nil if ELT is an element of VECTOR. Comparison done with `equal'."
    (let ((i 0)
          (len (length vector))
          found)
      (while (and (not found)
                  (< i len))
        (if (equal (elt vector i) elt)
            (setq found t)
          (setq i (1+ i))))
      found))
  
  (defsubst py-list-member (elt list)
    (if (member elt list) t nil))
  
  (defun py-string-member (s string)
    "Return non-nil if S is a substring of STRING"
    (and (stringp s) (if (string-match (regexp-quote s) string) t nil)))
  
  (defun py-object-member (elt obj)
    ;;https://docs.python.org/3/reference/expressions.html#membership-test-details
    (if (py-object-p obj)
        (if (obj-hasattr obj --contains--)
            (call-method obj --contains-- elt)
  
          ;;else: try iteration via __iter__
          (let ((iter (condition-case nil
                          (call-method obj --iter--)
                        (AttributeError nil)))
                (not-found t)
                (i -1) val)
            (if iter
                (condition-case nil
                    (while not-found
                      (setq val (call-method iter --next--))
                      (if (or (eq val elt) (equal val elt))
                          (setq not-found nil)))
                  (StopIteration nil))
              ;;else: try old-style iteration protocol if __getitem__ is defined
              (if (obj-hasattr obj --getitem--)
                  (condition-case nil
                      (while not-found
                        (setq val (call-method obj --getitem-- (setq i (1+ i))))
                        (if (or (eq val elt) (equal val elt))
                            (setq not-found nil))
  
                        )
                    (IndexError nil))
                ;;else: not iterable
                (py-raise (TypeError
                           (format "argument of type '%s' is not iterable" (py-type obj))))))
            (not not-found)))
      ;;else: not an object
      (error (format "py-object-member: invalid type for OBJ parameter (%s)"
                     (type-of obj)))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   in
   ;;lists
   ("3 in range(3)" t)
   ("'s' in range(3)" nil)
   ("'s' in [1,2,'s',3]" t)
   ;;vectors
   ("1 in [3,1,2]" t)
   ("'s' in (4,2,'s','x')" t)
   ("'s' in (4,2,'ss','x')" nil)
   ("[1,2,3][1] in [1,3,[3,2,1]][2]" t)
   ;;strings
   ("'s' in 'string'" t)
   ("'q' in 'string'" nil)
   ("'tri' in 'string'" t)
   ;;objects
   ;;with __contains__
   ("class tst():
   x = [1,2,3,4]
   def __contains__(self,e):
    return e in self.x
  x = tst()"
    ("3 in x" t)
    ("3 not in x" nil)
    ("2 in [x][0]" t))
   ;;with __iter__
   ("class tst2:
   x = [1,2,3,4]
   def __iter__(self):
    self.i = 0
    self.max = len(self.x)
    return self
   def __next__(self):
    i = self.i
    __i = i
    __m = self.max
    if i < self.max:
      ret = self.x[i]
      self.i = i+1
      return ret
    else:
     raise StopIteration
  o = tst2()"
    ("3 in o" t)
    ("33 not in o" t)
    ("3 not in o" nil)
    ("33 in o" nil))
   ;;with __getitem__
   ("class tst3:
   x = [5,6,7,8]
   def __getitem__(self, index):
    if type(index) == int and index >= 0 and index < len(self.x):
     return self.x[index];
    else:
     raise IndexError
  o = tst3()
  x = []
  for i in range(10):
   if i in o:
    x.append(i)"
    ("3 in o" nil)
    ("7 in o" t)
    ("7 not in o" nil)
    ("12 not in o" t)
    ("x" '(5 6 7 8)))
   )
  
  (pyel-create-tests
   not-in
   ;;lists
   ("3 not in range(3)" nil)
   ("'s' not in range(3)" t)
   ("'s' not in [1,2,'s',3]" nil)
   ;;vectors
   ("1 not in [3,1,2]" nil)
   ("'s' not in (4,2,'s','x')" nil)
   ("'s' not in (4,2,'ss','x')" t)
   ("[1,2,3][1] in [1,3,[3,2,1]][2]" nil)
   ;;strings
   ("'s' not in 'string'" nil)
   ("'q' not in 'string'" t)
   ("'tri' not in 'string'" nil)
   ;;objects tests are part of the 'in' tests
   )
  
#+END_SRC
** comprehensions
DOC: generator expressions are translated to list comprehensions
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform comprehension pyel (target iter ifs)
    (lambda (target iter ifs) (pyel-comprehension target iter ifs)))
  
  (defun pyel-comprehension (target iter ifs)
    ;;this uses the inter-transform var 'comprehension-body'
    (assert (boundp 'comprehension-body)
            "`comprehension-body' must be defined for this transform")
    ;;TODO: ifs
    `(loop for ,(using-context for-loop-target
                               (transform target))
           in (py-list ,(transform iter))
           ,(if ifs
                (list '@ 'if
                         (cons (if (> (length ifs) 1)
                                   'and
                                 '@)
                               (mapcar 'transform ifs)))
              pyel-nothing)
           do ,comprehension-body))
  
  (def-transform list-comp pyel (elt generators)
    (lambda (elt generators &optional line col)
      (pyel-list-comp elt generators line col)))
  
  (defun pyel-list-comp (elt generators &optional line col)
    (let* ((list-var '__list__)
           (comprehension-body `(setq ,list-var (cons ,(transform elt) ,list-var)))
           (i (length generators))
           code)
      ;;`comprehension-body' is an inter-transform var
      (while (> i 0)
        (setq i (1- i))
        ;;'comprehension-body' holds the inner code, and each transform
        ;; is the inner code for the preceding generator in 'generators'
        ;; (loop ... collect ...) produces a list, so no additional work is needed
        (setq comprehension-body (transform (nth i generators))))
  
      `(let ((,list-var nil))
         ,comprehension-body
         (reverse ,list-var))))
  
  (def-transform dict-comp pyel (key value generators)
    (lambda (key value generators &optional line col)
      (pyel-dict-comp key value generators line col)))
  
  (defun pyel-dict-comp (key value generators &optional line col)
    (let* ((hash-var '__dict__)
           (comprehension-body (list 'puthash (transform key)
                                     (transform value)
                                     hash-var))
           (i (length generators))
           code)
      (while (> i 0)
        (setq i (1- i))
        (setq comprehension-body (transform (nth i generators))))
  
      `(let ((,hash-var (make-hash-table :test 'equal)))
         ,comprehension-body
         ,hash-var)))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def comprehension(target, iter, ifs):
      return l_str(["comprehension", target, iter, l_str(ifs)])

  def GeneratorExp(elt, generators, lineno='nil', col_offset='nil'):
      return l_str(["list-comp", elt, l_str(generators), lineno, col_offset])

  def ListComp(elt, generators, lineno='nil', col_offset='nil'):
      return l_str(["list-comp", elt, l_str(generators), lineno, col_offset])

  def DictComp(key, value, generators, lineno='nil', col_offset='nil'):
      return l_str(["dict-comp", key, value, l_str(generators), lineno, col_offset])

  def SetComp(elt, generators, lineno='nil', col_offset='nil'):
      return "(unimplemented \"set comprehension\")"
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   list-comprehensions
   ("[x*x for x in range(10)]" '(0 1 4 9 16 25 36 49 64 81))
   ("[x*x for x in range(10) if x > 5]" '(36 49 64 81))
   ("[x*x for x in range(10) if x > 5 if x < 8]" '(36 49))
  
   ("[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]" '([1 3] [1 4] [2 3] [2 1] [2 4] [3 1] [3 4]))
  
   ("matrix = [[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],]
  transposed = []
  for i in range(4):
   transposed.append([row[i] for row in matrix])"
    
    ("[[row[i] for row in matrix] for i in range(4)]"
     '((1 5 9) (2 6 10) (3 7 11) (4 8 12)))
    ("transposed" '((1 5 9) (2 6 10) (3 7 11) (4 8 12)))))

  
  (pyel-create-tests
   dict-comprehensions
   ("str({x:x*x for x in range(5)})" "{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}")
   ("x = {x: [y*y for y in range(x)] for x in range(20)}"
    ("hash_table_count(x)" 20)
    ("x[3],x[5],x[10]" [(0 1 4) (0 1 4 9 16) (0 1 4 9 16 25 36 49 64 81)])))
#+END_SRC

** boolop, and, or
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform boolop pyel (op values)
    (lambda (op values &optional line col)
      (cons op (mapcar 'transform values))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def BoolOp(op, values, lineno='nil', col_offset='nil'):
      return l_str(["boolop", op, l_str(values), lineno, col_offset])
  def Or():
      return "or"
  def And():
      return "and"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests boolop
                     "a or b"
                     "a or b or c"
                     "a.c or b.c() or a[2]"
                     "a and b"
                     "a and b or c"
                     "a[2] and b.f() or c.e"
                     "a.e and b[2] or c.e() and 2 ")
#+END_SRC
** pass
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform pass pyel ()
    (lambda (&optional line col) nil))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Pass(lineno=None, col_offset=None):
      return l_str(["pass", lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** unimplemented
This will help notify the user when some syntax has not been implemented
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform unimplemented pyel (name)
    (lambda (name)
      (pyel-notify-error "Set comprehensions have not been implemented")
      pyel-error-string))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** conditional expressions
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform if-exp pyel ()
    (lambda (test body orelse &optional line col)
      (let ((tst (transform test)))
        `(if ,(if (equal tst []) nil tst)
             ,(transform body)
           ,(transform orelse)))))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def IfExp (test, body, orelse, lineno='nil', col_offset='nil'):
      return l_str(["if-exp", test, body, orelse, lineno, col_offset])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests conditional-expressions
                     "1 if True else 0"
                     "true() if tst() else false()"
                     "a[1] if a[2:2] else a[2]"
                     )
#+END_SRC
** raise
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform raise pyel ()
    (lambda (exc cause &optional line col)
      `(py-raise ,(transform exc)))) ;;TODO: ignoring cause
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Raise(exc, cause, lineno='nil', col_offset='nil'):
      return l_str(["raise", exc, cause or "nil", lineno, col_offset])
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-raise (exc &optional cause)
    "signal an error with the name of EXC, an class/object
  EXC must be derived from BaseException"
    (if (py-object-p exc)
           ;;;;TODO: after `issubclass' is implemented
        ;; (or (and (py-class-p exc)
        ;;          (issubclass exc BaseException))
        ;;     (and (py-instance-p exc)
        ;;          (issubclass (py-type exc) BaseException)))
        (signal (intern (getattr exc --name--)) exc)
      (signal 'TypeError "TypeError: exceptions must derive from BaseException")))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* function transforms
** simple name changes
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-translate-function-name 'map 'mapcar)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** len
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform len (thing)
                       (hash)   -> (hash-table-count thing)
                       (object) -> (call-method thing --len--)
                       (_)      -> (length thing))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   len-function
   ("a = [1,2,3,'5']
  b = []
  c = 'str'
  d = (1,2,3,4)"
    ("len(a)" 4)
    ("len(b)" 0)
    ("len(c)" 3)
    ("len(d)" 4))
   ("len('')" 0)
   ("len([3,4])" 2)
   ("len({1:'one', 2:'two'})" 2)
   )
#+END_SRC
** range
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (push '(range py-range) pyel-function-name-translations)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-range (start &optional end step)
   (unless end
    (setq end start
     start 0))
   (number-sequence start (1- end) step))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   range-function
   ("range(5)" '(0 1 2 3 4))
   ("range(2,7)" '(2 3 4 5 6))
   ("range(2,20,3)" '(2 5 8 11 14 17)))
#+END_SRC
** input
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'input 'read-string)
#+END_SRC
** list
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (defalias 'py-list 'pyel-list-function)
  (pyel-func-transform list (object)
                       (string) -> (py-string-to-list object)
                       (object) -> (py-object-to-list object)
                       (vector) -> (py-vector-to-list object)
                       (hash)   -> (py-hash-to-list object)
                       (list)   -> (py-copy-list object))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defsubst py-string-to-list (string)
    (mapcar 'byte-to-string string))
  
  (defsubst py-vector-to-list (vector)
    (mapcar 'identity vector))
  
  (defsubst py-copy-list (list)
    (copy-list list))
  
  (defun py-object-to-list (object)
    "assumes that py-object(OBJECT) == t"
    (let ((iter (condition-case nil
                    (call-method object --iter--)
                  (AttributeError
                   (py-raise (TypeError (format
                                         "'%s' object is not iterable"
                                         (getattr object --name--)))))))
          list)
      (condition-case nil
          (while t
            (setq list (cons (call-method iter --next--) list)))
        (StopIteration (reverse list)))))
  
  (defun py-hash-to-list (hash)
    (let (keys)
      (maphash (lambda (key value)
                 (setq keys (cons key keys))) hash)
      keys))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   list-function
   ("list('string')" '("s" "t" "r" "i" "n" "g"))
   ("list([1,2,'3',(2,)])" '(1 2 "3" [2]))
   ("a = [1]
  b = [a,1]
  c = list(b)"
    ("c is b" nil)
    ("c == b" t)
    ("c[0] is a" t))
  
   ("a = [1]
  b = (a, 1)
  c = list(b)"
    ("c" '((1) 1))
    ("c[0] is a" t))
  
   ("list({1:'one', 2:'two', 3:'three'})" '(3 2 1))
  
   ("list((1,2,3))" '(1 2 3))
   
   ("s = '123'
  l = [1,2,3]
  tu = (1,2,3,)
  d = {1:'1',2:'2',3:'3'}"
    ("list(s)" '("1" "2" "3"))
    ("list(l)" '(1 2 3))
    ("list(tu)" '(1 2 3))
    ("list(d)" '(3 2 1)))
   
   ("class a:
   x = 5
   def __iter__(self):
    return self
   def __next__(self):
    if self.x > 0:
     ret = str(self.x)
     self.x -= 1
     return ret
    raise StopIteration
  obj = a()"
    ("list(obj)" '("5" "4" "3" "2" "1"))))
#+END_SRC
** tuple
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform tuple (object)
                       (string) -> (py-string-to-vector object)
                       (list)   -> (py-list-to-vector object)
                       (vector) -> (py-copy-vector object)
                       (hash)   -> (py-hash-to-vector object)
                       (object) -> (py-object-to-vector object))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;; (defun py-string-to-vector (string)
  ;;   "Return a vector of characters in STRING."
  ;;   (vconcat (mapcar 'byte-to-string string)))
  (defun py-string-to-vector (string)
    "Return a vector of characters in STRING."
    (let* ((v (make-vector (length string) 0))
           (i -1))
      (mapc (lambda (x)
              (aset v (setq i (1+ i)) (byte-to-string x)))
            string)))
  
  (defsubst py-list-to-vector (list)
    "return a vector v such that (aref v i) = (nth i LIST)"
    (vconcat list))
  
  (defsubst py-copy-vector (vec)
    (vconcat vec))
  
  (defun py-hash-to-vector (ht)
    (let ((v (make-vector (hash-table-count ht) 0))
          (i -1))
      (maphash (lambda (key value)
                 (aset v (setq i (1+ i)) key))
               ht)
      v))
  
  (defsubst py-object-to-vector (object)
    (vconcat (py-object-to-list (object))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   tuple-function
   ("tuple('string')" ["s" "t" "r" "i" "n" "g"])
   ("tuple([1,2,'3',(2,)])" [1 2 "3" [2]])
   ("a = [1]
  b = [a,1]
  c = list(b)"
    ("c is b" nil)
    ("c == b" nil)
    ("c[0] is a" t))
   
   ("a = [1]
  b = (a, 1)
  c = tuple(b)"
    ("c" '((1) 1))
    ("c[0] is a" t))
  
   ("a = (1,)
  b = [a, 1]
  c = tuple(b)"
    ("c" '[[1] 1])
    ("c[0] is a" t))
   
   ("tuple({1:'one', 2:'two', 3:'three'})" '[3 2 1])
   
   ("tuple((1,2,3))" [1 2 3])
   
   ("s = '123'
  l = [1,2,3]
  tu = (1,2,3,)
  d = {1:'1',2:'2',3:'3'}"
    ("tuple(s)" ["1" "2" "3"])
    ("tuple(l)" [1 2 3])
    ("tuple(tu)" [1 2 3])
    ("tuple(d)" [3 2 1]))
   
   ("class a:
   x = 5
   def __iter__(self):
    return self
   def __next__(self):
    if self.x > 0:
     ret = str(self.x)
     self.x -= 1
     return ret
    raise StopIteration
  obj = a()"
    ("list(obj)" '["5" "4" "3" "2" "1"])))
#+END_SRC
** hasattr
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'hasattr 'obj-hasattr)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** isinstance
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'isinstance 'obj-isinstance)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
** str
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform str (thing)
                       (number) -> (number-to-string thing)
                       (string) -> (format "\"%s\"" thing)
                       (function) -> (py-function-str thing)
                       (list) -> (py-list-str thing)
                       (object) -> (call-method thing --str--)
                       (vector) -> (py-vector-str thing)
                       (hash) -> (py-hash-str thing)
                       (symbol) -> (symbol-name thing))

  (pyel-translate-function-name 'str 'pyel-str)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun _py-str-sequence (seq)
    "convert SEQ to a string of its python representation
      does not include starting/ending parens or brackets"
    (if (vectorp seq)
        (setq seq (mapcar 'identity seq)))
    (if (listp seq)
        (if (listp (cdr seq))
            (mapconcat (lambda (x) (pyel-str-function x)) seq ", ")
          ;;cons cell
          ;;this should not happend from normal python
          ;;but maybe when interacting with lisp code from python
          (concat (pyel-str-function (car seq))
                  " . "
                  (pyel-str-function (cdr seq))))
      (error "invalid type")))
  
  (defun py-list-str (thing)
    (concat "[" (_py-str-sequence thing) "]"))
  (defun py-vector-str (thing)
    (concat "(" (_py-str-sequence thing) ")"))
  
  (defun py-function-str (func)
    "return a string representation of function FUNC"
    (let* ((obj (bound-method-p func))
           (obj-name (if obj (-to_ (getattr obj --name--)) nil)))
      (if obj
          (format "<bound method %s.%s of %s object at 0x18b071>"
                  obj-name
                  (-to_ (bound-method-name func))
                  obj-name)
        (format "<function %s at 0x18b071>" (if (and (listp func)
                                                     (or (eq (car func) 'lambda)))
                                                "<lambda>"
                                              (symbol-name func))))))
  
  (defun py-hash-str (ht)
    (let (str)
      (maphash (lambda (key value)
                 (push (concat (pyel-str-function key)
                               ": "
                               (pyel-str-function value))
                       str))
               ht)
  
      (concat "{" (mapconcat 'identity (reverse str) ", ") "}")))
  
  ;;temp fix for 'str' transform
  ;;The problem:
  ;; cannot pass a function name to the str transform because the tranform
  ;; treats it like a variable and it may not be bound as a variable
  ;;*This should be temporary because the 'str' transform cannot
  ;;expand this way to take advantage of known types
  (defmacro pyel-str (thing)
    (if (symbolp thing)
        (if (boundp thing)
            (list 'pyel-str-function thing)
          (if (functionp thing)
              `(py-function-str (quote ,thing))
            thing;;error
            ))
      (list 'pyel-str-function thing)))
  
  ;;Currently, the repr and str transforms are not not called directly
  ;;so they never have the change to expand.
  ;;The expanded functions are used so we force expansion here.
  ;;required functions are `pyel-str-function' and `pyel-repr-function'
  ;;;NOTE: this is also done in `pyel-run-tests'
  (let ((current-transform-table (get-transform-table 'pyel)))
    (call-transform (pyel-func-transform-name 'repr) nil)
    (call-transform (pyel-func-transform-name 'str) nil))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   str
   ("str('somestring')" "\"somestring\"")
   ("str(\"'dstring'\")" "\"'dstring'\"")
   ("str(342)" "342")
   ("x = [1,2,'hi']
  str(x)"
    "[1, 2, \"hi\"]")
   ("x = (1,'two',3)
  str(x)"
    "(1, \"two\", 3)")
   ("x = {1: 'one', 5: 'five', 12: 'telve'};
  str(x)"
    "{1: \"one\", 5: \"five\", 12: \"telve\"}")
   ("f = lambda : False
  str(f)"
    "<function <lambda> at 0x18b071>")
   ("def __ff_(): pass
  str(__ff_)"
    "<function --ff- at 0x18b071>")
  
   ("class strtest:
   def __init__ (self, n):
    self.x = n
   def __str__(self):
    return 'str' + str(self.x)
  obj = strtest(4)"
   ("str(obj)" "str4")))
#+END_SRC
** repr
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform repr (thing)
                       (number) -> (number-to-string thing)
                       (string) -> (py-repr-string thing)
                       (function) -> (py-function-str thing)
                       (symbol) -> (pyel-symbol-str thing)
                       (list) -> (py-list-repr thing)
                       (object) -> (call-method thing --repr--)
                       (vector) -> (py-vector-str thing)
                       (hash) -> (py-hash-str thing))

  (pyel-translate-function-name 'repr 'pyel-repr)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;;temp function. see `pyel-str' for details
  (defmacro pyel-repr (thing)
    (if (stringp thing)
        (py-repr-string (py-repr-string thing))
      (if (symbolp thing)
          (if (boundp thing)
              (list 'pyel-repr-function thing)
            (if (functionp thing)
                `(py-function-str (quote ,thing))
              thing;;error
              ))
        (list 'pyel-repr-function thing))))
  
  (defsubst py-repr-string (thing)
    (prin1-to-string thing))
  
  (defun _py-repr-sequence (seq)
    (mapconcat (lambda (x) (pyel-repr-function x)) seq ", "))
  
  (defun py-list-repr (thing)
    (concat "[" (_py-repr-sequence thing) "]"))
  
  (defun py-vector-repr (thing)
    (concat "(" (_py-repr-sequence thing) ")"))
  
  (defun pyel-symbol-str (sym)
    (if (eq sym t)
        "True"
      (case sym
        (nil "False")
        (integer "<class 'int'>")
        (float "<class 'float'>")
        (string "<class 'str'>")
        (cons "<class 'list'>")
        (vector "<class 'tuple'>")
        (hash-table "<class 'dict'>")
        (t (symbol-name sym)))))
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   repr
   ("repr('somestring')" "\"\\\"somestring\\\"\"")
   ("repr(342)" "342")
   ("x = [1,2,'hi']
  repr(x)"
    "[1, 2, \"hi\"]")
   ("x = (1,'two',3)
  repr(x)"
    "(1, \"two\", 3)")
   ("x = {1: 'one', 5: 'five', 12: 'telve'}
  repr(x)"
    "{1: \"one\", 5: \"five\", 12: \"telve\"}")
   ("f = lambda : False
  repr(f)"
    "<function <lambda> at 0x18b071>")
   ("def __ff_(): pass
  repr(__ff_)"
    "<function --ff- at 0x18b071>"))
#+END_SRC
** hex
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'hex 'py-hex)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-hex (n)
    (format "0x%x" n))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   hex-function
   ("hex(23)" "0x17")
   ("hex(123232332)" "0x758604c"))
#+END_SRC
** bin
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'bin 'py-bin)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-bin (n) ;;Is there really no built in way to do this???
    (let (bin)
      (while (not (= n 0))
        (push (number-to-string (% n 2)) bin)
        (setq n (/ n 2)))
      (mapconcat 'identity (cons "0b" bin) "")))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   bin-function
   ("bin(123)" "0b1111011")
   ("bin(3456312)" "0b1101001011110100111000"))
#+END_SRC
** print
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;;(pyel-translate-function-name 'print 'py-print)
  (pyel-define-function-translation
   print
   `(py-print ,(cadr (assoc 'sep kwargs))
              ,(cadr (assoc 'end kwargs))
              nil ;;TODO: file=sys.stdout
              ,@args))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defvar pyel-print-function 'prin1
    "function that is used for printing by `py-print'")

  (defun py-print (sep end file &rest args)
    (let ((sep (or sep " "))
          (end (or end "\n")))
      (progn (mapc (lambda (x)
                     (funcall pyel-print-function x)
                     (funcall pyel-print-function sep))
                   (butlast args))
             (funcall pyel-print-function (car (last args)))
             (funcall pyel-print-function end)
             nil)))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Print(dest, values, nl, lineno='nil', col_offset='nil'):
      print("Error: using python2, upgrade to python3")
      exit()
        
#+END_SRC  
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** pow
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-define-function-translation
   pow
   (case (length args)
     (3 (list 'mod (list 'expt (car args) (cadr args)) (caddr args)))
     (2 (list 'expt (car args) (cadr args)))
     (t "ERROR") ;;TODO
     ))
  
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   pow
   ("pow(2,5,5)" 2)
   ("pow(3,7,20)" 7)
   ("pow(3,7)" 2187)
   ("pow(2,2)" 4))
#+END_SRC
** eval
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'eval 'py-eval)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-eval (source &rest others)
    (if others
        (error "Only the first arg in `py-eval' is implemented"))
    (if (stringp source)
        (eval (pyel source))
      (py-raise (TypeError "eval() arg 1 must be a string, bytes or code object)"))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests 
   eval
   ("x = 23
  a = 1
  b = 4
  s = 'a+b'"
    ("eval('x')" 23)
    ("eval(s)" 5)))
#+END_SRC
** type
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-translate-function-name 'type 'py-type)
  
  (pyel-translate-variable-name 'int 'py-int)
  (pyel-translate-variable-name 'float 'py-float)
  (pyel-translate-variable-name 'tuple 'py-tuple)
  (pyel-translate-variable-name 'dict 'py-dict)
  (pyel-translate-variable-name 'list 'py-list)
  (pyel-translate-variable-name 'string 'py-string)
  (pyel-translate-variable-name 'bool 'py-bool)
  (pyel-translate-variable-name 'type 'py-type)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;;TODO: when the built in type classes are finished and `py-type'
  ;;      returns them, the special cases for the types in
  ;;      `pyel-symbol-str' should be removed
  
  (defun py-type (object)
    (cond ((integerp object)
           py-int)
          ((floatp object)
           py-float)
          ((listp object)
           py-list)
          ((stringp object)
           py-string)
          ((py-instance-p object)
           (aref object obj-class-index)) ;;?
          ((py-class-p object)
           py-type)
          ((vectorp object)
           py-tuple)
          ((hash-table-p object)
           py-dict)
          ((or (eq object t)
               (eq object nil))
           py-bool)
          (t (type-of object))))
  
  ;;symbols that represent built in python types
  (defconst py-int 'int)
  (defconst py-float 'int)
  (defconst py-tuple 'tuple)
  (defconst py-dict 'dict)
  (defconst py-list 'list)
  (defconst py-str  'string)
  (defconst py-string 'string)
  (defconst py-bool 'bool)
  (defconst py-type 'type)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   type
   ("type(t)" "<class 'bool'>")
   ("type(3)" py-int)
   ("type(3.3)" py-float)
   ("type('3')" py-string)
   ("type([3])" py-list)
   ("type((3,))" py-tuple)
   ("type({3:'3'})" py-list)
   ("type('s') == str" t)
   ("type((3,)) == list" nil)
   ("class testc: pass
  x = testc()
  y = type(x)"
    ("repr(type(x))" "<class 'testc'>")
    ("y is testc" t)))
#+END_SRC
** abs
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform abs (object)
                       (number) -> (abs object)
                       (object) -> (call-method object --abs--))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   abs-function
   ("abs(3)" 3)
   ("abs(-3)" 3)
   ("class C:
   def __abs__(self):
    'doc'
    return 'hi'
  obj = C()"
    ("abs(obj)" "hi")))
#+END_SRC  
** chr
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-translate-function-name 'chr 'py-chr)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defsubst py-chr (i)
    (byte-to-string i))
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   chr-function
   ("chr(70)" "F")
   ("chr(50)" "2"))
#+END_SRC

** ord
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-translate-function-name 'ord 'py-ord)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defsubst py-ord (i)
    (string-to-char i))
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   ord-function
   ("ord('F')" 70)
   ("ord('2')" 50))
#+END_SRC
** exit
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'exit 'pyel-exit)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
(defun pyel-exit ()
  (if pyel-interactive
      (progn (kill-buffer)
	     (message "you killed ipyel")
	     (throw 'ipyel-quit nil))
    ;;(kill-emacs)
    (save-buffers-kill-terminal)))
#+END_SRC
** int
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform int (object)
                       (string) -> (py-str-to-int object)
                       (number) -> (py-number-to-int object)
                       (object) -> (call-method object --int--))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defmacro py-number-to-int (num)
    (if (numberp num)
        (floor num)
      (list 'floor num)))
  
  (defmacro py-str-to-int (str)
    (if (stringp str)
        (floor (string-to-int str))
      `(floor (string-to-int ,str))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   int-function
   ("int('34')" 34)
   ("int('3.3')" 3)
   ("int(2)" 2)
   ("int(23.2)" 23)
   ("x = '3'
  y = ['4']
  z = 2
  a = 3.3"
    ("int(x)" 3)
    ("int(y[0])" 4)
    ("int(z)" 2)
    ("int(a)" 3))
   ("class test:
   def __int__(self):
    return 342
  o = test()"
    ("int(o)" 342)))
#+END_SRC

** float
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform float (object)
                       (string) -> (py-str-to-float object)
                       (number) -> (py-number-to-float object)
                       (object) -> (call-method object --float--))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defmacro py-number-to-float (num)
    (if (numberp num)
        (* 1.0 num)
      (list '* 1.0 num)))
  
  (defmacro py-str-to-float (str)
    (if (stringp str)
        (* 1.0 (string-to-int str))
      (list '* 1.0 (list 'string-to-int str))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   float-function
   ("float('34')" 34.0)
   ("float('3.3')" 3.3)
   ("float(2)" 2.0)
   ("float(23.2)" 23.2)
   ("x = '3.1'
  y = ['4']
  z = 2
  a = 3.3"
    ("float(x)" 3.1)
    ("float(y[0])" 4.0)
    ("float(z)" 2.0)
    ("float(a)" 3.3))
   ("class test:
   def __float__(self):
    return 342.1
  o = test()"
    ("float(o)" 342.1)))
#+END_SRC

** dict
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-kwarg-transform dict (kwargs)
                             (_)-> (pyel-alist-to-hash2 'kwargs))
  
  (pyel-func-transform dict (&optional object)
                       (list)   -> (pyel-list-to-dict object)
                       (object) -> (pyel-object-to-dict object)
                       (vector) -> (pyel-vector-to-dict object)
                       (hash)   -> (copy-hash-table object))
  
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-alist-to-hash2 (alist)
    "like `pyel-alist-to-hash' but elements have the form (a b)"
    (let ((ht (make-hash-table
               :test 'equal
               :size (length alist))))
      (mapc (lambda (x)
              (puthash (car x) (cadr x) ht))
            alist)
      ht))
  
  (defun pyel-list-to-dict (list)
    (let ((h (make-hash-table :test pyel-dict-test)) ;;default length??
          key-val)
      (mapcar (lambda (elem)
                (setq key-val (pyel-get-key-val elem))
                (puthash (car key-val) (cdr key-val) h))
              list)
      h))
  
  (defun pyel-vector-to-dict (vec)
    (let ((h (make-hash-table :test pyel-dict-test)) ;;default length??
          key-val)
      (dotimes (i (length vec))
        (setq key-val (pyel-get-key-val (aref vec i)))
        (puthash (car key-val) (cdr key-val) h))
      h))
  
  (defun pyel-object-to-dict (object)
    (let ((iter (condition-case nil
                    (call-method object --iter--)
                  (AttributeError
                   (py-raise (TypeError (format
                                         "'%s' object is not iterable"
                                         (getattr object --name--)))))))
          (ht (make-hash-table :test pyel-dict-test))
          key-val)
      (condition-case nil
          (while t
            (setq key-val (pyel-get-key-val (call-method iter --next--)))
            (puthash (car key-val) (cdr key-val) ht))
        (StopIteration ht))))
  
  (defun pyel-get-key-val (obj)
    "(k . v) -> (k . v)
  \(k v) -> (k . v)
  \[k v] -> (k . v)
  'kv' -> ('k' . 'v')"
    (cond ((listp obj)
           (if (listp (cdr obj))
               (if (= (length obj) 2)
                   (cons (car obj) (cadr obj))
                 (error "invalid length"))
             obj))
          ((vectorp obj)
           (if (= (length obj) 2)
               (cons (aref obj 0) (aref obj 1))
             (error "invalid length")))
          ((stringp obj)
           (if (= (length obj) 2)
               (cons (subseq obj 0 1) (subseq obj 1 2))
             (error "invalid length")))
          (t (error "invalid type"))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   dict-function
   ("repr(dict())" "{}")
   ("repr(dict(__a = 1,__b = 2,__c = 4))" "{--a: 1, --b: 2, --c: 4}")
   ("repr(dict([('a',3),('b', 5),('c',8)]))" "{\"a\": 3, \"b\": 5, \"c\": 8}")
   ("repr(dict((('a',3),('b', 5),('c',8))))" "{\"a\": 3, \"b\": 5, \"c\": 8}")
   ("a = [('ab'),['b', 5],('c',8)]
  x = dict(a)"
    ("repr(x)" "{\"a\": \"b\", \"b\": 5, \"c\": 8}"))
   ("class a:
   x = 5
   def __iter__(self):
    return self
   def __next__(self):
    if self.x > 0:
     ret = self.x
     self.x -= 1
     return ret, ret**2
    raise StopIteration
  o = a()
  x = dict(o)"
    ("repr((x))" "{5: 25, 4: 16, 3: 9, 2: 4, 1: 1}")))
#+END_SRC

** round
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-translate-function-name 'round 'py-round)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-round (number &optional ndigits)
    (if ndigits
        (round-float number ndigits)
      (round number)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   round-function
   ("round(342.234)" 342)
   ("round(342.834)" 343)
   ("round(342.834,1)" 342.8)
   ("round(342.834,2)" 342.83))
#+END_SRC
** enumerate
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform enumerate (obj &optional start)
                       (list)   -> (pyel-enumerate-list obj start)
                       (string) -> (pyel-enumerate-string obj start)
                       (object) -> (pyel-enumerate-object obj start)
                       (vector) -> (pyel-enumerate-vector obj start)
                       (hash)   -> (copy-enumerate-hash obj start))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-enumerate-list (list &optional start)
    (let ((ret nil)
          (c (or start 0)))
      (while list
        (setq ret (cons (list c (car list)) ret)
              list (cdr list)
              c (1+ c)))
      (reverse ret)))
  
  (defsubst pyel-enumerate-vector (vec &optional start)
    (pyel-enumerate-list (mapcar 'identity vec) start))
  
  (defsubst pyel-enumerate-hash (hash &optional start)
    (pyel-enumerate-list (py-hash-to-list hash) start))
  
  (defsubst pyel-enumerate-string (str &optional start)
    (pyel-enumerate-list (split-string str "" :omit-nulls) start))

  (defsubst pyel-enumerate-object (obj &optional start)
    (pyel-enumerate-list (py-object-to-list obj) start))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   enumerate-function
   ("enumerate(['a','b','c'])" '((0 "a") (1 "b") (2 "c")))
   ("enumerate(('a','b','c'))" '((0 "a") (1 "b") (2 "c")))
   ("enumerate('abc')" '((0 "a") (1 "b") (2 "c")))
   ("enumerate(['a','b','c'],10)" '((10 "a") (11 "b") (12 "c")))
   ("enumerate(('a','b','c'),10)" '((10 "a") (11 "b") (12 "c")))
   ("enumerate('abc',10)" '((10 "a") (11 "b") (12 "c")))
   ("class a:
   x = 5
   def __iter__(self):
    return self
   def __next__(self):
    if self.x > 0:
     ret = str(self.x)
     self.x -= 1
     return ret
    raise StopIteration
  obj = a()"
    ("enumerate(obj)" '((0 "5") (1 "4") (2 "3") (3 "2") (4 "1")))))
#+END_SRC

** interactive
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-define-function-translation
   interactive
   (setq interactive t))
#+END_SRC
** divmod
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform divmod (x y)
                       (_ float)
                       (_ float) -> (py-divmod-f x y)
                       (int int) -> (py-divmod-i x y)
                       (_ _)     -> (py-divmod x y))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defmacro py-divmod (x y)
    "(divmod X Y) -> [div mod]
  
  Return the vector [(X-X%Y)/Y, X%Y].  Invariant: div*Y + mod == X."
    (cond ((and (numberp x)
                (numberp y))
           (vector (if (or (floatp x)
                           (floatp y))
                       (ffloor (/ x y)) (floor (/ x y)))
                   (mod x y)))
          ((or (floatp x) (floatp y))
           `(vector (ffloor (/ ,x ,y)) (mod ,x ,y)))
          (t `(vector (if (or (floatp ,x)
                              (floatp ,y))
                          (ffloor (/ ,x ,y))
                        (floor (/ ,x ,y)))
                      (mod ,x ,y)))))
  
  (defsubst py-divmod-f (x y)
    (vector (ffloor (/ x y)) (mod x y)))
  
  (defsubst py-divmod-i (x y)
    (vector (floor (/ x y)) (mod x y)))
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   divmod-function
   ("divmod(6, 2)" [3 0])
   ("divmod(6, 4)" [1 2])
   ("divmod(6.7, 4)" [1.0 2.7])
   ("divmod(6.712, 4.1)" [1.0 2.612])
   ("divmod(4.2, 2.1)" [2.0 0.0])
   ("divmod(4, 2.1)" [1.0 1.9])
   ("a = 412
  b = 13"
    ("divmod(a, b)" [31 9])))
#+END_SRC

** bool
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-func-transform bool (object)
                       (object) -> (py-object-bool object)
                       (_) -> (py-bool object))
  
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defsubst py-bool (thing)
    "convert a non-object THING into a boolean value.
  For objects, use `py-object-bool'"
    ;;TODO: this should handled in the type dispatch
    (if (and thing (not (or (eq thing 0) (eq thing []) (eq thing "")))) t))
  
  (defun py-object-bool (object)
    "return t if an object is considered true, else nil.
  If the object defines the --bool-- method, that is called.
  Otherwise the --len-- method is tried, the result is true
  if the length is greator then one.
  If neither the --bool-- or the --len-- methods are defined,
  all instances are considered true"
    (condition-case nil
        (call-method object --bool--)
      (AttributeError
       (condition-case nil
           (> (call-method object --len--) 0)
         (AttributeError
          t)))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* method transforms
** doc  TODO: move or tangle
*Defining method transforms for build in types*
In python, primitive types such as the list and string are objects. We need to
define the way in which these method calls will be transformed to function
calls in Emacs Lisp. The macro `pyel-method-transform' is used for this.

Definition form is just like normal type transforms, with a few extra requirement
- The first argument is the potential object
- these transforms are responsible for creating the normal
  method call if obj is actually an object and not a primative type
  this must always be last with the type selector (_ _ ... _ ) ->
Example:
#+Begin_SRC emacs-lisp
  (pyel-method-transform append (obj thing)
                         (list _) -> (py-list-append obj thing)
                         (_ _)    -> (call-method obj append thing))
#+End_Src
** append
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform append (obj thing)
                         (list _) -> (py-append $obj thing)
                         (_ _)    -> (call-method obj append thing))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list-append (list thing)
    "add THING to the end of LIST"
    (while (not (null (cdr list)))
      (setq list (cdr list)))
    (setcdr list (list thing)))
  
  (defmacro py-append (list thing)
    "add THING to the end of LIST"
    `(cond ((null ,list) (setq ,list (list ,thing)))
           (t (py-list-append ,list ,thing))))
  
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   append
   ("a = [1,2,3]
  c = ['a','a']
  b = a
  a.append('hi')
  e = []
  e.append(3)"
    ("a" '(1 2 3 "hi"))
    ("a is b" t)
    ("a.append(c)" ("a is b" t))
    ("a.append(c)" ("a[3] is c" t))
    ("e" '(3))))
#+END_SRC
** insert
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform insert (obj i x)
                         (list _) -> (py-insert obj i x)
                         (_ _) -> (call-method obj insert i x))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
(defun py-insert (list index object)
  "insert OBJECT into LIST at INDEX"
  (let ((i 0)
	(rest list)
	first)
    (while (< i index)
      (setq first rest)
      (setq rest (cdr rest))
      (setq i (1+ i)))
    (setcdr first (cons object rest)))
  nil)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(pyel-create-tests
 insert
 ("x = [1,2,3]
y = x
x.insert(1,'hi')"
  ("x" '(1 "hi" 2 3))
  ("x is y" t)))
#+END_SRC
** find
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform find (obj sub &optional start end)
                         (string _ _ _) -> (py-find obj sub start end)
                         (_ _ _ _)      -> (call-method obj find sub start end))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-find (str sub &optional start end)
    "Return the lowest index in S where substring sub is found,
  such that sub is contained within S[start:end].  Optional
  arguments start and end are interpreted as in slice notation.
  
  Return -1 on failure."
    (let* ((start (or start 0))
          (index (string-match (regexp-quote sub) (substring str start end))))
      (if index
          (+ index start)
        -1)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   find-method
   ("'aaaxaaa'.find('x',3)"  3)
   ("'aaaxaaa'.find('x',4)"  -1)
   ("'aaaxaaa'.find('x',2, 4)"  3)
   ("'aaaxaaa'.find('x',1, 3)"  -1)
   ("x = 'asdf'"
    ("x.find('sd')" 1)))
#+END_SRC
** index
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform index (obj elem)
                         (list _) -> (list-index elem obj)
                         (string _) -> (py-string-index obj elem)
                         (object _) -> (call-method obj index elem)
                         (vector _) -> (vector-index elem obj))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun list-index (elem list)
    "return the index of ELEM in LIST"
    (let ((m (member elem list)))
      (when m
        (- (length list) (length m)))))
  
  (defun vector-index (elem vector)
    "return the index of ELEM in VECTOR"
    (let ((i 0)
          (len (length vector))
          found)
  
      (while (and (< i len)
                  (not found))
        (if (equal (aref vector i) elem)
            (setq found i)
          (setq i (1+ i))))
      found))
  
  (defun py-string-index (str sub)
    "Like STR.find() but raise ValueError when the substring SUB is not found."
    (let ((ret (py-find str sub)))
      (if (= ret -1)
          (py-raise (ValueError "substring not found"))
        ret)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   index-method
   ;;lists
   ("x = [1,(1,2),'5']"
    ("x.index(1)" 0 )
    ("x.index((1,2))" 1)
    ("x.index('5')" 2))
   ;;strings
   ("x = 'importantstring'"
    ("x.index('t')" 5)
    ("x.index('or')" 3)
    ("x.index('g')" 14)
    ("x.index(x)" 0))
    ("x = 'str.ing'"
     ("x.index('.')" 3))
   ;;arrays
   ("x = (1,2,'tree',(3,))"
    ("x.index(1)" 0)
    ("x.index('tree')" 2)
    ("x.index((3,))" 3)))
#+END_SRC
** remove
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform remove (obj x)
                         (list _) -> (py-list-remove obj x)
                         (_ _) -> (call-method obj remove x))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list-remove (list item)
    "remove ITEM from LIST"
    (when (equal (car list) item)
      (setcar list (cadr list))
      (setcdr list (cddr list)))
    (let ((rest list)
          first)
      (while rest
        (if (equal (car rest) item)
            (progn (setcdr first (cdr rest))
                   (setq rest nil))
          (setq first rest
                rest (cdr rest))))
      nil))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   remove-method
   ("x = [1,'2','2',(1,)]
  y = x
  x.remove('2')"
    ("x is y" t))
   
   ("x = [1,'2','2',(1,)]
  x.remove('2')"
    ("x" '(1 "2" [1])))
   
   ("x = [1,'2','2',(1,)]
  x.remove(1)"
    ("x" '("2" "2" [1])))
   
   ("x = [1,'2','2',(1,)]
  x.remove((1,))"
    ("x" '(1 "2" "2"))))
#+END_SRC
** count
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform count (obj elem)
                         (string _) -> (count-str-matches obj elem)
                         (list _) -> (count-elems-list obj elem)
                         (object _)  -> (call-method obj count elem)
                         (vector _) -> (count-elems-vector obj elem))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;;;; this one is slower
  ;;;; maybe faster with a non-regexp search function?
  ;; (defun count-str-matches (string substr)
  ;;   "count number of occurrences of SUBSTR in STRING"
  ;;   (let ((quoted (regexp-quote substr))
  ;;      (start 0)
  ;;      (strlen (length string))
  ;;      (sublen (length substr))
  ;;      (count 0))
  ;;     (while (< start strlen)
  ;;       (setq start (string-match quoted string start))
  ;;       (if start (setq count (1+ count)
  ;;                    start (+ start sublen))
  ;;      (setq start strlen)))
  ;;     count))
  
  (defun count-str-matches (string substr)
    "count number of occurrences of SUBSTR in STRING"
    (with-temp-buffer
      (insert string)
      (goto-char 1)
      (how-many (regexp-quote substr))))
  
  (defun count-elems-list (list elem)
    "return how many times ELEM occurs in LIST"
    (let ((c 0))
      (dolist (x list)
        (if (equal x elem)
            (setq c (1+ c))))
      c))
  
  (defun count-elems-vector (vector elem)
    "return how many times ELEM occurs in VECTOR"
    (let ((c 0)
          (i 0)
          (len (length vector)))
      (while (< i len)
        (if (equal (aref vector i) elem)
            (setq c (1+ c)))
        (setq i (1+ i)))
      c))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(pyel-create-tests
 count-method
 ;;strings
 ("'xxxxx'.count('x')" 5)
 ("'xxxx'.count('xx')" 2)
 ("'xxxx'.count('xxxx')" 1)
 ("'x.xx'.count('.')" 1)
 ;;lists
 ("x = [1,2,3,3,[2],'s']"
  ("x.count(3)" 2)
  ("x.count(2)" 1)
  ("x.count([3,4])" 1)
  ("x.count('s')" 1))
 ;;vector
 ("x = (1,2,3,3,[2],'s')"
  ("x.count(3)" 2)
  ("x.count(2)" 1)
  ("x.count([3,4])" 1)
  ("x.count('s')" 1))
 ("(1,1,1).count(1)" 3))
#+END_SRC
** join
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform join (obj elem)
                         (string _) ->  (mapconcat 'identity elem obj)
                         (_ _)      -> (call-method obj join thing))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
    (pyel-create-tests
     join-method
     ("'X'.join(('f','g'))" "fXg")
     ("' '.join([str(x) for x in range(3)])" "0 1 2")
     ("''.join(['a','b']))" "ab"))
#+END_SRC
** extend
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform extend (obj elem)
                         (list _) ->  (py-list-extend obj elem)
                         (_ _)    ->  (call-method obj extend elem))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list-extend (list iterable)
    "Extend LIST by appending elements from the ITERABLE"
    (let ((rest list)
          prev)
  
      (while rest
        (setq prev rest
              rest (cdr rest)))
      
      (cond ((py-object-p iterable)
             (_py-list-extend-with-object prev iterable))
            ((listp iterable)
             (_py-list-extend-with-list prev iterable))
            ((stringp iterable)
             (_py-list-extend-with-string prev iterable))
            ((vectorp iterable)
             (_py-list-extend-with-vector prev iterable))
            (t (py-raise (TypeError (format "TypeError: '%s' object is not iterable"
                                            (type-of iterable))))))))
  
  (defun _py-list-extend-with-list (list extendlist)
    (while extendlist
      (setcdr list (list (car extendlist)))
      (setq list (cdr list)
            extendlist (cdr extendlist))))
  
  (defun _py-list-extend-with-vector (list vector)
    (let ((len (length vector))
          (index 0))
      (while (< index len)
        (setcdr list (list (aref vector index)))
        (setq list (cdr list)
              index (1+ index)))
      nil))
  
  (defun _py-list-extend-with-string (list string)
    (let ((len (length string))
          (index 0))
      (while (< index len)
        (setcdr list (list (char-to-string (aref string index))))
        (setq list (cdr list)
              index (1+ index)))
      nil))
  
  (defun _py-list-extend-with-object (list object)
    "assumes that py-object(OBJECT) == t"
    (let ((iter (condition-case nil
                    (call-method object --iter--)
                  (AttributeError
                   (py-raise (TypeError (format
                                         "'%s' object is not iterable"
                                         (getattr object --name--))))))))
      (condition-case nil
          (while t
            (setcdr list (list (call-method iter --next--)))
            (setq list (cdr list)))
        (StopIteration nil))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   extend-method
   ;;extend with list
   ("x = [1]
  y = x
  x.extend([1,'2',(3,)])"
    ("x is y" t)
    ("x" '(1 1 "2" [3])))
   ;;extend with vector
   ("x = [1]
  y = x
  x.extend((1,'2',(3,)))"
    ("x is y" t)
    ("x" '(1 1 "2" [3])))
   ;;extend with string
   ("x = [1]
  y = x
  x.extend('extended')"
    ("x is y" t)
    ("x" '(1 "e" "x" "t" "e" "n" "d" "e" "d")))
   ;;extend with object
   ("class a:
   x = 5
   def __iter__(self):
    return self
   def __next__(self):
    if self.x > 0:
     ret = str(self.x)
     self.x -= 1
     return ret
    raise StopIteration
  obj = a()
  x = [1]
  y = x
  x.extend(obj)"
    ("y is x" t)
    ("x" '(1 "5" "4" "3" "2" "1"))))
#+END_SRC
** pop
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform pop (obj &optional a)
                         (list _) -> (py-list-pop obj a)
                         (hash _) -> (py-hash-pop obj a)
                         (_ _)    -> (call-method obj pop a))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list-pop (list &optional index)
    "remove and return item at INDEX from LIST (default last)"
    (let ((rest list)
          (i 0)
          last ret)
      (if index
          (if (= index 0)
              (progn
                (setq ret (car list))
                (setcar list (cadr list))
                (setcdr list (cddr list))
                ret)
            ;; 0 < index < len(list)
            (while (< i index)
              (setq last rest
                    rest (cdr rest)
                    i (1+ i)))
            (setq ret (car rest))
            (setcdr last (cdr rest))
            ret)
        ;;pop last element
        (while (cdr rest)
          (setq prev rest
                rest (cdr rest)))
        (setq ret (car rest))
        (setcdr prev nil))
      ret))
  
  (defun py-hash-pop (ht key)
    (let ((ret (gethash key ht)))
      (remhash key ht)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   pop-method
   ("x = [[1],'s',(2,), 1, 4]
  y = x
  a = x.pop()
  b = x.pop(0)
  c = x.pop(2)
   "
    ("a" 4)
    ("b" '(1))
    ("c" 1)
    ("x is y" t))
  
   ("x = {1:'one',2:'two',3:'three'}
  y = x.pop(2)"
    ("y" "two") 
    ("repr(x)" "{1: \"one\", 3: \"three\"}"))
   )
#+END_SRC
** reverse
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform reverse (obj)
                         (list) ->  (pyel-list-reverse obj)
                         (_)    ->  (call-method obj reverse))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-list-reverse (list)
    "reverse LIST *IN PLACE*"
    (let ((reversed (reverse list))
          (rest list))
      (while reversed
        (setcar rest (car reversed))
        (setq reversed (cdr reversed)
              rest (cdr rest)))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   reverse-method
   ("x = [1,2,3]
  y = x
  x.reverse()"
    ("x" '(3 2 1))
    ("x is y" t)))
#+END_SRC
** lower
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform lower (obj)
                         (string) ->  (downcase obj)
                         (_)    ->  (call-method obj lower))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   lower-method
   ("x = 'aB'
  y = x
  y = x.lower()"
    ("y" "ab")
    ("x" "aB")))
#+END_SRC
** upper
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform upper (obj)
                         (string) ->  (upcase obj)
                         (_)    ->  (call-method obj upper))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   upper-method
   ("x = 'aB'
  y = x
  y = x.upper()"
    ("y" "AB")
    ("x" "aB")))
#+END_SRC
** split
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform split (obj &optional sep maxsplit)
                         (string) ->  (pyel-split obj sep maxsplit)
                         (_)    ->  (call-method obj split sep maxsplit))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-split (string &optional sep maxsplit)
    
    (let ((sep (or (and sep (regexp-quote sep)) "[ \f\t\n\r\v]+")) ;;correct default?
          (ret (split-string string sep t)))
      (if maxsplit
          ret ;;TODO
        ret)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   split-method
   ("x = 'a b c'
  y = x.split()"
    ("y" '("a" "b" "c")))
   ("'a b c'.split()" '("a" "b" "c"))
   ("y = 'a x b x d x'.split()"
    ("y" '("a" "x" "b" "x" "d" "x"))
    ("len(y)" 6)))
#+END_SRC
** strip
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform strip (obj &optional chars)
                         (string) ->  (pyel-strip obj chars)
                         (_)    ->  (call-method obj strip chars))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-strip-left (s &optional chars)
    "Remove whitespace or CHARS at the beginning of S."
    (let ((chars (if chars (format "\\`[%s]+" chars)
                   "\\`[ \t\n\r]+")))
      (if (string-match chars s)
          (replace-match "" t t s)
        s)))
  
  (defun pyel-strip-right (s &optional chars)
    "Remove whitespace or CHARS at the end of S."
    (let ((chars (if chars (format "[%s]+\\'" chars)
                   "[ \t\n\r]+\\'")))
      (if (string-match chars s)
          (replace-match "" t t s)
        s)))
  
  (defun pyel-strip (s &optional chars)
    "Remove whitespace or CHARS at the beginning and end of S."
    (pyel-strip-left (pyel-strip-right s chars) chars))
  
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   strip-method
   ("'\r\nhello \t'.strip('heo')" "hello")
   ("'hello'.strip('heo')" "ll")
   ("x = 'hello'"
    ("x.strip('hlo')" "e")))
#+END_SRC
** get
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform get (obj key &optional default)
                         (hash) ->  (gethash key obj default)
                         (_)    ->  (call-method-with-defaults obj get
                                                               (key) (default)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   get-method
   ("x = {1:'one',2:'two',3:'three'}"
    ("x[1]" "one")
    ("x[1] == x.get(1)" t)
    ("x.get(3, 'd')" "three")
    ("x.get(4, 'd')" "d")))
#+END_SRC
** items
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform items (obj)
                           (hash) -> (pyel-dict-items obj)
                           (_)    -> (call-method obj items))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-dict-items (dict)
    (let (ret)
      (maphash (lambda (key value)
                 (push (list key value) ret))
               dict)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   items-method
   ("x = {1:'one',2:'two',3:'three'}
  y = {8 : 88}
  z = {}"
    ("x.items()" '((3 "three") (2 "two") (1 "one")))
    ("y.items()" '((8 88)))
    ("z.items()" nil)))
#+END_SRC
** keys
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform keys (obj)
                             (hash) -> (pyel-dict-keys obj)
                             (_)    -> (call-method obj key))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-dict-keys (dict)
    (let (ret)
      (maphash (lambda (key value)
                 (push key ret))
               dict)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   keys-method
   ("x = {1:'one',2:'two',3:'three'}
  y = {8 : 88}
  z = {}"
    ("x.keys()" '(3 2 1))
    ("y.keys()" '((8)))
    ("z.keys()" nil)))
#+END_SRC
** values
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform values (obj)
                         (hash) -> (pyel-dict-values obj)
                         (_)    -> (call-method obj values))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-dict-values (dict)
    (let (ret)
      (maphash (lambda (key value)
                 (push value ret))
               dict)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   values-method
   ("x = {1:'one',2:'two',3:'three'}
  y = {8 : 88}
  z = {}"
    ("x.values()" '("three" "two" "one"))
    ("y.values()" '(88))
    ("z.values()" nil)))
#+END_SRC
** popitem
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform popitem (obj)
                         (hash) -> (pyel-hash-popitem obj)
                         (_)    -> (call-method obj popitem))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-hash-popitem (ht)
    (let* ((key (catch '_pop_
                  (maphash (lambda (k v)
                             (throw '_pop_ k))
                           ht)))
           (ret (list key (gethash key ht))))
      (remhash key ht)
      ret))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   popitem-method
   ("x = {1:'one',2:'two',3:'three'}
  y = x.popitem()"
    ("y" '(1 "one"))
    ("repr(x)" "{2: \"two\", 3: \"three\"}")))
#+END_SRC
** copy
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform copy (obj)
                         (hash) -> (copy-hash-table obj)
                         (_)    -> (call-method obj popitem))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   copy-method
   ("x = {1:['one'],2:'two',3:'three'}
  y = x
  z = x.copy()"
    ("x is z" nil)
    ("x[1] is z[1]" t)))
#+END_SRC
** islower
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform islower (obj)
                         (string) -> (py-islower obj)
                         (_)      -> (call-method obj islower))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-gen-match-code (regex str)
    "return code that tests if REGEX matches STR
  if STR is constant, return t if it matches, else nil"
    (let ((case-fold-search nil))
      (if (stringp str)
          (numberp (string-match regex str))
        `(let ((case-fold-search nil))
           (numberp (string-match ,regex ,str))))))
  
  
  (defmacro py-islower (s)
    "S.islower() -> bool
  
  Return t if all cased characters in S are lowercase and there is
  at least one cased character in S, False otherwise."
    (pyel-gen-match-code "^[^A-Z]*[a-z]+[^A-Z]*$" s))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   islower-method
   ("a = 'A'
  b = 'a'
  c = 'Aa'"
    ("a.islower()" nil)
    ("b.islower()" t)
    ("c.islower()" nil))
   ("'A1'.islower()" nil)
   ("'a1'.islower()" t)
   ("'11'.islower()" nil))
#+END_SRC

** isupper
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform isupper (obj)
                         (string) -> (py-isupper obj)
                         (_)      -> (call-method obj isupper))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defmacro py-isupper (s)
    "S.isupper() -> bool
  
  Return True if all cased characters in S are uppercase and there is
  at least one cased character in S, False otherwise."
  (pyel-gen-match-code "^[^a-z]*[A-Z]+[^a-z]*$" s))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   isupper-method
   ("a = 'A'
  b = 'a'
  c = 'Aa'"
    ("a.isupper()" t)
    ("b.isupper()" nil)
    ("c.isupper()" nil))
   ("'A1'.isupper()" t)
   ("'a1'.isupper()" nil)
   ("'11'.isupper()" nil))
#+END_SRC
** istitle
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform istitle (obj)
                         (string) -> (py-istitle obj)
                         (_)      -> (call-method obj istitle))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defmacro py-istitle (s)
  "  S.istitle() -> bool
  
      Return True if S is a titlecased string and there is at least one
      character in S, i.e. upper- and titlecase characters may only
      follow uncased characters and lowercase characters only cased ones.
      Return False otherwise.  "
  
    (pyel-gen-match-code "^[^a-zA-Z]*[A-Z][^A-Z]*$" s))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   istitle-method
   ("a = 'sldk'
  b = 'Dsldk'
  c = 'aDsldk'"
    ("a.istitle()" nil)
    ("b.istitle()" t)
    ("c.istitle()" nil))
   ("'2Dsldk'.istitle()" t)
   ("'DDsldk'.istitle()" nil)
   ("'LDKJ'.istitle()" nil)
   ("''.istitle()" nil))
#+END_SRC
** isalpha
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform isalpha (obj)
                         (string) -> (py-isalpha obj)
                         (_)      -> (call-method obj isalpha))  
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defmacro py-isalpha (s)
      "S.isalpha() -> bool
    
    Return True if all characters in S are alphabetic
    and there is at least one character in S, False otherwise."
    
      (pyel-gen-match-code "^[a-zA-Z]+$" s))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(pyel-create-tests
 isalpha-method
 ("'a'.isalpha()" t)
 ("'aBc'.isalpha()" t)
 ("'2'.isalpha()" nil)
 ("'a2B'.isalpha()" nil)
 ("''.isalpha()" nil)
 ("x = 'asd'"
  ("x.isalpha()" t)))  
#+END_SRC
** isalnum
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform isalnum (obj)
                         (string) -> (py-isalnum obj)
                         (_)      -> (call-method obj isalnum))

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defmacro py-isalnum (s)
    "S.isalnum() -> bool
  
      Return True if all characters in S are alphanumeric
      and there is at least one character in S, False otherwise."
  
    (pyel-gen-match-code "^[0-9]+$" s))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   isalnum-method
   ("'0'isalnum()" t)
   ("'0'isalnum()"  t)
   ("'0s'.isalnum()" nil)
   ("''.isalnum()" nil)
   ("'0.1'.isalnum()" nil)
   ("x = '23'"
    ("x.isalnum()" t)))
  
#+END_SRC
** zfill
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform zfill (obj width)
                         (string) -> (py-zfill obj width)
                         (_)      -> (call-method obj zfill width))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-zfill (str width)
    " S.zfill(width) -> str
  
  Pad a numeric string S with zeros on the left, to fill a field
  of the specified width. The string S is never truncated."
    (let ((diff (- width (length str))))
      (if (> diff 0)
          (concat (make-string diff ?0) str)
        str)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   zfill-method
   ("a = 'asdf'"
    ("a.zfill(10)" "000000asdf"))
   ("'34'.zfill(5)" "00034")
   ("'234789'.zfill(5)" "234789")
   ("''.zfill(5)" "00000"))  
#+END_SRC
** title
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform title (obj)
                         (string) -> (py-title obj)
                         (_)      -> (call-method obj title))  
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-title (s)
    "Return a titlecased version of S, i.e. words start with title case
  characters, all remaining cased characters have lower case."
    (let ((case-fold-search nil))
      (if (eq s "")
          ""
        (if (string-match "^\\([^A-Za-z]*\\)\\([A-Za-z]\\)\\(.*\\)$" s)
            (concat (match-string 1 s)
                    (upcase (match-string 2 s))
                    (downcase (match-string 3 s)))
          s))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   title-method
   ("'sldk'.title()" "Sldk")
   ("'s'.title()" "S")
   ("''.title()" "")
   ("'2dd'.title()" "2Dd")
   ("'2ddlkDd'.title()" "2Ddlkdd")
   ("'23(23aaaaa'.title()" "23(23Aaaaa")
   ("'343'.title()" "343")
   ("x = '2dd'"
    ("x.title()" "2dd")))
#+END_SRC
** swapcase
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform swapcase (obj)
                         (string) -> (py-swapcase obj)
                         (_)      -> (call-method obj swapcase))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-swapcase (s)
    "swapcase(...)
  S.swapcase() -> str
  
  Return a copy of S with uppercase characters converted to lowercase
  and vice versa."
    (let ((i (length s)))
      (while (> i 0)
        (setq i (1- i))
        (aset s i (let ((char (aref s i)))
                    (if (eq (downcase char) char)
                        (upcase char)
                      (downcase char)))))
      s))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   swapcase-method
   ("'ab'.swapcase()"  "AB")
   ("'aB'.swapcase()"  "Ab")
   ("'aB1'.swapcase()"  "Ab1")
   ("'11'.swapcase()" "11")
   ("''.swapcase()"  "")
   ("x = 'aaBB1'"
    ("x.swapcase()" "AAbb1")))  
#+END_SRC
** startswith
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform startswith (obj prefix &optional start end)
                         (string _ _ _) -> (py-startswith obj prefix start end)
                         (_ _ _ _)            -> (call-method obj startswith prefix start end))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-startswith (s prefix &optional start end)
    "S.startswith(prefix[, start[, end]]) -> bool
  
  Return True if S starts with the specified prefix, False otherwise.
  With optional start, test S beginning at that position.
  With optional end, stop comparing S at that position.
  prefix can also be a tuple of strings to try."  
    (setq start (or start 0))
    (cond ((stringp prefix)
           (if (string-match (concat "^" (regexp-quote prefix)) (substring s start end))
               t nil))
          ((vectorp prefix)
           (let ((found nil)
                 (i 0)
                 (len (length prefix)))
             (while (< i len)
               (if (py-startswith s (aref prefix i) start end)
                   (setq found t
                         i len)
                 (setq i (1+ i))))
             found))
          (t (py-raise (TypeError (format "startswith first arg must be str or a tuple of str, not %s" (py-type prefix)))))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   startswith-method
   ("'abcde'.startswith('bcd', 1, 2)" nil)
   ("'abcde'.startswith('bcd', 1, 3)" nil)
   ("'abcde'.startswith('bcd', 1, 4)" t)
   ("'abcde'.startswith('bcd', 1)" t)
   ("'abcde'.startswith('x', 1)" nil)
   ("'abcde'.startswith('abc')" t)
   ("'$abcde'.startswith('$abc')" t)
   ("'abcde'.startswith('.')" nil)
   ("x = 'abcde'"
    ("x.startswith('.')" nil))
   ("'abcde'.startswith(('.', 'b'))" nil)
   ("'abcde'.startswith(('.', 'b','a'))" t))
#+END_SRC
** splitlines
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform splitlines (obj &optional keepends)
                         (string) -> (py-splitlines obj keepends)
                         (_)      -> (call-method obj splitlines keepends))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-splitlines (string &optional keepends)
    ;;based off code from `split-string'
    (let ((start 0)
          notfirst
          (list nil)
          (len (length string))
          str)
  
      (while (and (string-match "\n" string
                                (if (and notfirst
                                         (= start (match-beginning 0))
                                         (< start len))
                                    (1+ start) start))
                  (< start len))
        (setq notfirst t
              str (substring string start (match-beginning 0)))
        (if keepends (setq str (concat str "\n")))
        (setq list (cons str list)
              start (match-end 0)))
  
      (setq str (substring string start))
      (unless (eq str "")
        (if keepends (setq str (concat str "\n")))
        (setq list (cons str list)))
      (nreverse list)))  
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   splitlines-method
   ("'''a
  b
  c
  
  '''.splitlines()" '("a" "b" "c" ""))
   ("x =  '''a
  
  b
  c
  
  '''.splitlines()" '("a" "" "" "b" "c" ""))
   ("''.splitlines()" nil)
   ("'asdf'.splitlines()" '("asdf")))
#+END_SRC
** rstrip
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform rstrip (obj &optional chars)
                         (string) -> (py-rstrip obj chars)
                         (_)      -> (call-method obj rstrip chars))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-rstrip (s &optional chars)
    "S.rstrip([chars]) -> str
  
  Return a copy of the string S with trailing whitespace removed.
  If chars is given and not None, remove characters in chars instead."
    (pyel-strip-right s chars))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   rstrip-method
   ("'hello'.rstrip('heo')" "hell")
   ("'\thello\t  '.rstrip()" "    hello")
   ("x = 'hello'"
    ("x.rstrip('hlo')" "he")))  
#+END_SRC
** lstrip
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform lstrip (obj &optional chars)
                         (string) -> (py-lstrip obj chars)
                         (_)      -> (call-method obj lstrip chars))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-lstrip (s &optional chars)
    "S.lstrip([chars]) -> str
  
  Return a copy of the string S with leading whitespace removed.
  If chars is given and not None, remove characters in chars instead."
    (pyel-strip-left s chars))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   lstrip-method
   ("'hello'.lstrip('heo')" "llo")
   ("'\thello\t  '.lstrip()" "hello         ")
   ("x = 'hello'"
    ("x.lstrip('hlo')" "ello")))
#+END_SRC
** rsplit
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform rsplit (obj &optional sep maxsplit)
                         (string) ->  (pyel-rsplit obj sep maxsplit)
                         (_)    ->  (call-method obj rsplit sep maxsplit))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-rsplit (string &optional sep maxsplit)
    (pyel-split string sep maxsplit)) ;;TODO: properly implement this
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   rsplit-method
   ("x = 'a b c'
  y = x.rsplit()"
    ("y" '("a" "b" "c")))
   ("'a b c'.rsplit()" '("a" "b" "c"))
   ("y = 'a x b x d x'.rsplit()"
    ("y" '("a" "x" "b" "x" "d" "x"))
    ("len(y)" 6)))
#+END_SRC
** partition
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform partition (obj sep)
                         (string) ->  (py-partition obj sep)
                         (_)    ->  (call-method obj partition sep))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-partition (s sep)
    "S.partition(sep) -> (head, sep, tail)
  
  Search for the separator sep in S, and return the part before it,
  the separator itself, and the part after it.  If the separator is not
  found, return S and two empty strings."
    (if (string-match (format "^\\(.*\\)%s\\(.*\\)$" (regexp-quote sep))  s)
        (vector (match-string 1 s) sep (match-string 2 s))
      (vector s "" "")))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   partition-method
   ("'abcdefghi'.partition('c')" ["ab" "c" "defghi"])
   ("'abcdefghi'.partition('cde')" ["ab" "cde" "fghi"])
   ("'abcdefghi'.partition('x')" ["abcdefghi" "" ""])
   ("'x'.partition('x')" ["" "x" ""])
   ("x = 'abcdefghi'"
    ("x.partition('c')" ["ab" "c" "defghi"])))
#+END_SRC
** rpartition
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform rpartition (obj sep)
                         (string) ->  (py-rpartition obj sep)
                         (_)      ->  (call-method obj rpartition sep))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defalias 'py-rpartition 'py-partition)
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   rpartition-method
   ("'abcdefghi'.rpartition('c')" ["ab" "c" "defghi"])
   ("'abcdefghi'.rpartition('cde')" ["ab" "cde" "fghi"])
   ("'abcdefghi'.rpartition('x')" ["abcdefghi" "" ""])
   ("'x'.rpartition('x')" ["" "x" ""])
   ("x = 'abcdefghi'"
    ("x.rpartition('c')" ["ab" "c" "defghi"])))
#+END_SRC
** rjust
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform rjust (obj width &optional fillchar)
                         (string) -> (py-rjust obj width fillchar)
                         (_)      -> (call-method obj rjust width fillchar))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-rjust (str width &optional fillchar)
    "S.rjust(width[, fillchar]) -> str
  
  Return S right-justified in a string of length width. Padding is
  done using the specified fill character (default is a space)."
    (if (> (length fillchar) 1)
        (py-raise (TypeError
                   "The fill character must be exactly one character long")))
    (let ((diff (- width (length str)))
          (fillchar (or fillchar " ")))
      (if (> diff 0)
          (concat (make-string diff (string-to-char fillchar)) str)
        str)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   rjust-method
   ("'hi'.rjust(10)"  "        hi")
   ("'hi'.rjust(7, '_')" "_____hi")
   ("'hi'.rjust(10)" "        hi")
   ("'hi'.rjust(3, '_')" "_hi")
   ("'hi'.rjust(7, '_')" "_____hi")
   ("'hisldkjf'.rjust(3, '_')" "hisldkjf")
   ("x = 'ab'"
    ("x.rjust(10)" "        ab")))  
#+END_SRC
** ljust
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform ljust (obj width &optional fillchar)
                         (string) -> (py-ljust obj width fillchar)
                         (_)      -> (call-method obj ljust width fillchar))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-ljust (str width &optional fillchar)
  "S.ljust(width[, fillchar]) -> str
  
  Return S left-justified in a Unicode string of length width. Padding is
  done using the specified fill character (default is a space)."
    (if (> (length fillchar) 1)
        (py-raise (TypeError
                   "The fill character must be exactly one character long")))
    (let ((diff (- width (length str)))
          (fillchar (or fillchar " ")))
      (if (> diff 0)
          (concat str (make-string diff (string-to-char fillchar)))
        str)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   ljust-method
   ("'hi'.ljust(10)"  "hi        ")
   ("'hi'.ljust(7, '_')" "hi_____")
   ("'hi'.ljust(10)" "hi        ")
   ("'hi'.ljust(3, '_')" "hi_")
   ("'hi'.ljust(7, '_')" "hi_____")
   ("'hisldkjf'.ljust(3, '_')" "hisldkjf")
   ("x = 'ab'"
    ("x.ljust(10)" "ab        ")))    
#+END_SRC
** rfind
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform rfind (obj sub &optional start end)
                         (string) -> (py-rfind obj sub start end)
                         (_)      -> (call-method obj rfind sub start end))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun pyel-reverse-string (string)
    (let ((start 0)
          (end (1- (length string)))
          tmp)
      (while (< start end)
        (setq tmp (aref string start))
        (aset string start (aref string end))
        (aset string end tmp)
        (setq start (1+ start)
              end (1- end)))
      string))
  
  (defun py-rfind(str sub &optional start end)
    "S.rfind(sub[, start[, end]]) -> int
  
  Return the highest index in S where substring sub is found,
  such that sub is contained within S[start:end].  Optional
  arguments start and end are interpreted as in slice notation.
  
  Return -1 on failure."
    (let* ((start (or start 0))
           (index (string-match
                   (pyel-reverse-string (regexp-quote sub))
                   (pyel-reverse-string (substring str start end)))))
      (if index
          ;;(+ index start)
          (- (length str)  index (length sub))
        -1)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests
   rfind-method
   ("'aaaxaaa'.rfind('x',3)"  3)
   ("'aaaxaaa'.rfind('x',4)"  -1)
   ("'aaaxaaa'.rfind('x',2, 4)"  3)
   ("'aaaxaaa'.rfind('x',1, 3)"  -1)
   ("'abcxebdxebdexed'.rfind('xe')" 12)
   ("x = 'asdf'
  y = 'abxabxab'"
    ("x.rfind('sd')" 1)
    ("y.rfind('ab')" 6)))
#+END_SRC
** rindex
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform rindex (obj sub &optional start end)
                         (string) -> (py-rindex obj sub start end)
                         (_)      -> (call-method obj rindex sub start end))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-rindex (str sub &optional start end)
    "S.rindex(sub[, start[, end]]) -> int
   
   Like S.rfind() but raise ValueError when the substring is not found.  "
    (let ((ret (py-rfind str sub start end)))
      (if (= ret -1)
          (py-raise (ValueError "substring not found"))
        ret)))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
    
#+END_SRC
** replace
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform replace (obj old new &optional count)
                         (string) -> (py-replace obj old new count)
                         (_)      -> (call-method obj replace old new count))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-string-replace (string old new &optional count)
    "Return a copy of STRING with all occurrences of substring
  OLD replaced by NEW.  If the optional argument COUNT is
  given, only the first COUNT occurrences are replaced."
    ;;based on `replace-regexp-in-string'
  
    ;; To avoid excessive consing from multiple matches in long strings,
    ;; don't just call `replace-match' continually.  Walk down the
    ;; string looking for matches of REGEXP and building up a (reversed)
    ;; list MATCHES.  This comprises segments of STRING which weren't
    ;; matched interspersed with replacements for segments that were.
    ;; [For a `large' number of replacements it's more efficient to
    ;; operate in a temporary buffer; we can't tell from the function's
    ;; args whether to choose the buffer-based implementation, though it
    ;; might be reasonable to do so for long enough STRING.]
    (let ((case-fold-search nil)
          (replaced 0)
          (l (length string))
          (start 0)
          matches str mb me)
      (save-match-data
        (while (and
                (or (null count) (< replaced count))
                (< start l)
                (string-match old string start))
          (setq replaced (1+ replaced)
                mb (match-beginning 0)
                me (match-end 0))
          ;; If we matched the empty string, make sure we advance by one char
          (when (= me mb) (setq me (min l (1+ mb))))
          ;; Generate a replacement for the matched substring.
          ;; Operate only on the substring to minimize string consing.
          ;; Set up match data for the substring for replacement;
          ;; presumably this is likely to be faster than munging the
          ;; match data directly in Lisp.
          (string-match old (setq str (substring string mb me)))
          (setq matches
                (cons (replace-match new
                                     nil nil str)
                      (cons (substring string start mb) ; unmatched prefix
                            matches)))
          (setq start me))
        ;; Reconstruct a string from the pieces.
        (setq matches (cons (substring string start l) matches)) ; leftover
        (apply #'concat (nreverse matches)))))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
    
#+END_SRC
** clear
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform clear (obj)
                         (hash) -> (py-hash-table-clear obj)
                         (_)      -> (call-method obj clear))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-hash-table-clear (ht)
    "Remove all items from hash table HT"
    (maphash (lambda (key value)
               (remhash key ht))
             ht))
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
    
#+END_SRC
** fromkeys
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform fromkeys(obj keys &optional value)
                           (hash _ _) -> (py-fromkeys keys value)
                           (_)      -> (call-method obj fromkeys keys value))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-fromkeys (keys &optional value)
    (let* ((len (length keys))
           (ht (make-hash-table :size len :test 'equal))
           (type (type-of keys))
           (i 0))
      (cond ((eq type 'cons)
             (while keys
               (puthash (car keys) value ht)
               (setq keys (cdr keys))))
            ((eq type 'string)
             (while (< i len)
               (puthash (substring keys i (1+ i)) value ht)
               (setq i (1+ i))))
            ((eq type 'vector)
             (while (< i len)
               (puthash (aref keys i) value ht)
               (setq i (1+ i)))
             )
            (t (error "py-fromkeys: invalid type for parameter 'keys'")))
      ht))  
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
    
#+END_SRC
** isprintable
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform isprintable (obj)
                         (string) -> (py-isprintable obj)
                         (_)      -> (call-method obj isprintable))
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defconst py-printable "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c")
  
  (setq py-printable-ht (make-hash-table :test 'equal
                                         :size (* (length py-printable) 2)))
  (py-for c in py-printable
          (puthash c t py-printable-ht))
  
  ;;TODO: perhaps examining ascii values will be faster
  (defun py-isprintable(s)
    "S.isprintable() -> bool
  
  Return True if all characters in S are considered
  printable in repr() or S is empty, False otherwise."
    (let ((good t)
          (len (length s))
          (i 0))
      (while (and good (< i len))
        (if (not (gethash (pyel-string-nth s i) py-printable-ht))
            (setq good nil))
        (setq i (1+ i)))
      good))
  
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
    
#+END_SRC
** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC
* macro transforms
macros and macroish primitives
** cond
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  ;;;;errors with these
  ;; (pyel-create-tests cond
  ;;                    "x = cond([1 > 2, 'first']
  ;;    [2 == 2, 'second']
  ;;    [5 == 7, 'third']
  ;;    [True, error('wtf')])
  ;; assert x == 'second'"
  ;;                    )
#+END_SRC
** lambda
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  ;;;;Errors with these
  ;; (pyel-create-tests lambda
  ;;                    "x = [2,3,4]
  ;; square = lambda([x]
  ;;  x*x)
  ;; y = mapcar(square,x)
  ;; assert y == [4,9,16]
  ;; "
  ;;                    "f = lambda([x,y]
  ;; if x > y:
  ;;  'x'
  ;; else:
  ;;  'y')
  ;; x=cl_mapcar(f, [1, 2, 3, 4, 5], [4, 2, 1, 6, 3])
  ;; assert x == ['y', 'y', 'x', 'y', 'x']")
#+END_SRC
** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp:tangle py-lib.el

#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC


* ---------------------
* misc
#+Begin_SRC emacs-lisp :tangle pyel.el
  
  (defmacro pyel-string-nth (string index)
    (list 'substring string index
          (if (numberp index) (1+ index) (list '1+ index))))
  
  (defsubst pyel-nth (n seq)
    (let ((tp (type-of seq)))
      (cond ((eq tp 'cons)
             (nth n seq))
            ((eq tp 'vector)
             (aref seq n))
            ((eq tp 'string)
             (substring seq n (1+ n))))))
  
  (defun char-split-string (string)
    "split a string into its charaters"
    (cdr (butlast (split-string string ""))))
  
  
  (defun strip-end (string &optional char)
    "if CHAR occurs at the end of STRING, remove it"
    (let ((split (char-split-string string))
          (char (or char " ")))
      
      (while (string= char (car (last split)))
        (setq split (butlast split)))
      (mapconcat 'identity split "")))
  
  (defun strip-start (string &optional char)
    "if CHAR occurs at the beginning of STRING, remove all occurrences"
    (let ((split (char-split-string string))
          (char (or char " ")))
      
      (while (string= char (car split))
        (setq split (cdr split)))
      (mapconcat 'identity split "")))
  
  ;;built-in equivalent?
  (defun file-path-concat (&rest dirs)
    "concatenate strings representing file paths
  prevents multiple/none '/' seporating file names"
    (let* ((first (strip-end (car dirs) "/"))
           (last (strip-start (car (last dirs)) "/"))
           (dirs (append (list first)
                         (mapcar '(lambda (x)  (strip-start (strip-end x "/") "/"))
                                 (cdr (butlast dirs)))
                         (list last))))
      (mapconcat 'identity dirs "/")))
  
#+END_SRC

* EOF
** main
#+Begin_SRC emacs-lisp :tangle pyel.el
  (require 'transformer)
  (require 'pyel-transforms)
  (require 'pyel-tests-generated)
  (require 'pyel-preprocessor)
  
  (require 'py-objects)
  (require 'pyel-mode)
  (require 'py-lib)
  (require 'pyel-testing)
  
  (pyel "this_fixes_a_bug") ;;prevents errors the first time pyel-run-tests is run
  ;;...I'm so sorry
  
  (provide 'pyel)
  ;;pyel.el ends here
#+END_SRC
** transforms
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(provide 'pyel-transforms)
;;pyel-transforms.el ends here
#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(provide 'pyel-tests)
;;pyel-tests.el ends here
#+END_SRC
** py-lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
(provide 'py-lib)
;;py-lib.el ends here
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
#py-ast.py ends here
#+END_SRC

* ------------------
* transform template
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC

** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* .emacs config (move)
#+Begin_SRC emacs-lisp :tangle pyel.el
(setq pyel-use-list-for-varargs t)
;;(setq pyel-directory "path/to/pyel/directory")
;;(require 'pyel)
#+END_SRC
