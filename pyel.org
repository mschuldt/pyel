* documentation
TODO: how to export a heading as pdf or into a seporate file?

TODO: update most of this. tranforms have changed
** type switches
 pyel-switch forms are inserted in a backquoted form so an ',' unquote
 may be used. DO NOT UNQUOTE THE ARGUMENTS, they will be replaced later

** from py ast to e-lisp transform
#+Begin_SRC emacs-lisp 
  ;;First, get the python ast:
  (py-ast "(a,b)")
  "Module(body=[Expr(value=Tuple(elts=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], ctx=Load()))])
  "
  
  ;;Second create any newly needed python AST interpretor.
  ;; Here we need Tuple(elts,ctx)
  
  def Tuple(elts, ctx):
      return l_str(["tuple ", ll_str(elts), ctx])
  
  ;;Third, define a tranform to convert the function to lisp
  (def-transform tuple pyel ()
    (lambda (elts ctx) ;;Ignoring ctx for now
      (concat "["
              (mapconcat 'transform elts " ")
              "]")))
  
  
  ;;Forth, create tests. Evaluate the expresstion, the test are sent to the kill ring
  (pyel-create-tests 'Tuple
                     "()"
                     "(a, b)"
                     "(a, (b, (c,d)))"
                     "((((((((a))))))))")
#+END_SRC  
** ways to define new transforms
TODO:
 how to define a macro transform

*** change a function name
Example:
#+Begin_SRC emacs-lisp 
(pyel-translate-function-name 'range 'py-range)
(pyel-translate-function-name 'map 'mapcar)o
#+END_SRC 
*** change a variable name
Example:
#+Begin_SRC emacs-lisp 
(pyel-translate-variable-name 'None 'nil)
#+END_SRC 
*** define a general translation
Example:
#+Begin_SRC emacs-lisp 
(def-transform assert pyel ()
    (lambda (test msg) 
      `(assert ,(transform test) t ,(transform msg))))
#+END_SRC 

*** define a method translation
$var replaces var with name of the original var
   (expands to ,var in the macro definition) 
 other parameter references are evaluated and assigned to tmp variables
#+Begin_SRC emacs-lisp 
(pyel-method-transform append (obj thing)
                  (list _) -> (setq $obj (append obj (list thing)))
                  (_ _)    -> (append obj thing))
#+END_SRC 

*** define a function translation
#+Begin_SRC emacs-lisp 
  (pyel-func-transform len (thing)
                       (object) -> (__len__ ,thing)
                       (_)      -> (length ,thing))
#+END_SRC 
*** type switching transforms
  (pyel-create-py-func ** (l r) ;;pow
                    (number number) -> (expt l r)
                    (object _ ) 
                    (_ object) -> (--pow-- l r))

*** declare a name to be a macro
(pyel-declare-macro "save_excursion")
** writing faster code
*** large difference
*** small difference
prevent pyel from converting *varargs to a vector. Instead manipulate it in python as if it were a list instead of a tuple like it normally is.
put the following line in your config:
  (setq pyel-use-list-for-varargs t)
  ==> NO! ALL CHANGES TO CODE TRANSFORMS SHOULD BE INDECATED IN THE PYTHON SOURCE

* headers
** main
#+Begin_SRC emacs-lisp :tangle pyel.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** transforms
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** py-lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  ;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  # This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org
#+END_SRC  

* main
header
** require 
#+Begin_SRC emacs-lisp :tangle pyel.el
  (add-to-list 'load-path "~/programming/pyel/")
  (add-to-list 'load-path "~/programming/code-transformer/")  
  (require 'eieio)
  (require 'cl) 
;;other requires are at the end
#+END_SRC

** main
 #+Begin_SRC emacs-lisp :tangle pyel.el
;; This is a tangled file  -- DO NOT HAND-EDIT -- 
;;PYEL -> translate PYthon to Emacs Lisp
#+END_SRC  

main
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defun mpp (code)
    (let ((pp (pp-to-string code)))
      (insert "\n" pp)))
  
  
  ;;TODO: more robust checking, return type of error as well
  (defun pyel-is-error (code)
    "return the line of the error in CODE, else nil"
    (let ((line))
      (if (string-match "^Traceback" code)
          (with-temp-buffer
            (insert code)
            (goto-char (point-max))
            (if (re-search-backward "line \\([0-9]+\\)")
                (setq line (match-string 1)))))
      ;;TODO: why is this the actual line number...it should be relative the a bunch of code it's appended to ...
      (and line (string-to-number line))))
  
  (defvar pyel-transform-status nil
    "indicate status (success/fail) of last pyel transform
  status types:
  nil for no error
  ('python ast transform error'  <line number>) 
  ")
  
  (defvar pyel-error-string "PYEL ERROR"
    "string returned by `pyel' when it failed to transform")
  
  (defun pyel-py-ast-file-name ()
    "return the full file name of py-ast.el"
    (file-path-concat pyel-directory "py-ast.py"))
  
  
  (defun pyel (python &optional py-ast-only include-defuns)
    "translate PYTHON into Emacs Lisp.
  PYTHON is a string.
  If PY-AST-ONLY, return the un-evaled ast.
  If INCLUDE-DEFUNS, include the list of pyel defined functions in the output
    this is ignored if PY-AST-ONLY is non-nil"
    (assert (eq lexical-binding nil) "pyel requires dynamic scoping")
    
    (setq pyel-marked-ast-pieces nil)
    (setq pyel-transform-status nil) ;;so far so good...
  
    (let* (;;Q general way of replacing backslashes?
           (python (replace-regexp-in-string "\"" "\\\\\"" python))
           ;(python (replace-regexp-in-string "\n" "\\\\n" python nil :literal))
           
           ;; (pyel "x = 'x\n'")
          (py-ast "")
          (el-code "")
          (current-transform-table (get-transform-table 'pyel))
          (python (with-temp-buffer
                    (insert python)
                    (pyel-preprocess-buffer2)
                    (buffer-string)))
          (pyel-context nil)
          line ret
          )
      
      ;;?? setting the mark?
      (with-temp-buffer
        ;;    (find-file file)
        ;;    (erase-buffer)
        (insert-file-contents-literally (pyel-py-ast-file-name))
        (goto-char (point-max))
        (insert "\n")
        (setq line (line-number-at-pos))
        (insert (format "print(eval(ast.dump(ast.parse(\"\"\"%s\"\"\"))))" python))
        (write-region
         nil
         nil
         pyel-tmp-file nil 'silent))
      
      (setq py-ast (shell-command-to-string (format "python3 %s" pyel-tmp-file)))
  
      (if (setq py-error (pyel-is-error py-ast))
          (progn
            (setq pyel-python-error-line py-error)
            pyel-error-string)
          ;;else: no error
      (if py-ast-only
          py-ast
        ;;      (pyel-do-splices (transform (read py-ast))))))
        ;;read can only return one sexp so we need to put it in a progn or something
        ;;similar
        
        (setq ret (pyel-do-splices (if include-defuns
                             (list '@ (cons '@ pyel-function-definitions)
                                      (transform (read (format "(@ %s)" py-ast))))
                           (transform (read  (format "(@ %s)" py-ast))))))
        ;;TODO: this is a temp solution for convenience
        (mapc 'eval pyel-function-definitions) 
        ret
        ))))
  
  
  (defun pyel-buffer-to-string (&optional ast-only)
    "transform python in current buffer and return a string"
    ;;THIS DOES NOT RETURN A STRING!
    (pyel (buffer-string) ast-only))
  
  
  (defvar pyel-pp-function 'pp-to-string
        "function that pretty prints pyel e-lisp code")
        
  (defun pyel-buffer (&optional out-buff)
    "transform python in current buffer and display in OUT-BUFF,
  OUT-BUFF defaults to *pyel-output*"
    (interactive)
    (let ((out (pyel-buffer-to-string)))
      (switch-to-buffer-other-window "*pyel-output*")
      (erase-buffer)
      (insert (funcall 'pyel-pp-function out))
      (emacs-lisp-mode)))
  
  (defun pyel-transform-ast (ast &optional no-splice)
    "transform a python AST to Emacs Lisp, AST must be a string
  AST can be generated by `pyel' with (pyel py-string t)"
    (with-transform-table 'pyel
                          (let ((code (transform (read  (format "(@ %s)" ast)))))
                            (if no-splice
                                code
                              (pyel-do-splices code)))))
  
  
  (defun pyel-file-ast (file-name)
    "return the ast from .py file FILE-NAME"
    )
        
  (defmacro pyel-with-known-types (known-types &rest code)
    "translate CODE while faking the known types"
    `(flet ((pyel-get-possible-types
             (&rest args)
             (mapcar* (lambda (arg type) (cons arg type))
                      args ,known-types)))
       
       (pyel ,@code)))
  
  
  (defun py-ast (code &optional pp)
    "Return the python abstract syntax tree for python CODE"
    (let ((py-ast "")
          (el-code "")
          ret)
      
      (with-temp-buffer
        (insert "import ast" "\n")
        (insert (format "print(ast.dump(ast.parse(\"\"\"%s\"\"\")))" code))
        (write-region nil nil pyel-tmp-file nil 'silent))
      
      (setq ret (shell-command-to-string (format "python3 %s" pyel-tmp-file)))
      (if pp
          (mapconcat 'identity (split-string ret ",") ",\n")
        ret)))
  
  
  ;;'(a (@ b (c)))) => (a b (c))
  ;;'(a (@ b c)))   => (a b c)
  ;;'(@ a b c) => (progn a b c)
  ;;'(@ (a b)) = > (a b)
  ;;'(a (@) b) = > (a b)
  
  (defun pyel-do-splices (code)
    (if (listp code)
        (let (c)
          (if (eq (car code) '@) ;;special case: outer most list 
              (if (> (length code) 2)
                  (pyel-do-splices `(progn ,code))
                (pyel-do-splices (cadr code)))
            (let ((ncode nil))
              (while code
                (setq c (pop code))
                (if (listp c)
                    (if (equal (car c) '@)
                        (setq ncode (append (reverse (pyel-do-splices (cdr c))) ncode))
                      (push (pyel-do-splices c) ncode))
                  (push c ncode)))
              (if (listp ncode) (reverse ncode) ncode))))
      code))
  
  
  
  (defun pyel-reload ()
      (interactive)
      (dolist (f '(pyel
                   pyel-tests
                   pyel-transforms
                   pyel-mode
                   pyel-pp
                   pyel-preprocessor
                   transformer))
        (setq features (remove f features)))
      (require 'pyel))
  
  
  (defun pyel-method-transform-name(method-name)
    "return the name of the temlate that transform the method METHOD-NAME.
  template names are modified to avoid potential conflict with other templates"
    (intern (format "_%s-method_" (symbol-name method-name))))
  
  
  (defun pyel-func-transform-name (func-name)
    "like `pyel-method-transform-name' for functions"
    (intern (format "_%s-function_" (symbol-name func-name))))
  
  
  
  (defmacro push-back (val place)
    "Add VAL to the end of the sequence stored in PLACE. Return the new
  value."
    `(setq ,place (append ,place (list ,val))))
  
  (defun pyel-translate-function-name (name new-name)
    "translate python NAME to e-lisp NEW-NAME"
    (push (list name new-name) pyel-function-name-translations))
  
  (defun pyel-translate-variable-name (name new-name)
    "translate python  NAME to e-lisp NEW-NAME"
    (push (list name new-name) pyel-variable-name-translations))
  
  
  (defun pyel-not-implemented (message)
    "signify that a feature is not implemented"
    ;;TODO
    (message message) ;;tmp
    )
  
  
  (defmacro insert-at (list nth value)
    "insert VALUE at NTH index in LIST"
    `(setq ,list (append (subseq ,list 0 ,nth)
                         (list ,value)
                         (subseq ,list  ,nth))))
  
  (defun list-to-vector (list)
    (eval `(vector ,@list))) ;;this is gross
  
  
  (defun _to- (thing)
    (cond
     ((stringp thing)
  
      (replace-regexp-in-string "_" "-"  thing))
     ((symbolp thing)
      (intern (replace-regexp-in-string "_" "-"  (symbol-name thing))))
     ((listp thing) (mapcar '_to- thing))
     (t (error "ERROR in _to-. invalid thing"))))
  
  
  (defun pyel-change-ctx (form ctx)
    "change ctx of form to CTX"
    (let ((type (and (listp form) (car form))))
      (cond ((eq type 'name)
             (list (car form) (cadr form) (list 'quote ctx)))
            ;;TODO: attribute and other forms (if needed)
            (t form))))
  
  
  (defun pyel-make-ast (type &rest args)
    "Generate pyhon ast.
  This is used when the ast form is needed by a transform that is manually
   called from another transform"
    (flet ((assert_n_args (type expect have)
                          (assert (= expect have)
                                  (format "pyel-make-ast -- ast type '%s'expects %s args. received %s args" type expect have)))
           (correct_ctx (ctx)
                        (if (symbolp ctx)
                            (pyel-make-ast ctx)
                          ctx))
           (correct_to_string (name)
                              (if (stringp name)
                                  name
                                (if (symbolp name)
                                    (symbol-name name)
                                  (error "invalid type for 'name'")))))
      
      ;;TODO: should have seporate functions to check
      ;;      the validity of the ast instead of having
      ;;      the correction functions do it
      (case type
        
        (subscript ;;args: value slice ctx
         (assert_n_args 'subscript 3 (length args))
         
         (let ((ctx (correct_ctx (car (last args)))))
           (list 'subscript (car args) (cadr args) ctx)))
        
        (name ;;args: name ctx
         (assert_n_args 'name 2 (length args))
         (let* ((name (correct_to_string (car args)))
                
                (ctx (correct_ctx (car (last args)))))
           
           (list 'name name ctx)))
        
        (load
         '(quote load))
        (store
         '(quote store)))))
#+END_SRC


** variables
#+Begin_SRC emacs-lisp :tangle pyel.el
    
    (defvar pyel-directory ""
      "Path to pyel files. must include py-ast.py, pyel.el etc")
    
    
    (defvar pyel-type-test-funcs '((string stringp)
                                   (number numberp)
                                   (integer integerp)
                                   (int integerp)
                                   (float floatp)
                                   (vector vectorp)
                                   (list listp)
                                   (cons consp)
                                   (hash hash-table-p)
                                   (hash-table hash-table-p)
                                   (symbol symbolp)
                                   (array arrayp)
                                   (object object-p)
                                   (function functionp)
                                   (func functionp))
      
      "alist of types used in pyel-call-transform for the switch-type
        and the function used to test for that type")
    
    
    (defvar pyel-defined-classes nil
      "list of call class names defined by pyel")
    
    
    
    (defvar pyel-defined-functions nil
      "list of some functions defined pyel
      used by some templates to determine if a needed function has been defined yet")
    
    (defvar pyel-function-definitions nil
      "used to store function definitions created by pyel, not the user.")
    
    (defvar pyel-replace-args nil
      "if non-nil, pyel-do-call-transform will replace the arg symbols with their
      value, used if the code is to be inlined
      TODO: the option to replace the args should probably be obsoletede")
    
    (defvar pyel-unique-obj-names nil
      "if non-nil, uniquely name object instantces")
    
    
    (defvar pyel-context-groups nil ;;TODO: still used?
      "groups of contexts that cannot exist at the same time.
    `context-p' will stop at the first one in the list,")
    
    (setq pyel-context-groups
          '((assign-target assign-value)))
    
    (defvar pyel-function-name-translations nil
      "alist of function name translations, python->e-lisp.
    
    Entries in `pyel-function-name-translations' are applied before
    checking for function transforms.
    If a translation len->length is defined then the function transform for
    'len' will not be detected because the name is now 'length'
    ")
    
    (defvar pyel-variable-name-translations nil
      "alist of variable name translations, python->e-lisp.")
    
    (setq pyel-function-name-translations `(
                                            
                                            ))
    ;;TODO: list, vector, etc
    ;;      map?               
    
    (setq pyel-variable-name-translations '((True t)
                                            (False nil)
                                            (None nil)))
    
    (defvar pyel-method-transforms nil
      "List of names of methods for which a transform has been defined
    For internal use only--do not modify by hand"
      )
    
    (defvar pyel-func-transforms nil
      "list of function names that have transforms defined for them")
    
    
    (defconst pyel-nothing '(@)
      "value to return from a function/transform when it should
    not contribute to the output code")
    
    (defconst pyel-python-version "3.2.3"
      "python interpreter version whose ast pyel is written for")
    
    
    
    (defvar test-variable-values nil
      "variables values for running tests")
    
    
    (setq test-variable-values
          '((pyel-defined-classes nil)
            (pyel-function-definitions nil)
            (pyel-defined-functions nil)
            (pyel-obj-counter 0)
            (pyel-unique-obj-names nil)
            ;;(pyel-method-transforms nil)
            ;;(pyel-func-transforms nil)
            (pyel-marker-counter 0)
            (known-types ((number list vector string object hash function)
                          (number list vector string object hash function)
                          (number list vector string object hash function)
                          (number list vector string object hash function)
                          (number list vector string object hash function)
                          (number list vector string object hash function)
                          (number list vector string object hash function)
                          (number list vector string object hash function)
                          (number list vector string object hash function)
                          (number list vector string object hash function)))))
    
    
    (defvar pyel-marker-counter 0)
    
  (defvar pyel-tmp-file  "/tmp/pyel-ast.py"
    "Name of temp file to use for AST generation")
    
#+END_SRC  
** syntax output variables
variables that effect the form of the output code
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defvar pyel-default--init--method
      "(defmethod --init-- ((self %s))
       \"Default initializer\"
      )"
      
      "default initializer for pyel objects.")
  
    (defvar pyel-use-list-for-varargs nil
        "Determines if *varargs will be passed to function as a list or a vector,
    non-nil for list, otherwise vector.
    To be like python (vectors), this should be nil
    To be consistent with Emacs-Lisp (lists), this should be t.
       On the python side, this means that *varargs is a list instead of a tuple")
#+End_SRC
** pyel-block
This will have to be removed after the code is generated
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defmacro pyel-block (&rest code)
    `(progn ,@ code))
#+END_SRC     
** context
#+Begin_SRC emacs-lisp :tangle pyel.el
  ;;TODO: this should be generalized and added to the transform code
  (defvar pyel-context nil
    "list of current expansion contexts")
  
  (defmacro using-context (context &rest code)
    `(progn
       (push ',context pyel-context)
       (let ((ret (progn ,@code)))
         (pop pyel-context)
         ret)))
  (def-edebug-spec using-context (symbolp &rest form))
  
  
  (defmacro remove-context (context &rest code)
    "remove CONTEXT and translate CODE, then restore context"
    `(let ((pyel-context (remove ',context pyel-context)))
       ,@code))
  
  (defmacro context-switch (&rest forms)
    `(cond ,@(mapcar (lambda (x)
                       `(,(let ((context (car x)))
                            (if (eq context t) t
                              `(member ',context pyel-context))) ,@(cdr x)))
                     forms)))
  
  
  
  (defun get-context-group (context)
    (let ((groups pyel-context-groups)
          (found nil)
          group)
      (while groups
        (setq group (car groups)
              groups (cdr groups))
        (dolist (g group)
          (when (equal g context)
            (setq found group
                  groups nil))))
      found))
  
  ;; (defun context-p (context)
  ;;   (member context pyel-context))
  (defun context-p (context)
      ;;;;TODO: the extra features that this provides is probably not being used anywere...
    (let ((group (get-context-group context))
          (cont pyel-context)
          (ret nil)
          c)
      (while cont
        (setq c (car cont)
              cont (cdr cont))
        ;;if the context is in a group only return t if it is the first one in pyel-context
        (if (member c group)
            (setq ret (equal c context)
                  cont nil)
          (when (equal c context)
            (setq ret t
                  cont nil))))
      ret))
  
  
  
  (defun context-depth (context)
    "get the depth of CONTEXT in `pyel-context'"
    ;;TODO:
    )
#+end_src

** type inference
#+Begin_SRC emacs-lisp :tangle pyel.el
  ;;this is all temp for testing
  (setq known-types '((number object ) (number string)))
  
  ;;prevents error: "Wrong type argument: listp, string"
  (setq known-types '((number list vector string object hash function)
                      (number list vector string object hash function)
                      (number list vector string object hash function)
                      (number list vector string object hash function)
                      (number list vector string object hash function)
                      (number list vector string object hash function)
                      (number list vector string object hash function)
                      (number list vector string object hash function)
                      (number list vector string object hash function)
                      (number list vector string object hash function)))
  
  (defun pyel-get-possible-types (&rest args)
    "return a list in the form (arg types).
    The car is the argument and the cdr is a list of possible types"
    
    ;;FOR TESTING
    (let ((types (if (>= (length known-types) (length args))
                     known-types
                   (append known-types '(string number list vector integer float))))
          (args (filter (lambda (x) (not (or (eq x '&optional)
                                             (eq x '&rest)))) args)))
      
      (mapcar* (lambda (arg type) (cons arg type))
               args types)))
#+end_src

** pyel-def-funcall related
#+Begin_SRC emacs-lisp :tangle pyel.el
  (defun pyel-filter-non-args(args)
    "remove '&optional' and '&rest' from ARGS list"
    (filter (lambda (x) (not (or (eq x '&optional)
                                 (eq x '&rest))))
            args))
  
    
  ;;TODO: have functions saved in another file,
  ;;      instead of putting them all at the top of the file, have some type of
  ;;      require/import mechanism to functions are not constantly being redefined
  ;;    option to place insert function defs instead of requires
  (defmacro pyel-create-py-func (name args &rest type-switches)
    "return the function name"
    ;;create a template that will resolve arg types and create a new function 
    
    ;;-determine if enough type info is available to eliminate testing
    ;;-if testing is necessary, use `pyel-do-call-transform' like function to generate
    ;; the testing and calling structure and put that in a function
    ;;-create defun code if not yet defined
    ;;  add new func name to defined code list
    
    ;;temp solution: does not check types etc
    (let* ((striped-args (mapcar 'strip_ args))
           (args-just-vars (pyel-filter-non-args striped-args))
           (rest-arg (if (eq (car (last striped-args 2)) '&rest)
                         (car (last striped-args)) nil)))
  
      `(def-transform ,name pyel ()
         (lambda ,striped-args
           (let ((fsym (intern (concat "pyel-" (symbol-name ',name) "")))
                 ;;      (body (pyel-do-call-transform (pyel-get-possible-types ,@(mapcar (lambda (x) `(quote ,x))args))
                 (body (pyel-do-call-transform (pyel-get-possible-types
                                                ,@args-just-vars)
                                               ',args
                                               ',type-switches))
                 (known-types nil)) ;;tmp
             (unless (member fsym pyel-defined-functions)
               (push (list 'defmacro fsym ',striped-args
                           body)
                     pyel-function-definitions)
               (push fsym pyel-defined-functions)
               (fset fsym (lambda () nil)))
             ;;(if (eq (car (last args 2)) '&rest)
                 
             ;; (cons fsym (mapcar 'eval ,(if rest-arg
             ;;                               `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
             ;;                             `(quote ,args-just-vars))))
             (cons fsym ,(if rest-arg
                            `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
                          (cons 'list args-just-vars)))
             )))))
  
  (defmacro pyel-method-transform (name args &rest type-switches)
    "define transforms for method calls on primative types"
    ;;method transforms are defined like normal type-transforms
    ;;when a method call is being transformed the name is looked up in the list
    ;;of defined method transforms, if it found, this transform will override
    ;;the normal transform.
    (add-to-list 'pyel-method-transforms name)
    ;;TODO: should name be modified to avoid conflicts ?
    `(def-transform ,(pyel-method-transform-name name) pyel () 
       (lambda ,args
         (let ((fsym (intern (concat "pyel-" (symbol-name ',name) "-method")))
               (body (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                             ',args
                                             ',type-switches))
               (known-types nil)) ;;tmp -- should this be before 'body' is set!!??
           
           (unless (member fsym pyel-defined-functions)
             (push (list 'defmacro fsym ',(mapcar 'strip_ args)
                         body)
                   pyel-function-definitions)
             (push fsym pyel-defined-functions)
             (fset fsym (lambda () nil)))
           (cons fsym (mapcar 'eval ',args))))))
  
  (defmacro pyel-func-transform (name args &rest type-switches)
    "define transforms for function calls"
    ;;function transforms are defined like normal type-transforms
    ;;when a function call is being transformed the name is looked up in the list
    ;;of defined function transforms, if it found, this transform will override
    ;;the normal function call transform.
    (add-to-list 'pyel-func-transforms name)
    ;;TODO: should name be modified to avoid conflicts ?
    `(def-transform ,(pyel-func-transform-name name) pyel () 
       (lambda ,args
         (let ((fsym (intern (concat "pyel-" (symbol-name ',name) "-function")))
               (body (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                             ',args
                                             ',type-switches))
               (known-types nil)) ;;tmp -- should this be before 'body' is set!!??
           
           (unless (member fsym pyel-defined-functions)
             (push (list 'defmacro fsym ',(mapcar 'strip_ args)
                         body)
                   pyel-function-definitions)
             (push fsym pyel-defined-functions)
             (fset fsym (lambda () nil)))
           (cons fsym (mapcar 'eval ',args))))))
  
  
  ;;TODO: this should be more general to allow for things like subscript to use it
  
  ;;TODO: rename pyel-def-funcall -> pyel-create-py-func
  (defmacro pyel-def-funcall (name args &rest type-switches)
    "Define how to call the function NAME.
        NAME is a function that is called differently based on its argument types.
        An attempt will be made to test the least possible number of types.
        
        This defines a transforms in the pyel transform table with NAME and ARGS"
    `(def-transform ,name pyel ()
       (lambda ,args
         (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                 ',args
                                 ',type-switches))))
  
  ;;TODO: rename pyel-def-funcall -> pyel-def-type-transform
  (defmacro pyel-def-type-transform (name args &rest type-switches)
    "Define a transform NAME that produces code based on the types of ARGS
      TYPE-SWITCHES
      
      This defines a transforms in the pyel transform table with NAME and ARGS"
    `(def-transform ,name pyel ()
       (lambda ,args
         (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                 ',args
                                 ',type-switches))))
  
  ;; (defmacro pyel-def-call-func (name args &rest type-switches)
  ;;   "like `pyel-def-call-template' except that it generates a macro that
  ;; is called directly, because of this NAME must be unique"
  ;;   `(defun ,name ,args
  ;;      ;;   (let (,(mapcar (lambda (arg) `(,arg ',arg)) args))
  ;;      (pyel-do-call-transform (pyel-get-possible-types ,@args)
  ;;                              ',args
  ;;                              ',type-switches)))
  
  
  (defun pyel-expand-type-switch (type-switch)
    "expands the types switch form to a list of cond clauses"
    (flet ((helper (arg form)
                   (let ((type (car form))
                         (varlist (cadr form))
                         mod types ret and-or)
                     (if (consp type)
                         (progn
                           ;;TODO: this can never be 'and'
                           (setq and-or (car type))
                           (dolist (tp (cdr type))
                             (push `((,arg ,tp) ,varlist) ret))
                           `(,and-or ,@(reverse ret)))
                       `((,arg ,type) ,varlist))))
           (expander (type-switch)
                     
                     
                     (let ((args (car type-switch))
                           (forms (cdr type-switch))
                           and-or ret inner tmp tests)
                       (if (consp args)
                           (progn
                             (setq and-or (car args)) ;;TODO: verify and/or
                             (if (eq and-or 'and)
                                 (dolist (form forms)
                                   (setq tests nil)
                                   (dolist (arg (cdr args))
                                     (push (car (helper arg form)) tests))
                                   (push `(and ,(reverse tests) ,(cadr form)) ret))
                               ;;else == or
                               (dolist (form forms)
                                 (dolist (arg (cdr args))
                                   (setq tmp (helper arg form))
                                   (if (equal (car tmp) 'or)
                                       (dolist (x (cdr tmp))
                                         (push x ret))
                                     (push (helper arg form) ret))))))
                         
                         ;;else single arg
                         (dolist (form forms)
                           (setq tmp (helper args form))
                           (if (equal (car tmp) 'or)
                               (dolist (x (cdr tmp))
                                 (push x ret))
                             (push tmp ret))))
                       (reverse ret))))
      (let ((ret nil))
        (dolist (ts type-switch)
          (dolist (e (expander ts))
            (push e ret)))
        (reverse ret))))
  
  
  ;;TODO: fix bug with  `pyel-expand-type-switch-2'
  ;;      the arg pattern (x x) should not expand unless
  ;;      x is a possible type of both args
  
  
  (defun pyel-expand-type-switch-2 (arglist patterns)
    "has output identical to `pyel-expand-type-switch' just translates
        different syntax"
    (let ((group nil) 
          (groups nil)
          (ngroups nil)
          (ret nil)
          code)
      
      
      ;;stage1: collect into groups
      (while patterns
        (setq p (pop patterns))
        
        (if (not (eq p '->))
            (push-back p group)
          (push-back (pop patterns) group)
          (push-back group groups)
          (setq group nil)))
      
      (dolist (g groups)
        (let* ((g (reverse g))
               (code (car g))
               (g (cdr g))
               ;;      (param-types (make-vector (length (car g)) nil))
               type)
          
          (dolist (arg-pattern (reverse g)) ;;for each arg pattern
            (setq group-patterns nil)
            (dotimes (i (length arg-pattern)) ;;for each type or '_
              (setq type (nth i arg-pattern))
              (if  (not (eq type '_))
                  (push `((,(nth i arglist) ,type) ,code) group-patterns)))
            (if (null group-patterns) ;;all types where _
                (setq ret (append ret (list (list t code))))
              (if (= (length group-patterns) 1)
                  (setq ret (append ret (reverse group-patterns)))
                (setq ret (append ret (list (cons 'and 
                                                  (list (mapcar 'car
                                                                (reverse group-patterns))
                                                        code))))))))))
      ret))
  
  
  (defun pyel-do-call-transform (possible-types args type-switch)
    "This is responsible for  producing a call to NAME in the most
        efficient way possible with the known types"
    (let* ((possible-types (let ((ret nil)
                                 arg)
                             ;;get entries in form (arg . type)
                             (dolist (p-t possible-types)
                               (setq arg (car p-t))
                               (dolist (type (cdr p-t))
                                 (push (cons arg type) ret)))
                             ret))
           (c 0)
  
           (args-just-vars (pyel-filter-non-args (mapcar 'strip_ args)))
           (new-args (loop for a in args ;;doing: check for leading underscore
                           collect (if (or (eq a '&optional)
                                           (eq a '&rest)
                                           (string-match-p "\\(^_\\)\\(.+\\)"
                                                           (symbol-name a))) nil
                                       (intern (format "__%s__" (symbol-name a))))))
           ;;list of symbols to replace
           ;;format: (symbol replace)
           (let-vars (let (lv) (mapcar* (lambda (a b) (if b
                                                          (push (list a b) lv)))
                                        args-just-vars new-args)
                          lv))
           ;;strip any leading underscores
           (args (mapcar (lambda (a)
                              (if (string-match "\\(^_\\)\\(.+\\)" (symbol-name a))
                                (intern (match-string 2 (symbol-name a))) a))
                                args))
                       
           ;;the __x__ type replacements interfere with the (\, x) type replacements
           ;;so they must be seporated and done one at a time
           (arg-replacements1 let-vars)
           (arg-replacements2 (mapcar (lambda (x)
                                        (list  (intern (format "$%s" x)) (list '\, x)))
                                      args-just-vars))
           (arg-replacements3 (mapcar (lambda (x)
                                        (list (intern (format "$$%s" x)) (list 'quote (list '\, x))))
                                      args-just-vars))
           (arg-replacements (append arg-replacements1 arg-replacements2))
  
           (current-replace-list nil)
           ;; (arg-replacements (append let-vars
           ;;                           (mapcar (lambda (x)
           ;;                                     (list  (intern (format "$%s" x)) (list '\, x)))
           ;;                                   args)))
           
           (ts ) ;;??
           (valid nil) ;;list of valid arg--types
           (found nil)
           (lets nil)
           var value type all-good var-vals len)
      ;;        (print "possible types = ")
      ;;        (print possible-types)
      
      
      ;;collect all the arg-type--code pairs that are valid possibilities,
      ;;that is, members of possible-types.
      ;;This essentially throws out all the arg types that have been ruled out.
      (dolist (t-s (pyel-expand-type-switch-2 args-just-vars type-switch))
        (if (equal (car t-s) 'and)
            (progn (setq all-good t
                         found nil)
                   (dolist  (x (cadr t-s)) ;;for each 'and' member type-switch
                     (dolist (pos-type possible-types) ;;for each arg type
                       (if (and (equal (eval (car x)) (car pos-type)) 
                                (equal (cadr x) (cdr pos-type)))
                           (setq found t)))
                     (setq all-good (if (and all-good found) t nil)))
                   (when all-good
                     (push t-s valid)))
          ;;else
          (if (eq (car t-s) t) ;;when all types are _
              (push t-s valid)
            ;;otherwise check if the type is one of the valid types
                 
            (setq _xx t-s)
            (dolist(pos-type possible-types)
              (when (and (equal (eval (caar t-s)) (car pos-type))
                         (equal (strip$ (cadar t-s)) (cdr pos-type)))
                (push t-s valid))))));;TODO: break if found?
      
      
      
      ;;generate code to call NAME
      ;;if there is 2 posible types, use IF. For more use COND
      (setq len (length valid))
      
      (flet ((replace (code replacements)
                      (let ((ret nil)
                            found)
                        
                        (dolist (c code)
                          (setq found nil)
                          (dolist (r replacements)
                            (if (consp c)
                                (setq c (replace c replacements))
                              (if (and (equal c (car r))
                                       (not found))
                                  (progn (push (cadr r) ret)
                                         (setq found t)))))
                          (unless found
                            (push c ret)))
                        (reverse ret)))
  
             (type-tester (x) (cadr (assoc x pyel-type-test-funcs)))
             (and-type-tester (x) (cadr (assoc (car x) pyel-type-test-funcs)))
             ;;(get-replacement (arg) ;;returns arg replacement
             ;;                 (cadr (assoc arg arg-replacements)))
             (get-replacement (arg) ;;returns arg replacement
                              (cadr (assoc arg current-replace-list)))
  
             ;;bug fix maybe...
             (get-replacement-OLD (arg) ;;returns arg replacement
                                  (cadr (assoc arg arg-replacements)))
  
             ;;replaces the vars, one type at a time
             (replace-vars (code)
                           (let* ((current-replace-list arg-replacements1)
                                  (code (replace code arg-replacements1))
                                  (current-replace-list arg-replacements2)
                                  (code (replace code arg-replacements2))
                                  (current-replace-list arg-replacements3))
                             (replace code arg-replacements3)))
             
             (gen-cond-clause (t-s--c) ;;Type-Switch--Code
                              (if (equal (car t-s--c) 'and)
                                  (progn (setq __x t-s--c)
                                         `((and ,@(mapcar '(lambda (x)
                                                             ;;TODO: test
                                                             `(,(type-tester (cadr x))
                                                               ,(get-replacement-OLD
                                                                 (car x))))
                                                          (cadr t-s--c)))
                                           ,(replace-vars (caddr t-s--c))))
                                
                                ;;TODO
                                (progn (setq __x t-s--c)
                                       (if (equal (car t-s--c) t) ;;all types where _
                                           `(t ,(replace-vars (cadr t-s--c)))
                                         (let* ((str (symbol-name (cadar t-s--c)))
                                                (quote-arg-p (string-match-p "\\(^\\$\\)\\(.+\\)"
                                                                             str))
                                                (type (if quote-arg-p (intern (match-string 2 str)) (cadar t-s--c)))
                                                (tester (type-tester type))
                                                (body (replace-vars (cadr t-s--c)))
                                                (arg (get-replacement-OLD (caar t-s--c))))
                                           `((,tester ,(if quote-arg-p (list 'quote (list '\, (caar t-s--c))) arg))
                                             ,body))
  
                                         ))))
  
             (gen-varlist ()
                          (mapcar (lambda (x) `(,(cadr x) ,(list '\, (car x))))
                                  let-vars)
                          ))
        
        (cond ((<= len 0) "ERROR: no valid type")
              ((= len 1)
               (if (eq (caar valid) 'and)
                   ;;; (eval (caddar valid))
                   (caddar valid)
                 ;;;(eval  (cadar valid))
                 (cadar valid)
                 ))
              ;;?TODO: are there possible problems with evaluating the arguments
              ;;       multiple times? Maybe they should be put in a list
              (t (let* ((clauses (mapcar 'gen-cond-clause valid))
                        (clauses (if (eq (caar clauses) t)
                                     clauses
                                   (cons
                                    '(t (error "invalid type, expected <TODO>"))
                                    clauses)))
                        (varlist (gen-varlist)))
                   `(backquote ,(if varlist
                                   `(let ,varlist
                                     (cond ,@(reverse clauses)))
                                  `(cond ,@(reverse clauses)))
                                 )))))))
  
  
  (defun call-transform (template-name &rest args)
    "expand TEMPLATE-NAME with ARGS in the same way that `transform' would
  if was called as (transform '(template-name args))
  NOTE: this calls `transform' on all ARGS, but not TEMPLATE-NAME"
    (eval `(transform '(,template-name ,@(mapcar 'transform args)))))
  
  (defun strip$ (sym)
    (let ((str (symbol-name sym)))
      (if (string-match "\\(^\\$\\)\\(.+\\)" str)
          (intern (match-string 2 str))
        sym)))
  (defun strip_ (sym)
    (let ((str (symbol-name sym)))
      (if (string-match "\\(^_\\)\\(.+\\)" str)
          (intern (match-string 2 str))
        sym)))
#+END_SRC
*** example usage
(pyel-def-call-func pyel+ (lhs rhs)
		    ((or lsh rhs)
		     (string (concat lhs rhs))
		     (number (+ lhs rhs))
		     (list (append lhs rhs)
			   (vector (ldk lhs rhs)))))


(setq known-types '((string list) (number vector)))

(pyel+ 'a 'b)
==>  (cond
      ((listp a)
       (append a b))
      ((numberp b)
       (+ a b))
      ((stringp a)
       (concat a b))
      (t
       (error "invalid type, expected <TODO>")))


TODO: describe alternative syntax
==> look at the bin-op heading for examples
(pyel-def-funcall * (l r)
                    (number number) ->  (* l r)
                    (object _)      
                    (_ object)  -> (--mul-- l r)
                    (_ string)
                    (string _)  -> (pyel-mul-num-str l r))


*** tests
auto generated tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;
#+END_SRC
hand written
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(ert-deftest pyel-expand-type-switch ()
  ;;verify that both type expanders produce the same output
  (should (equal (pyel-expand-type-switch-2 '(l r)
					    '((number number) ->  (* l r)
					      (object _)      
					      (_ object)  -> (--mul-- l r)
					      (_ string)
					      (string _)  -> (pyel-mul-num-str l r)))

		 (pyel-expand-type-switch-2 '(l r)
					    '((number number) ->  (* l r)
					      (object _)      
					      (_ object)  -> (--mul-- l r)
					      (_ string)
					      (string _) -> (pyel-mul-num-str l r))))))
#+END_SRC

** translation messages 
#+Begin_SRC emacs-lisp :tangle pyel.el
(defvar pyel-translation-messages nil
  "collects messages during pyel translations")

(defvar pyel-message-formats '((error "ERROR: %s")
			       (warn "WARNING: %s")
			       (recommend "RECOMMENDATION: %s"))
  "alist of message type and their format strings")

(defun pyel-notify (type msg)
  "add MSG to `pyel-translation-messages', TYPE specifies the format string
in `pyel-message-formats'"
  (push (format (or (cadr (assoc type pyel-message-formats))
		    (format "[%s]: %%s" (upcase (symbol-name type))))
		msg) pyel-translation-messages))

#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(ert-deftest pyel-do-splices ()
 (should (equal (pyel-do-splices '(a (@ b (c)))) '(a b (c))))
 (should (equal (pyel-do-splices '(a (@ b c)))  '(a b c)))
 (should (equal (pyel-do-splices '(a (@ b (c (@ 2 (n (x 1 (@ 2))) 3 (@ 3) (@ a b (2)))))))
		'(a b (c 2 (n (x 1 2)) 3 3 a b (2)))))

  (should (equal (pyel-do-splices '(@ (a b (@ d (e 2 (@ a b c ))))))
		 '(a b d (e 2 a b c))))

  (should (equal (pyel-do-splices '(@ (a b (@ d (e 2 (@ a b c )))) last))
		 '(progn (a b d (e 2 a b c)) last)))

  (should (equal (pyel-do-splices '(@)) nil))
)
#+END_SRC

* python preprocessor
the preprocessor is no longer tangled

(lambda (a b) (print a))
lambda((a,b)
       print(a))

(cond ((> a b) (print a))
      (t (print b)))
cond([a > b, print(a)]
     [true, print(b)])

(py-ast "lambda([a,b],
print(a)) " t)

preprocessor expand separately
  scan for regex
  copy form to seporate file and expand to pyel-ast
    store in hash table with unique ID
  in py-ast replace with variable that matches some regex and contains that id
  in pyel expanstion match names, when match found, transform ast from hash table

* transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(make-transform-table 'pyel)
#+END_SRC
** tests
* python ast
This is for all non template specific code.

#+Begin_SRC python :tangle py-ast.py
  import ast
  
  #TODO: use *args
  
  def l_str(x):
      return "(" + " ".join(map(str,x)) + ")"
  
  def ll_str(x):
      if x == []:
          return "nil"
      elif type(x) == str:
          return x
      return "(" + " ".join(map(str,x)) + ")"
  #    return " ".join(map(str,x))
  #    return "(list " + " ".join(map(str,x)) + ")"
  # commented out for 'assign'. cause problems elsewhere?
  
  
  def untuple(x):
      return ll_str(x)
      if x == []:
          return "nil"
      elif type(x) == str:
          return x
      
  def Module(body):
      return "\n".join(body)
  
  
    
  def keyword(arg, value):
      return l_str(["(keyword ", arg, " ", value, ")"])
        
  def Print(dest, values, nl):
      print("Error, using python2.x upgrade to 3")
      exit()
        
  def Param():
      return "'param"
      
  def Load():
      return "'load"
      
  def Store():
      return "'store"
      
  def Expr(value): #?bug
      return value
      
  def Import(names):
      return l_str(["import ",ll_str(names)])
      
  def alias(name, asname):
      if asname: asname = "\"" + asname + "\""
      return l_str(["alias ", "\"" + name + "\"", asname or "nil"]) 
      
  def ImportFrom(module, names, level):
      return l_str(["import-from ","\"" + module + "\"", ll_str(names), level])
    
#+END_SRC  
* runtime
* testing
ert tests
http://www.gnu.org/software/emacs/manual/html_mono/ert.html#Test-Selectors

#+Begin_SRC emacs-lisp :tangle pyel.el
  
  (defvar pyel-test-py-functions nil
    "list of generated python test functions.
  when `pyel-run-tests' is run, these are translated to e-lisp
  and compared to expected values")
  
  (setq _pyel-tests nil)    
  
  (defvar pyel-test-func-counter 0
    "just another counter")
    
  (defun pyel-make-test-func-name ()
    (setq pyel-test-func-counter (1+ pyel-test-func-counter)))
  
  
  (defmacro pyel-create-tests (name &rest py-tests)
    (let ((complete nil)
          (py-ast nil)
          (el-ast nil)
          (c 0)
          ert-tests
          tests
          trans)
      (progv
          (mapcar 'car test-variable-values)
          (mapcar 'cadr test-variable-values)
        
        (flet ((pyel-create-new-marker () "test_marker"))
          
          (dolist (test (reverse py-tests))
            (cond ((and (consp test)
                        (>= (length test) 2)
                        (consp (cadr test)))
                   (let* ((tests)  ;;form: ("test" ("test1" result1) ("test2" result2) ...)
                          (name-str (replace-regexp-in-string "-" "_" (symbol-name name)))
                          (test-name (concat "pyel_test_" name-str "_" (number-to-string (pyel-make-test-func-name))))
                          (d 0))
                     
                     (push (setq _x (pyel-functionize (concat (car test)
                                                                    (if (= (length test) 2)
                                                                        (concat "return " (caadr test))
                                                                        (mapconcat (lambda (x) (concat "\nif n == " (number-to-string (setq d (1+ d))) ":\n"
                                                                                                   " return " (car x)))
                                                                               (cdr test) "\n")))
                                                            test-name "n"))
                           pyel-test-py-functions)
                     (setq d 0)
                     (mapc (lambda (x)
                             (push `(ert-deftest
                                        ,(intern (concat "pyel-" name-str
                                                         (number-to-string (setq c (1+ c))))) ()
                                      (should (equal (eval (pyel ,(if (= (length test) 2)
                                                                      (format "%s()" test-name)
                                                                    (format "%s(%s)" test-name (setq d (1+ d))))))
                                                     ,(cadr x))))
                                   tests))
                           (cdr test))
                     (setq _pyel-tests (append _pyel-tests (reverse tests)))
                     ))
                  
                ((consp test) ;;form: ("test" expect)
                 (push `(ert-deftest
                              ,(intern (concat "pyel-" (symbol-name name)
                                               (number-to-string (setq c (1+ c))))) ()
                            (should (equal (eval (pyel ,(concat (pyel-functionize (car test))
                                                                "\nf()")))
                                           ,(cadr test))))
                         _pyel-tests))
              
                (t (progn ;;form "test"
                     ;;check complete code transformation
                     (setq trans (pyel test))
                     (push `(push '(should (equal
                                            (pyel ,test)
                                            ',trans))
                                  pyel-transform-tests)
                           _pyel-tests)
                     ;;check python ast
                     (push `(push '(should (equal (py-ast ,test)
                                                  ,(py-ast test)))
                                  pyel-py-ast-tests)
                           _pyel-tests)
                     
                     ;;check transformed .py syntax tree
                     (push `(push '(should (string= (pyel ,test t)
                                                    ,(pyel test t)))
                                  pyel-el-ast-tests)
                           _pyel-tests))
            )))))))
  
  (defun pyel-create-tests-with-known-types (name known-types &rest py-code)
    "just like `pyel-create-tests-with-known-types' fakes the known types during the tests"
    ;;99% of the code is the same...
    (let ((complete nil)
          (py-ast nil)
          (el-ast nil)    
          trans)
      (progv
          (mapcar 'car test-variable-values)
          (mapcar 'cadr test-variable-values)
  
        
        (dolist (code (reverse py-code))
          ;;check complete code transformation
          (setq trans (pyel-with-known-types known-types code))
          (push `(should (equal
                          (pyel-with-known-types ',known-types ,code)
                          ',trans))
                complete)
          ;;check pure .py syntax tree
          (push `(should (equal (py-ast ,code)
                                ,(py-ast code)))
                py-ast)
          ;;check transformed .py syntax tree
          (push `(should (string= (pyel ,code t)
                                  ,(pyel code t)))
                el-ast))
        
        (kill-new (pp-to-string `(ert-deftest ,(intern (concat "pyel-" (symbol-name name) "-full-transform"))
                                     () ,@complete)))
        (kill-append (pp-to-string `(ert-deftest ,(intern (concat "pyel-" (symbol-name name) "-py-ast"))
                                        () ,@py-ast)) nil)
  
        (kill-append (pp-to-string `(ert-deftest ,(intern (concat "pyel-" (symbol-name name) "-el-ast"))
                                        () ,@el-ast)) nil)
        (message "Tests copied to kill ring"))))
  
    
  (defun pyel-generate-tests ()
    (interactive)
    ;;read in tests from pyel-tests.el
    ;;save resulting tests in  pyel-tests-generated.el
    ;;evaluate all the tests
    (let ((pyel-test-func-counter 0)
          pyel-transform-tests
          pyel-py-ast-tests
          pyel-el-ast-tests
          pyel-test-py-functions
          _pyel-tests
          )
  
      (load-file (file-path-concat pyel-directory "pyel-tests.el"))
      (with-temp-buffer
        ;;insert header stuff
        (mapc (lambda (x) (insert (prin1-to-string x) "\n"))
              '((setq pyel-transform-tests nil)
                (setq pyel-py-ast-tests nil)
                (setq pyel-el-ast-tests nil)
                ))
        ;;insert main tests
        (mapc (lambda (x) (insert (prin1-to-string x) "\n"))
              _pyel-tests)
        ;;save py test functions
        (insert (format "(setq pyel-test-py-functions '%s)"
                        (prin1-to-string pyel-test-py-functions)))
        (insert "\n(provide 'pyel-tests-generated)")
        (write-file (file-path-concat pyel-directory "pyel-tests-generated.el"))
        (eval-buffer))))
  
  (defalias 'pyel-verify 'pyel-run-tests)
  (defun pyel-run-tests ()
    (interactive)
    (flet ((pyel-create-new-marker () "test_marker"))
      (progv
          (mapcar 'car test-variable-values)
          (mapcar 'cadr test-variable-values)
        (let ((transform-passed (reduce '+ (mapcar (lambda (test)
                                                     (if (eval test) 1 0))
                                                   pyel-transform-tests)))
              (py-ast-passed (reduce '+ (mapcar (lambda (test)
                                                  (if (eval test) 1 0))
                                                pyel-py-ast-tests)))
              (el-ast-passed (reduce '+ (mapcar (lambda (test)
                                                  (if (eval test) 1 0))
                                                pyel-el-ast-tests))))
          (message "transform: %s/%s\npy-ast: %s/%s\nel-ast: %s/%s\n"
                   transform-passed (length pyel-transform-tests)
                   py-ast-passed (length pyel-py-ast-tests)
                   el-ast-passed (length pyel-el-ast-tests))
          (ert-run-tests-interactively "pyel")
          ))))
  
  (defun pyel-functionize (py-code &optional func-name &rest args)
    "wrap PY-CODE in a function definition
  FUNC-NAME defaults to 'f'"
    (concat  "def " (or func-name "f") (if args (format "(%s)" (mapconcat 'identity args ", ")) "()") ":\n"
             (mapconcat 'identity (mapcar (lambda (x) (concat " " x))
                                          (split-string py-code "\n"))
                        "\n")))
#+END_SRC

* ---------------------
* assign
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-create-py-func set (_sym _val)
                       (_ $function) -> (fset $$sym $$val)
                       (_ _) -> (setq $sym $val)) ;;TODO: other?
  
  (def-transform assign pyel ()
      (lambda (targ val) (py-assign targ val)))
    
   ;;TODO: put all setq's in a single form: (setq a 1 b 2) etc
  
  (defun py-assign (targets values)
      
      (let ((wrap-values t)
            unpack i)
        ;;make sure targets and lists are both in a list form
        ;;the 'unpack' flag is needed because it leaves no difference
        ;;between a,b=c and a=b=c
        (if (and (listp (car targets))
                 (eq (caar targets) 'tuple))
            (progn
              
              (if (eq (car values) 'tuple)
                  (progn
                    
                    (setq values (cadr values))
                    (setq wrap-values nil))
                (setq unpack t) ;;targets is a tuple and values is not
                ;;(setq values (list values))
                )
              
              (setq targets (cadar targets)))
          )
        
        (when wrap-values
          (setq values (list values)))
        
        
        ;;py-sssign2 does the main transforms
        ;;TODO: check for the special case a,b=b,a and create temp variables
        ;;TODO: check that legnth of the lists are the same
  
        ;;TODO: 
        (cond (unpack
                ;;TODO: pyel error unless: (and (> (length targets) 1)  (= (length values) 1)
  
              (let ((code '(@)))
                `(let ((__value__ ,(transform (car values))))
                   
                ,(dotimes (i (length targets) (reverse code))
                   ;;;TODO: will have to help the transform know what type __value__ is
                  (push (py-assign2 (nth i targets)
                                    
                                    (pyel-make-ast 'subscript '__value__ i 'load))
                        code))
                )))
  
               ((= (length targets) 1)
               ;;form: a=b
               (py-assign2 (car targets)
                           (car values))) ;;if this is the second call of a "a,b = c" type form, then the ctx of values will be store instead of load which leads to an error
    
              ;;form: a,b = c
              ((and (> (length targets) 1) (= (length values) 1))
               (list '@ (py-assign2 (car (last targets)) (car values))
                        (py-assign  (butlast targets)
                                    (pyel-change-ctx (car (last targets)) 'load))))
              
              ;;form: a,b = x,y
              (t (let* ((tmp-vars (loop for i from 1 to (length targets)
                                        collect (intern (format "__%s__" i))))
                        (let-vars (mapcar* (lambda (a b)
                                             (list a (transform b)))
                                           tmp-vars values)))
                   `(let ,let-vars
                      ,(cons '@ (mapcar* 'py-assign2 targets tmp-vars))))))))
  
  ;;DOC: tranforms must be carefull not to transform code multiple times
  
  (defun py-assign2 (target value)
   (let ((ctx (eval (car (last target))))
  
          (assign-value value)) 
  
      ;;the target code is responsible for providing the correct assign function
      ;;
      
      ;;TODO:     is context-value still used?
      ;; (using-context assign-target
      ;;             (setq t-target (transform target)))
      ;; (using-context assign-value
      ;;             (setq t-value (transform value)))
  
      ;;The target transform is responsible for generating the code
      ;;The value being assigned to the target is available to the
      ;;target transform via the variable assign-value.
      ;;assign-value is untransformed, the target transform must tranform it
      
      ;; (using-context assign-value
      ;;             (setq assign-value (transform value)))
      ;;problem: code was being transformed multiple times
      (setq assign-value value)
      (using-context assign-target
                     (transform target))
      ;;    (list assign-func t-target t-value)
  
      ))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Assign(targets, value):
      #    print("targets: ", targets)
      return l_str(["assign ", untuple(targets), value])
  
#+END_SRC

** tests 
#+Begin_SRC emacs-lisp :tangle pyel-tests.el 
  (pyel-create-tests assign
                     "a = 1"
                     "a.b = 1"
                     "a.b = c"
                     "a.b.c = 1"
                     "a.b = d.c"
                     "a,b = 1,2"
                     "a,b.c,x[2] = 1,a.c(),x[x()+y]"
                     "a = 1
  b = 2
  a,b= b,a
  assert a == 2
  assert b == 1"
  
                     "a,b = c"
                     "a,b,c = c.a"
                     "a,b = c.a()"
                     "a,b = c"
                     "a,b = a.e.e()"
                     "a[1:4], b[2], a.c = c"
  
                     "a = b = c"
                     "a = b = c.e"
                     "a = b = c.e()"
                     "a = b = c = 9.3"
                     "a = b = c = 9.3
  assert a == b == c == 9.3"
  
                     )
#+END_SRC 
* attribute
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform attribute pyel ()
    (lambda (value attr ctx)
      (pyel-attribute value attr ctx)))
  
  
  (defun pyel-attribute (value attr ctx)
    (setq ctx (cond ((context-p 'force-load) 'load)
                    ((context-p 'force-store) 'store)
                    (t (eval ctx))))
    (let ((t-value (transform value))
          (attr (read (_to- (transform attr)))))
      
      ;;create slot for this attribute if it does not already exist
      (when (and (context-p 'method-def)
                 (not (assoc attr class-def-slots)))
        (push `(,attr :initarg ,(intern (concat ":"
                                                (symbol-name attr)))
                      :initform nil)
              
              class-def-slots))
      (if (and (context-p 'method-call)
               (not (context-p 'method-call-override)))
          (using-context method-call-override
                         ;;ctx?
                         `(@ ,attr ,(transform value)))
        
        
        ;; (if (context-p 'assign-target)
        ;;          (setq assign-func 'oset))
        
        ;;check the presumption:
        (when (and (eq ctx 'store)
                   (not (context-p 'assign-target))
                   nil);;for this to work, this function need to set context as well
          (error "`pyel-attribute': Presumption failed: ctx==store but not in assign context"))
        (when (and (eq ctx 'store)
                   (not (boundp 'assign-value)))
          (error "`pyel-attribute': Presumption failed: ctx==store but assign-value is unbound"))
        
        (cond
         ((eq ctx 'store)
          (list 'oset t-value attr (transform assign-value))) ;;assign target
         ((eq ctx 'load) ;;assign value
          (list 'oref t-value attr))
         (t "Error in attribute-- invalid ctx"))
        )))
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Attribute(value, attr, ctx):
      return l_str(["attribute ", value, "\"" + attr + "\"", ctx])
#+END_SRC

** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests attribute
                     "a.b"
                     "a.b.c"
                     "a.b.c.e"
                     "a.b()"
                     "a.b.c()"
                     "a.b.c.d()"
                     "a.b.c.d(1,3)"
                     "a.b = 2"
                     "a.b.e = 2"
                     "a.b.c = d.e"
                     "a.b.c = d.e.f"
                     "a.b.c = d.e()"
                     "a.b.c = d.e.f()"
                     "a.b.c = d.e.f(1,3)"
                     "a.b, a.b.c = d.e.f(1,3), e.g.b"
                     "a.b(x.y,y)"
                     "a.b(x.y(g.g()),y.y)")
  
#+END_SRC
* num ok
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform num pyel ()
    (lambda (n)
      n
      ))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Num(n):
      return "(num " + str(n) +")"
#+END_SRC

(pyel-create-tests 'num "3" "4.21")
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests num "3" "4.23")
#+END_SRC

* name 
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform name pyel ()
    (lambda (id ctx)
      (pyel-name id ctx)))
  
  (defun pyel-name (id ctx)
    (let ((new-id)
          (id (read id))
          piece code)
      
      ;;TODO: id should be string. verify?
      (setq ctx (cond ((context-p 'force-load) 'load)
                      ((context-p 'force-store) 'store)
                      (t (eval ctx))))
      
      
      (if (assoc id pyel-marked-ast-pieces)
          ;;this id is a marker, insert the corresponding macro
          (progn
            (setq piece (assoc id pyel-marked-ast-pieces))
            ;;'piece' has form: (marker macro-name macro-body)
            (using-context macro-call
                           (list (second piece)
                                 (pyel-transform-ast (third piece) :nosplice))))
        
        ;;else: normal name
        (setq id (_to- id))
        (when (and (context-p 'assign-value) ;;checking assumption
                   (not (equal ctx 'load)))
          (error (format "In transform name: context is 'assign-value' but ctx is not 'load'.
            ctx = %s" ctx)))
        
        (when (setq new-id (assoc id pyel-variable-name-translations))
          (setq id (cadr new-id)))
        
        (when (and (eq ctx 'store)
                   (context-p 'function-def)
                   (context-p 'assign-target))
          (add-to-list 'let-arglist id))
        
        (cond 
         ((eq ctx 'load) id)
         ((eq ctx 'store)  (if (context-p 'for-loop-target)
                               id
                             (call-transform 'set id assign-value)))
         (t  "<ERROR: name>"))
        )))
  
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Name(id, ctx):
      return l_str(["name ", "\"" + id + "\"", ctx])
#+END_SRC

** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests name "testName")
#+END_SRC

* literals
** list
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
    (def-transform list pyel ()
      (lambda (elts ctx)
        (pyel-list elts ctx)))
    
  
  (defun pyel-list (elts ctx)  ;;IGNORING CTX
    (if (context-p 'macro-call)
        (mapcar 'transform elts)
      (cons 'list (mapcar 'transform elts))))
  
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def List(elts, ctx):
      return "(list " + ll_str(elts) + " " + ctx +")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests list
                     "[]"
                     "[a,1,2]"
                     "a = [1,2,a.b]"
                     "b = [1,[1,a,[a.b,[],3]]]"
                     "[[[[[[[a]]]]]]]")
#+END_SRC
** dict
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (defvar pyel-dict-test 'equal "test function for dictionaries")
  
  (def-transform dict pyel ()
    (lambda (keys values)
      (pyel-dict keys values)))
  
  
  (defun pyel-dict (keys values) ;;TODO: move to lambda in template and create template vars 
    (if keys
  
        `(let ((__h__ (make-hash-table :test ',pyel-dict-test))) ;;default length??
           ,(cons '@ (mapcar* (lambda (key value)
                                         `(puthash ,key ,value __h__))
                                       (mapcar 'transform  keys)
                                       (mapcar 'transform  values)))
           __h__)
      
      `(make-hash-table :test ',pyel-dict-test)))
  
  
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Dict(keys, values):
      return "(dict " + ll_str(keys) + " " + ll_str(values) + ")"
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests dict
                     "{'a':2, 'b':4}"
                     "a = {a:2, b:4}"
                     "x = {'a':2, 'b':4, 'c' : {'d' : 1,'e': 2,f:{g:3}}}")
#+END_SRC

** tuple
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform tuple pyel ()
    (lambda (elts ctx) ;;Ignoring ctx for now
      (cons 'vector (mapcar 'transform elts))))
  
  
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Tuple(elts, ctx):
      return l_str(["tuple ", ll_str(elts), ctx])
#+END_SRC
*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests Tuple
                     "()"
                     "(a, b)"
                     "(a, (b, (c,d)))"
                     "((((((((a))))))))")
#+END_SRC

** string
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform str pyel () 
    (lambda (s)
  ;;    (format "\"%s\"" s)
      s
      ))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py
  def Str(s):
      return "(str \"" + str(s) +"\")"
#+END_SRC
*** tests
(pyel-create-tests 'str
		   "'a'"
		   "x = 'a'"
		   "['a','b']")
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-str-full-transform nil
    (should
     (equal
      (pyel "'a'")
      '"a"))
    (should
     (equal
      (pyel "x = 'a'")
      '(pyel-set x "a")))
    (should
     (equal
      (pyel "['a','b']")
      '(list "a" "b"))))
  (ert-deftest pyel-str-py-ast nil
    (should
     (equal
      (py-ast "'a'")
      "Module(body=[Expr(value=Str(s='a'))])\n"))
    (should
     (equal
      (py-ast "x = 'a'")
      "Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=Str(s='a'))])\n"))
    (should
     (equal
      (py-ast "['a','b']")
      "Module(body=[Expr(value=List(elts=[Str(s='a'), Str(s='b')], ctx=Load()))])\n")))
  (ert-deftest pyel-str-el-ast nil
    (should
     (string=
      (pyel "'a'" t)
      "(str \"a\")\n"))
    (should
     (string=
      (pyel "x = 'a'" t)
      "(assign  ((name  \"x\" 'store)) (str \"a\"))\n"))
    (should
     (string=
      (pyel "['a','b']" t)
      "(list ((str \"a\") (str \"b\")) 'load)\n")))
  
#+END_SRC

** ???
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el

#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* comparisons: >, <, ==, !=, <=, >= 
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  
  
  ;; (def-transform compare pyel ()
  ;;   (lambda (left ops comparators)
  ;;     ;;what if comparators has multiple items?
  ;;     `(,(read (car ops)) ,(transform left) ,(transform (car comparators)))))
  
  
  (def-transform compare pyel ()
    (lambda (left ops comparators)
      ;;what if comparators has multiple items?
      (pyel-compare left ops comparators :outer)))
  
  ;;TODO: assign comparators to temp variables to prevent repeated evaluation
  (defun pyel-compare (left ops comparators &optional outer)
    ;;if outer is non-nil, then we use 'and' to combine the seporate tests
    (if (> (length ops) 1)
        (list (if outer 'and '@)
              (pyel-compare left (list (car ops)) (list (car comparators)))
              (pyel-compare (car comparators) (cdr ops) (cdr comparators)))
      
      (call-transform (read (car ops)) left (car comparators))))
  
  
  (pyel-create-py-func == (l r)
                       (number number) -> (= l r)
                       (string string) -> (string= l r)
                       ;;                       (object _) -> (--eq-- l r)
                       
                       (_ _) -> (equal l r))
  
  (pyel-create-py-func > (l r)
                       (number number) -> (> l r)
                       ;;TODO: macro for this
                       (string string) -> (and (not (string< l r)) (not (string= l r)))
                       (object _) -> (__gt__ l r))
  ;;TODO: other py types?
  ;;::Q does `string<' behave like < for strings in python?
  (pyel-create-py-func < (l r)
                       (number number) -> (< l r)
                       (string string) -> (string< l r)
                       (object _) -> (__lt__ l r))
  ;;TODO: other py types?
  
  (pyel-create-py-func >= (l r)
                       (number number) -> (>= l r)
                       (string string) -> (not (string< l r))
                       (object _) -> (__ge__ l r))
  
  (pyel-create-py-func <= (l r)
                       (number number) -> (<= l r)
                       (string string) -> (or (string< l r) (string= l r))
                       (object _) -> (__le__ l r))
  
  (pyel-create-py-func != (l r)
                       (number number) -> (not (= l r))
                       (string string) -> (not (string= l r))
                       (object _) -> (__ne__ l r)
                       (_ _) -> (not (equal l r)))
                                          ;
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
    
  def Compare (left, ops, comparators):
        return l_str(["compare ", left, ll_str(ops), ll_str(comparators) ])
        
  def Gt():
        return "\">\""
  def Lt():
        return "\"<\""
  def Eq():
        return "\"==\""
  def NotEq ():
        return "\"!=\""
  def LtE():
        return "\"<=\""
  def GtE():
        return "\">=\""
  def In():
        return "\"in\"";
  def NotIn():
        return "\"not-in\"";      
#+END_SRC
** tests   
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (pyel-create-tests compare
                     "a=='d'"
                     "a==b"
                     "a>=b"
                     "a<=b"
                     "a<b"
                     "a>b"
                     "a!=b"
                     "(a,b) == [c,d]"
                     "[a == 1]"
                     "((a == 1),)"
                     "a<b<c"
                     "a<=b<c<=d"
                     "a.b<=b.c()<c<=3")
  
#+END_SRC

* if
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform if pyel ()
    (lambda (test body orelse)
      (let* ((tst (transform test))
             (true-body (mapcar 'transform body))
             (progn-code (if (> (length true-body) 1)
                             '(@ progn)
                           '@)))
  
        `(if  ,(if (equal tst []) nil tst)
  
             (,progn-code ,@true-body)
           ,@(mapcar 'transform orelse)))))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
    def If (test, body, orelse):
        return l_str(["if ",test, ll_str(body), ll_str(orelse)])
#+END_SRC
** tests
(pyel-create-tests 'if
"if (a==b):
  b=c
else:
  a = d"

"if (a==b):
   b=c
   z=1
else:
  a = 4
  b = a.b"

"if (a.b <= a.e):
 a.b=(2.1,2)
else:
 b.a.c=[a,{'a':23.3,'b':(3.2,3.1)}]"
)
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-if-full-transform nil
    (should
     (equal
      (pyel "if (a==b):\n  b=c\nelse:\n  a = d")
      '(if
           (pyel-== a b)
           (pyel-set b c)
         (pyel-set a d))))
    (should
     (equal
      (pyel "if (a==b):\n   b=c\n   z=1\nelse:\n  a = 4\n  b = a.b")
      '(if
           (pyel-== a b)
           (progn
             (pyel-set b c)
             (pyel-set z 1))
         (pyel-set a 4)
         (pyel-set b
                   (oref a b)))))
    (should
     (equal
      (pyel "if (a.b <= a.e):\n a.b=(2.1,2)\nelse:\n b.a.c=[a,{'a':23.3,'b':(3.2,3.1)}]")
      '(if
           (pyel-<=
            (oref a b)
            (oref a e))
           (oset a b
                 (vector 2.1 2))
         (oset
          (oref b a)
          c
          (list a
                (let
                    ((__h__
                      (make-hash-table :test 'equal)))
                  (puthash "a" 23.3 __h__)
                  (puthash "b"
                           (vector 3.2 3.1)
                           __h__)
                  __h__)))))))
  (ert-deftest pyel-if-py-ast nil
    (should
     (equal
      (py-ast "if (a==b):\n  b=c\nelse:\n  a = d")
      "Module(body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Name(id='b', ctx=Load())]), body=[Assign(targets=[Name(id='b', ctx=Store())], value=Name(id='c', ctx=Load()))], orelse=[Assign(targets=[Name(id='a', ctx=Store())], value=Name(id='d', ctx=Load()))])])\n"))
    (should
     (equal
      (py-ast "if (a==b):\n   b=c\n   z=1\nelse:\n  a = 4\n  b = a.b")
      "Module(body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Name(id='b', ctx=Load())]), body=[Assign(targets=[Name(id='b', ctx=Store())], value=Name(id='c', ctx=Load())), Assign(targets=[Name(id='z', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='a', ctx=Store())], value=Num(n=4)), Assign(targets=[Name(id='b', ctx=Store())], value=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Load()))])])\n"))
    (should
     (equal
      (py-ast "if (a.b <= a.e):\n a.b=(2.1,2)\nelse:\n b.a.c=[a,{'a':23.3,'b':(3.2,3.1)}]")
      "Module(body=[If(test=Compare(left=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Load()), ops=[LtE()], comparators=[Attribute(value=Name(id='a', ctx=Load()), attr='e', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Store())], value=Tuple(elts=[Num(n=2.1), Num(n=2)], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Attribute(value=Name(id='b', ctx=Load()), attr='a', ctx=Load()), attr='c', ctx=Store())], value=List(elts=[Name(id='a', ctx=Load()), Dict(keys=[Str(s='a'), Str(s='b')], values=[Num(n=23.3), Tuple(elts=[Num(n=3.2), Num(n=3.1)], ctx=Load())])], ctx=Load()))])])\n")))
  (ert-deftest pyel-if-el-ast nil
    (should
     (string=
      (pyel "if (a==b):\n  b=c\nelse:\n  a = d" t)
      "(if  (compare  (name  \"a\" 'load) (\"==\") ((name  \"b\" 'load))) ((assign  ((name  \"b\" 'store)) (name  \"c\" 'load))) ((assign  ((name  \"a\" 'store)) (name  \"d\" 'load))))\n"))
    (should
     (string=
      (pyel "if (a==b):\n   b=c\n   z=1\nelse:\n  a = 4\n  b = a.b" t)
      "(if  (compare  (name  \"a\" 'load) (\"==\") ((name  \"b\" 'load))) ((assign  ((name  \"b\" 'store)) (name  \"c\" 'load)) (assign  ((name  \"z\" 'store)) (num 1))) ((assign  ((name  \"a\" 'store)) (num 4)) (assign  ((name  \"b\" 'store)) (attribute  (name  \"a\" 'load) \"b\" 'load))))\n"))
    (should
     (string=
      (pyel "if (a.b <= a.e):\n a.b=(2.1,2)\nelse:\n b.a.c=[a,{'a':23.3,'b':(3.2,3.1)}]" t)
      "(if  (compare  (attribute  (name  \"a\" 'load) \"b\" 'load) (\"<=\") ((attribute  (name  \"a\" 'load) \"e\" 'load))) ((assign  ((attribute  (name  \"a\" 'load) \"b\" 'store)) (tuple  ((num 2.1) (num 2)) 'load))) ((assign  ((attribute  (attribute  (name  \"b\" 'load) \"a\" 'load) \"c\" 'store)) (list ((name  \"a\" 'load) (dict ((str \"a\") (str \"b\")) ((num 23.3) (tuple  ((num 3.2) (num 3.1)) 'load)))) 'load))))\n")))
  
#+END_SRC

* call
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (defvar pyel-obj-counter 0)
  
  (defun pyel-next-obj-name ()
    (if pyel-unique-obj-names
        (format "obj-%d" (setq pyel-obj-counter (1+ pyel-obj-counter)))
      "obj"))
  
  (pyel-create-py-func fcall (_func &rest args)
                       ($function _) -> ($func ,@args)
                       (_ _) -> (funcall $func ,@args))
  
  (def-transform call pyel ()
    ;;TODO: some cases funcall will need to be used, how to handle that?
    (lambda (func args keywords starargs kwargs)
      (pyel-call-transform func args keywords starargs kwargs)))
  
  
  (defun pyel-call-transform (func args keywords starargs kwargs)
    (let ((t-func (transform func))
          new-func m-name  f-name )
      (if (member t-func pyel-defined-classes)
          ;;instantiate an object and call its initializer
          `(let ((__c (,t-func ,(pyel-next-obj-name))))
             (--init-- __c ,@(mapcar 'transform args))
             __c)
        
        (if (eq (car func) 'attribute);;method call
            (if (member (setq m-name (read (caddr func)))
                        pyel-method-transforms)
                ;;this methods transform is overridden
                (eval `(call-transform ',(pyel-method-transform-name m-name)
                                       ',(transform (cadr func))
                                       ,@(mapcar '(lambda (x) `(quote ,x)) args)));;Transform these args?
              ;;normal method call
              (remove-context method-call-override
                              (using-context method-call
                                             `(,(transform func) ,@(remove-context method-call
                                                                                   (mapcar 'transform args))))))
          
          (when (setq new-func (assoc t-func pyel-function-name-translations));;function call
            ;;translate name 
            (setq t-func (cadr new-func)))
          
          ;;TODO: check if there is a function transform defined
          (if (member t-func pyel-func-transforms)
              ;;this function transform is overridden
              (eval `(call-transform ',(pyel-func-transform-name t-func)
                                     ;;',(transform (cadr func))
                                     ,@(mapcar '(lambda (x) `(quote ,x)) args)))
            
            ;;normal function call
            ;;`(,t-func ,@(mapcar 'transform args))
            ;;TODO: this is dumb, convert `call-transform' to a macro?
            (eval `(call-transform 'fcall ,@(cons 't-func (mapcar (lambda (x)
                                                                    `(quote ,x))
                                                                   args))))
            )))))
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Call(func, args, keywords, starargs, kwargs):
      return l_str(["call ", func, ll_str(args), ll_str(keywords), starargs or "nil" , kwargs or "nil"])
    
#+END_SRC
** tests
   (pyel-create-tests 'call
   "aa()"
   "aa(b,c(1,2))"
   ;;"aa()()" does not work yet
   "aa=b()"
   ;;"aa.b()"
   ;;"[aa.b()==4]"
   "aa(3,b(c(),[2,(2,3)]))"
   "aa.b()"
   "aa.b(1,2)"
   "aa.b(1,a.b(1,2,3))"
   
   "a.b().c()"
   "a.b().c().d()"
   "a.b(x.y().e()).c()"
   
		   )
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-call-full-transform nil
    (should
     (equal
      (pyel "aa()")
      '(aa)))
    (should
     (equal
      (pyel "aa(b,c(1,2))")
      '(aa b
           (c 1 2))))
    (should
     (equal
      (pyel "aa=b()")
      '(pyel-set aa
                 (b))))
    (should
     (equal
      (pyel "aa(3,b(c(),[2,(2,3)]))")
      '(aa 3
           (b
            (c)
            (list 2
                  (vector 2 3))))))
    (should
     (equal
      (pyel "aa.b()")
      '(b aa)))
    (should
     (equal
      (pyel "aa.b(1,2)")
      '(b aa 1 2)))
    (should
     (equal
      (pyel "aa.b(1,a.b(1,2,3))")
      '(b aa 1
          (b a 1 2 3))))
    (should
     (equal
      (pyel "a.b().c()")
      '(c
        (b a))))
    (should
     (equal
      (pyel "a.b().c().d()")
      '(d
        (c
         (b a)))))
    (should
     (equal
      (pyel "a.b(x.y().e()).c()")
      '(c
        (b a
           (e
            (y x)))))))
  (ert-deftest pyel-call-py-ast nil
    (should
     (equal
      (py-ast "aa()")
      "Module(body=[Expr(value=Call(func=Name(id='aa', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "aa(b,c(1,2))")
      "Module(body=[Expr(value=Call(func=Name(id='aa', ctx=Load()), args=[Name(id='b', ctx=Load()), Call(func=Name(id='c', ctx=Load()), args=[Num(n=1), Num(n=2)], keywords=[], starargs=None, kwargs=None)], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "aa=b()")
      "Module(body=[Assign(targets=[Name(id='aa', ctx=Store())], value=Call(func=Name(id='b', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "aa(3,b(c(),[2,(2,3)]))")
      "Module(body=[Expr(value=Call(func=Name(id='aa', ctx=Load()), args=[Num(n=3), Call(func=Name(id='b', ctx=Load()), args=[Call(func=Name(id='c', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), List(elts=[Num(n=2), Tuple(elts=[Num(n=2), Num(n=3)], ctx=Load())], ctx=Load())], keywords=[], starargs=None, kwargs=None)], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "aa.b()")
      "Module(body=[Expr(value=Call(func=Attribute(value=Name(id='aa', ctx=Load()), attr='b', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "aa.b(1,2)")
      "Module(body=[Expr(value=Call(func=Attribute(value=Name(id='aa', ctx=Load()), attr='b', ctx=Load()), args=[Num(n=1), Num(n=2)], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "aa.b(1,a.b(1,2,3))")
      "Module(body=[Expr(value=Call(func=Attribute(value=Name(id='aa', ctx=Load()), attr='b', ctx=Load()), args=[Num(n=1), Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Load()), args=[Num(n=1), Num(n=2), Num(n=3)], keywords=[], starargs=None, kwargs=None)], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "a.b().c()")
      "Module(body=[Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), attr='c', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "a.b().c().d()")
      "Module(body=[Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), attr='c', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), attr='d', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "a.b(x.y().e()).c()")
      "Module(body=[Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='y', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), attr='e', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)], keywords=[], starargs=None, kwargs=None), attr='c', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])\n")))
  (ert-deftest pyel-call-el-ast nil
    (should
     (string=
      (pyel "aa()" t)
      "(call  (name  \"aa\" 'load) nil nil nil nil)\n"))
    (should
     (string=
      (pyel "aa(b,c(1,2))" t)
      "(call  (name  \"aa\" 'load) ((name  \"b\" 'load) (call  (name  \"c\" 'load) ((num 1) (num 2)) nil nil nil)) nil nil nil)\n"))
    (should
     (string=
      (pyel "aa=b()" t)
      "(assign  ((name  \"aa\" 'store)) (call  (name  \"b\" 'load) nil nil nil nil))\n"))
    (should
     (string=
      (pyel "aa(3,b(c(),[2,(2,3)]))" t)
      "(call  (name  \"aa\" 'load) ((num 3) (call  (name  \"b\" 'load) ((call  (name  \"c\" 'load) nil nil nil nil) (list ((num 2) (tuple  ((num 2) (num 3)) 'load)) 'load)) nil nil nil)) nil nil nil)\n"))
    (should
     (string=
      (pyel "aa.b()" t)
      "(call  (attribute  (name  \"aa\" 'load) \"b\" 'load) nil nil nil nil)\n"))
    (should
     (string=
      (pyel "aa.b(1,2)" t)
      "(call  (attribute  (name  \"aa\" 'load) \"b\" 'load) ((num 1) (num 2)) nil nil nil)\n"))
    (should
     (string=
      (pyel "aa.b(1,a.b(1,2,3))" t)
      "(call  (attribute  (name  \"aa\" 'load) \"b\" 'load) ((num 1) (call  (attribute  (name  \"a\" 'load) \"b\" 'load) ((num 1) (num 2) (num 3)) nil nil nil)) nil nil nil)\n"))
    (should
     (string=
      (pyel "a.b().c()" t)
      "(call  (attribute  (call  (attribute  (name  \"a\" 'load) \"b\" 'load) nil nil nil nil) \"c\" 'load) nil nil nil nil)\n"))
    (should
     (string=
      (pyel "a.b().c().d()" t)
      "(call  (attribute  (call  (attribute  (call  (attribute  (name  \"a\" 'load) \"b\" 'load) nil nil nil nil) \"c\" 'load) nil nil nil nil) \"d\" 'load) nil nil nil nil)\n"))
    (should
     (string=
      (pyel "a.b(x.y().e()).c()" t)
      "(call  (attribute  (call  (attribute  (name  \"a\" 'load) \"b\" 'load) ((call  (attribute  (call  (attribute  (name  \"x\" 'load) \"y\" 'load) nil nil nil nil) \"e\" 'load) nil nil nil nil)) nil nil nil) \"c\" 'load) nil nil nil nil)\n")))
  
#+END_SRC

* while loop
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  
  ;;doc: context macro-call
  (defun pyel-while (test body orelse)
    ;;pyel-while is special. it gets to handle the macro definitions
    (let* ((tst (transform test))
           (else (mapcar 'transform orelse))
           break-code 
           continue-code
           macro-name
           ;;inter-transform variables
           continue-while
           break-while )
      
      (if (and (symbolp tst)
               (string-match (format "^%s\\([A-Za-z0-9_]+\\)$" pyel-py-macro-prefix)
                             (symbol-name tst)))
          (using-context
           macro-call
           ;;expand as a macro call
           `(,(intern (replace-regexp-in-string "_" "-" 
                                                (match-string 1 (symbol-name tst))))
             ;;TODO: if macro name is an alias, replace with actual
             ,@(mapcar 'transform body)))
        
        ;;expand as a normal while loop
        (setq code (using-context while (mapcar 'transform body))
              break-code (if break-while '(catch '__break__)
                           pyel-nothing)
              continue-code (if continue-while '(catch '__continue__)
                              pyel-nothing)
              wile `(,@break-code
                     (while
                         ,(if (equal tst []) nil tst)
                       (,@continue-code
                        ,@code))))
        (if else
            `(@ ,wile ,@else)
          wile))))
  
  
  
  ;; (defun pyel-while (test body orelse)
  ;;   (let* ((tst (transform test))
  ;;          (else (mapcar 'transform orelse))
  ;;          (wile `(while ,(if (equal tst []) nil tst)
  ;;                   ,@(mapcar 'transform body))))
      
  ;;     (if else
  ;;         `(@ ,wile ,@else)
  ;;       wile)))
  
  (def-transform while pyel ()
    (lambda (test body orelse)
      (pyel-while test body orelse)))
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def While(test, body, orelse):
      return l_str(["while ", test, ll_str(body), ll_str(orelse)])      
#+END_SRC
** tests
(pyel-create-tests 'while
"while (a==b):
  print('hi')"

"while (a==b):
  print('hi')
  a=b"

"while (a==b):
  while (a>2):
    b(3,[a,2])
    b=c.e
  a=b"

"while a:
 if b:
  break
 else:
  c()"

"while a:
 if b:
  continue
 c()"

)
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-while-full-transform nil
    (should
     (equal
      (pyel "while (a==b):\n  print('hi')")
      '(while
           (pyel-== a b)
         (print "hi"))))
    (should
     (equal
      (pyel "while (a==b):\n  print('hi')\n  a=b")
      '(while
           (pyel-== a b)
         (print "hi")
         (pyel-set a b))))
    (should
     (equal
      (pyel "while (a==b):\n  while (a>2):\n    b(3,[a,2])\n    b=c.e\n  a=b")
      '(while
           (pyel-== a b)
         (while
             (pyel-> a 2)
           (b 3
              (list a 2))
           (pyel-set b
                     (oref c e)))
         (pyel-set a b))))
    (should
     (equal
      (pyel "while a:\n if b:\n  break\n else:\n  c()")
      '(catch '__break__
         (while a
           (if b
               (throw '__break__ nil)
             (c))))))
    (should
     (equal
      (pyel "while a:\n if b:\n  continue\n c()")
      '(while a
         (catch '__continue__
           (if b
               (throw '__continue__ nil))
           (c))))))
  (ert-deftest pyel-while-py-ast nil
    (should
     (equal
      (py-ast "while (a==b):\n  print('hi')")
      "Module(body=[While(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Name(id='b', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='hi')], keywords=[], starargs=None, kwargs=None))], orelse=[])])\n"))
    (should
     (equal
      (py-ast "while (a==b):\n  print('hi')\n  a=b")
      "Module(body=[While(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Name(id='b', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='hi')], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='a', ctx=Store())], value=Name(id='b', ctx=Load()))], orelse=[])])\n"))
    (should
     (equal
      (py-ast "while (a==b):\n  while (a>2):\n    b(3,[a,2])\n    b=c.e\n  a=b")
      "Module(body=[While(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Name(id='b', ctx=Load())]), body=[While(test=Compare(left=Name(id='a', ctx=Load()), ops=[Gt()], comparators=[Num(n=2)]), body=[Expr(value=Call(func=Name(id='b', ctx=Load()), args=[Num(n=3), List(elts=[Name(id='a', ctx=Load()), Num(n=2)], ctx=Load())], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='b', ctx=Store())], value=Attribute(value=Name(id='c', ctx=Load()), attr='e', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='a', ctx=Store())], value=Name(id='b', ctx=Load()))], orelse=[])])\n"))
    (should
     (equal
      (py-ast "while a:\n if b:\n  break\n else:\n  c()")
      "Module(body=[While(test=Name(id='a', ctx=Load()), body=[If(test=Name(id='b', ctx=Load()), body=[Break()], orelse=[Expr(value=Call(func=Name(id='c', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])], orelse=[])])\n"))
    (should
     (equal
      (py-ast "while a:\n if b:\n  continue\n c()")
      "Module(body=[While(test=Name(id='a', ctx=Load()), body=[If(test=Name(id='b', ctx=Load()), body=[Continue()], orelse=[]), Expr(value=Call(func=Name(id='c', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))], orelse=[])])\n")))
  (ert-deftest pyel-while-el-ast nil
    (should
     (string=
      (pyel "while (a==b):\n  print('hi')" t)
      "(while  (compare  (name  \"a\" 'load) (\"==\") ((name  \"b\" 'load))) ((call  (name  \"print\" 'load) ((str \"hi\")) nil nil nil)) nil)\n"))
    (should
     (string=
      (pyel "while (a==b):\n  print('hi')\n  a=b" t)
      "(while  (compare  (name  \"a\" 'load) (\"==\") ((name  \"b\" 'load))) ((call  (name  \"print\" 'load) ((str \"hi\")) nil nil nil) (assign  ((name  \"a\" 'store)) (name  \"b\" 'load))) nil)\n"))
    (should
     (string=
      (pyel "while (a==b):\n  while (a>2):\n    b(3,[a,2])\n    b=c.e\n  a=b" t)
      "(while  (compare  (name  \"a\" 'load) (\"==\") ((name  \"b\" 'load))) ((while  (compare  (name  \"a\" 'load) (\">\") ((num 2))) ((call  (name  \"b\" 'load) ((num 3) (list ((name  \"a\" 'load) (num 2)) 'load)) nil nil nil) (assign  ((name  \"b\" 'store)) (attribute  (name  \"c\" 'load) \"e\" 'load))) nil) (assign  ((name  \"a\" 'store)) (name  \"b\" 'load))) nil)\n"))
    (should
     (string=
      (pyel "while a:\n if b:\n  break\n else:\n  c()" t)
      "(while  (name  \"a\" 'load) ((if  (name  \"b\" 'load) ((break)) ((call  (name  \"c\" 'load) nil nil nil nil)))) nil)\n"))
    (should
     (string=
      (pyel "while a:\n if b:\n  continue\n c()" t)
      "(while  (name  \"a\" 'load) ((if  (name  \"b\" 'load) ((continue)) nil) (call  (name  \"c\" 'load) nil nil nil nil)) nil)\n")))
  
#+END_SRC

* arguments
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  
  (def-transform arguments pyel ()
    (lambda (args vararg varargannotation kwonlyargs kwarg kwargannotation
                  defaults kw_defaults)
      (pyel-arguments args vararg varargannotation kwonlyargs kwarg kwargannotation
                      defaults kw_defaults)))
  
  (defun pyel-arguments (args vararg varargannotation
                              kwonlyargs kwarg kwargannotation
                              defaults kw_defaults)
    ;;TODO: other args
    
    (let* ((args (mapcar 'transform args))
           (defaults (mapcar 'transform defaults)))
  
      ;;create default assignment code
      (when (and defaults
                 (context-p 'function-def))
        
        ;;`assign-defaults' only exists under function-def context
        (setq assign-defaults (mapcar* (lambda (arg default)
                                         `(setq ,arg (or ,arg ,default)))
                                       (reverse args) (reverse defaults))))
      
      ;;&optional
      (when defaults
        (insert-at args (- (length args) (length defaults)) '&optional))
      ;;&rest
      (when vararg
        (setq args (append args (list '&rest vararg)))
        (when (and (not pyel-use-list-for-varargs)
                   (context-p 'function-def))
          (push `(setq, vararg (list-to-vector ,vararg)) assign-defaults)))
      
      args))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def arguments(args=None, vararg=None, varargannotation=None, kwonlyargs=None,
                kwarg=None, kwargannotation=None,defaults=None, kw_defaults=None):
      return ll_str(["(arguments ",
                     ll_str(args) or "nil",
                     vararg or "nil",
                     varargannotation or "nil",
                     kwonlyargs or "nil",
                     kwarg or "nil",
                     kwargannotation or "nil",
                     ll_str(defaults) or "nil",
                     kw_defaults or "nil", ")"])
      #return l_str(["_arguments ",ll_str(args) or "nil",vararg or "nil",varargannotation or "nil", kwonlyargs or "nil", kwarg or "nil", kwargannotation or "nil", defaults or "nil", kw_defaults or "nil"])
#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-arguments ()
    (with-transform-table 'pyel
                          (and 
                           (should (equal (transform '(arguments ((arg "b" nil)
                                                                  (arg "c" nil)) nil nil nil nil nil nil nil))
                                          
                                          '(b c)))
                           ;;other tests here
                           )))
#+END_SRC

* function def
includes 'arg' transformation
** python ast expansion example
"def a(b,c):
  print('ok')
  return c+a"

FunctionDef(name='a',
	    args=arguments(args=[arg(arg='b', annotation=None), arg(arg='c', annotation=None)],
				vararg=None,
				varargannotation=None,
				kwonlyargs=[],
				kwarg=None,
				kwargannotation=None,
				defaults=[],
				kw_defaults=[]),
	    
	    body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='ok')], keywords=[], starargs=None, kwargs=None)), Return(value=BinOp(left=Name(id='c', ctx=Load()), op=Add(), right=Name(id='a', ctx=Load())))],
	    
	    decorator_list=[],
	    returns=None)

** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform arg pyel ()
    (lambda (arg annotation) ;;Ignoring annotation
      (read arg)))
  
  
  (def-transform def pyel ()
    (lambda (name args body decoratorlist returns)
      (pyel-def name args body decoratorlist returns)))
  
  (defun transform-last-with-context (context code)
    ;;TODO: this does not work: fix and replace code in `pyel-def
    (let*  ((last-line (using-context context
                             (transform (car (last code)))))
             (first (mapcar 'transform (subseq code 0 (1- (length code))))))
       (append first (list last-line))))
  
  
  (defun pyel-def (name args body decoratorlist returns)
    
      (let ((name (read (_to- name))))
        
        (when (context-p 'function-def)
          (push name let-arglist)) ;;do this before the let-arglists gets overridden for this transform
        
        (let* ((func 'defun)
               t-body
               arglist
               first
               last-line
               
               ;;trans-template vars
               (assign-defaults (list pyel-nothing));;holds assignment code set by the arguments transform
               return-middle 
               let-arglist
               global-vars
               docstring
               
                ;;;
               (ret pyel-nothing)
               (args (using-context function-def (transform (car args))))
               (inner-defun (context-p 'function-def))
               (orig-name name)
               setq-code
               )
    
          
          (when (or (context-p 'lambda-def)
                    inner-defun)
            (setq func 'lambda
                  name pyel-nothing))
    
          
          (using-context
           function-def
           (cond
            
            ((context-p 'class-def) (using-context method-def
                                      (setq last-line (using-context last-function-line
                                                                     (transform (car (last body))))
                                            first (mapcar 'transform (subseq body 0 (1- (length body))))
                                            t-body (append first (list last-line)))
                                      
                                      ;;TODO: let-arlist for methods like
                                      ;;      and *args ...
                                      (push `(defmethod ,name
                                               ((,(car args) ,class-def-name)
                                                ,@(cdr args))
                                               
                                               ,@t-body)
                                            class-def-methods)))
            
            (t (setq last-line (using-context last-function-line
                                              (transform (car (last body))))
                     first (subseq body 0 (1- (length body)))
                     first (if first
                               (mapcar 'transform first)
                             nil)
                     t-body (append first (list last-line)))
               
               ;;(setq t-body (transform-last-with-context
               ;;                'last-function-line body))
               
               ;;remove variables from the let arglist that have been declared global
               (setq let-arglist (let (arglist) (mapcar (lambda (x)
                                                          (unless (member x global-vars)
                                                            (push x arglist)))
                                                        let-arglist)
                                      arglist))
               ;;      ?remove variables that are defined in emacs?
               
               (setq docstring 
                     (if (stringp (car t-body))
                         (pop t-body)
                       pyel-nothing))
               
               (when return-middle
                 (setq ret '(catch '__return__)))
    
               (if let-arglist
                   (setq let-arglist (list '@ 'let let-arglist))
                 (setq let-arglist '@))
    
               (if inner-defun
                   (setq setq-code (list '@ 'setq orig-name))
                 (setq setq-code '@))
    
               `(,setq-code (,func ,name ,args
                                   ,docstring
                                   ,@assign-defaults
                                   (,let-arglist
                                    (,@ret
                                     ,@t-body
                                     ))))
               
               ))))))
  
  
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
   def FunctionDef(name, args, body, decorator_list, returns):
       return " ".join(map(str, ["(def \"", name,"\"", ll_str(args), ll_str(body), decorator_list or "nil",returns or "nil",")"]))
  
      
  
  def arg(arg,annotation):
      return "(arg \"" + arg + "\" " + " " + (annotation or "nil") + ")"
#+END_SRC
** tests
(pyel-create-tests 'def
"def a(b,c):
  print('ok')
  a=b"

"def a(b,c):
  if (a==b()):
    c()
    while (a < d.b):
      b,c = 1,3
  a.b.c = [a,(2,2)]"

"def a():
  return time()"

"def a(x,y=2,z=4):
 print(z)"
"def a(x=1,y=2,z=4):
 print(z)"
"def a(x,y,z=4):
 print(z)"
"def a(x,y,z=4,*g):
 print(z)"

;;optional and variable args 
"def pyel_test(a,b=1,*c):
 if ab:
  x = a+b
 y = 3
 _a_()
 z.a = 4"
)

#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-def-full-transform nil
    (should
     (equal
      (pyel "def a(b,c):\n  print('ok')\n  a=b")
      '(defun a
         (b c)
         (let
             (a)
           (print "ok")
           (pyel-set a b)))))
    (should
     (equal
      (pyel "def a(b,c):\n  if (a==b()):\n    c()\n    while (a < d.b):\n      b,c = 1,3\n  a.b.c = [a,(2,2)]")
      '(defun a
         (b c)
         (let
             (b c)
           (if
               (pyel-== a
                        (b))
               (progn
                 (c)
                 (while
                     (pyel-< a
                             (oref d b))
                   (let
                       ((__1__ 1)
                        (__2__ 3))
                     (pyel-set b __1__)
                     (pyel-set c __2__)))))
           (oset
            (oref a b)
            c
            (list a
                  (vector 2 2)))))))
    (should
     (equal
      (pyel "def a():\n  return time()")
      '(defun a nil
         (time))))
    (should
     (equal
      (pyel "def a(x,y=2,z=4):\n print(z)")
      '(defun a
         (x &optional y z)
         (setq z
               (or z 4))
         (setq y
               (or y 2))
         (print z))))
    (should
     (equal
      (pyel "def a(x=1,y=2,z=4):\n print(z)")
      '(defun a
         (&optional x y z)
         (setq z
               (or z 4))
         (setq y
               (or y 2))
         (setq x
               (or x 1))
         (print z))))
    (should
     (equal
      (pyel "def a(x,y,z=4):\n print(z)")
      '(defun a
         (x y &optional z)
         (setq z
               (or z 4))
         (print z))))
    (should
     (equal
      (pyel "def a(x,y,z=4,*g):\n print(z)")
      '(defun a
         (x y &optional z &rest g)
         (setq z
               (or z 4))
         (print z))))
    (should
     (equal
      (pyel "def pyel_test(a,b=1,*c):\n if ab:\n  x = a+b\n y = 3\n _a_()\n z.a = 4")
      '(defun pyel-test
         (a &optional b &rest c)
         (setq b
               (or b 1))
         (let
             (x y)
           (if ab
               (pyel-set x
                         (pyel-+ a b)))
           (pyel-set y 3)
           (-a-)
           (oset z a 4))))))
  (ert-deftest pyel-def-py-ast nil
    (should
     (equal
      (py-ast "def a(b,c):\n  print('ok')\n  a=b")
      "Module(body=[FunctionDef(name='a', args=arguments(args=[arg(arg='b', annotation=None), arg(arg='c', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='ok')], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='a', ctx=Store())], value=Name(id='b', ctx=Load()))], decorator_list=[], returns=None)])\n"))
    (should
     (equal
      (py-ast "def a(b,c):\n  if (a==b()):\n    c()\n    while (a < d.b):\n      b,c = 1,3\n  a.b.c = [a,(2,2)]")
      "Module(body=[FunctionDef(name='a', args=arguments(args=[arg(arg='b', annotation=None), arg(arg='c', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Call(func=Name(id='b', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)]), body=[Expr(value=Call(func=Name(id='c', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), While(test=Compare(left=Name(id='a', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='d', ctx=Load()), attr='b', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='b', ctx=Store()), Name(id='c', ctx=Store())], ctx=Store())], value=Tuple(elts=[Num(n=1), Num(n=3)], ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Load()), attr='c', ctx=Store())], value=List(elts=[Name(id='a', ctx=Load()), Tuple(elts=[Num(n=2), Num(n=2)], ctx=Load())], ctx=Load()))], decorator_list=[], returns=None)])\n"))
    (should
     (equal
      (py-ast "def a():\n  return time()")
      "Module(body=[FunctionDef(name='a', args=arguments(args=[], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Return(value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))], decorator_list=[], returns=None)])\n"))
    (should
     (equal
      (py-ast "def a(x,y=2,z=4):\n print(z)")
      "Module(body=[FunctionDef(name='a', args=arguments(args=[arg(arg='x', annotation=None), arg(arg='y', annotation=None), arg(arg='z', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[Num(n=2), Num(n=4)], kw_defaults=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='z', ctx=Load())], keywords=[], starargs=None, kwargs=None))], decorator_list=[], returns=None)])\n"))
    (should
     (equal
      (py-ast "def a(x=1,y=2,z=4):\n print(z)")
      "Module(body=[FunctionDef(name='a', args=arguments(args=[arg(arg='x', annotation=None), arg(arg='y', annotation=None), arg(arg='z', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[Num(n=1), Num(n=2), Num(n=4)], kw_defaults=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='z', ctx=Load())], keywords=[], starargs=None, kwargs=None))], decorator_list=[], returns=None)])\n"))
    (should
     (equal
      (py-ast "def a(x,y,z=4):\n print(z)")
      "Module(body=[FunctionDef(name='a', args=arguments(args=[arg(arg='x', annotation=None), arg(arg='y', annotation=None), arg(arg='z', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[Num(n=4)], kw_defaults=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='z', ctx=Load())], keywords=[], starargs=None, kwargs=None))], decorator_list=[], returns=None)])\n"))
    (should
     (equal
      (py-ast "def a(x,y,z=4,*g):\n print(z)")
      "Module(body=[FunctionDef(name='a', args=arguments(args=[arg(arg='x', annotation=None), arg(arg='y', annotation=None), arg(arg='z', annotation=None)], vararg='g', varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[Num(n=4)], kw_defaults=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='z', ctx=Load())], keywords=[], starargs=None, kwargs=None))], decorator_list=[], returns=None)])\n"))
    (should
     (equal
      (py-ast "def pyel_test(a,b=1,*c):\n if ab:\n  x = a+b\n y = 3\n _a_()\n z.a = 4")
      "Module(body=[FunctionDef(name='pyel_test', args=arguments(args=[arg(arg='a', annotation=None), arg(arg='b', annotation=None)], vararg='c', varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[Num(n=1)], kw_defaults=[]), body=[If(test=Name(id='ab', ctx=Load()), body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='a', ctx=Load()), op=Add(), right=Name(id='b', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='y', ctx=Store())], value=Num(n=3)), Expr(value=Call(func=Name(id='_a_', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Attribute(value=Name(id='z', ctx=Load()), attr='a', ctx=Store())], value=Num(n=4))], decorator_list=[], returns=None)])\n")))
  (ert-deftest pyel-def-el-ast nil
    (should
     (string=
      (pyel "def a(b,c):\n  print('ok')\n  a=b" t)
      "(def \" a \" ((arguments  ((arg \"b\"  nil) (arg \"c\"  nil)) nil nil nil nil nil nil nil )) ((call  (name  \"print\" 'load) ((str \"ok\")) nil nil nil) (assign  ((name  \"a\" 'store)) (name  \"b\" 'load))) nil nil )\n"))
    (should
     (string=
      (pyel "def a(b,c):\n  if (a==b()):\n    c()\n    while (a < d.b):\n      b,c = 1,3\n  a.b.c = [a,(2,2)]" t)
      "(def \" a \" ((arguments  ((arg \"b\"  nil) (arg \"c\"  nil)) nil nil nil nil nil nil nil )) ((if  (compare  (name  \"a\" 'load) (\"==\") ((call  (name  \"b\" 'load) nil nil nil nil))) ((call  (name  \"c\" 'load) nil nil nil nil) (while  (compare  (name  \"a\" 'load) (\"<\") ((attribute  (name  \"d\" 'load) \"b\" 'load))) ((assign  ((tuple  ((name  \"b\" 'store) (name  \"c\" 'store)) 'store)) (tuple  ((num 1) (num 3)) 'load))) nil)) nil) (assign  ((attribute  (attribute  (name  \"a\" 'load) \"b\" 'load) \"c\" 'store)) (list ((name  \"a\" 'load) (tuple  ((num 2) (num 2)) 'load)) 'load))) nil nil )\n"))
    (should
     (string=
      (pyel "def a():\n  return time()" t)
      "(def \" a \" ((arguments  nil nil nil nil nil nil nil nil )) ((return (call  (name  \"time\" 'load) nil nil nil nil))) nil nil )\n"))
    (should
     (string=
      (pyel "def a(x,y=2,z=4):\n print(z)" t)
      "(def \" a \" ((arguments  ((arg \"x\"  nil) (arg \"y\"  nil) (arg \"z\"  nil)) nil nil nil nil nil ((num 2) (num 4)) nil )) ((call  (name  \"print\" 'load) ((name  \"z\" 'load)) nil nil nil)) nil nil )\n"))
    (should
     (string=
      (pyel "def a(x=1,y=2,z=4):\n print(z)" t)
      "(def \" a \" ((arguments  ((arg \"x\"  nil) (arg \"y\"  nil) (arg \"z\"  nil)) nil nil nil nil nil ((num 1) (num 2) (num 4)) nil )) ((call  (name  \"print\" 'load) ((name  \"z\" 'load)) nil nil nil)) nil nil )\n"))
    (should
     (string=
      (pyel "def a(x,y,z=4):\n print(z)" t)
      "(def \" a \" ((arguments  ((arg \"x\"  nil) (arg \"y\"  nil) (arg \"z\"  nil)) nil nil nil nil nil ((num 4)) nil )) ((call  (name  \"print\" 'load) ((name  \"z\" 'load)) nil nil nil)) nil nil )\n"))
    (should
     (string=
      (pyel "def a(x,y,z=4,*g):\n print(z)" t)
      "(def \" a \" ((arguments  ((arg \"x\"  nil) (arg \"y\"  nil) (arg \"z\"  nil)) g nil nil nil nil ((num 4)) nil )) ((call  (name  \"print\" 'load) ((name  \"z\" 'load)) nil nil nil)) nil nil )\n"))
    (should
     (string=
      (pyel "def pyel_test(a,b=1,*c):\n if ab:\n  x = a+b\n y = 3\n _a_()\n z.a = 4" t)
      "(def \" pyel_test \" ((arguments  ((arg \"a\"  nil) (arg \"b\"  nil)) c nil nil nil nil ((num 1)) nil )) ((if  (name  \"ab\" 'load) ((assign  ((name  \"x\" 'store)) (bin-op  (name  \"a\" 'load) + (name  \"b\" 'load)))) nil) (assign  ((name  \"y\" 'store)) (num 3)) (call  (name  \"_a_\" 'load) nil nil nil nil) (assign  ((attribute  (name  \"z\" 'load) \"a\" 'store)) (num 4))) nil nil )\n")))
  
#+END_SRC

* bin-op, +, -, *, /, **, |, &
::Q can an overloaded + operator obj be used like:  3+obj
    these transforms assume you can
TODO: FIX: most of these are wrong.
      if one arg is a number, then the other may still be an object
overloadable operators: http://rgruet.free.fr/PQR26/PQR2.6.html#SpecialMethods

emacs bitwise operators: http://www.gnu.org/software/emacs/manual/html_node/elisp/Bitwise-Operations.html

** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform bin-op pyel ()
      (lambda (left op right)
        (call-transform op left right)))
    
    
  (pyel-create-py-func * (l r)
                      (number number) ->  (* l r)
                      (object _)      
                      (_ object)      -> (--mul-- l r)
                      (_ string)
                      (string _)      -> (pyel-mul-num-str l r))
    
    (pyel-create-py-func + (lhs rhs)
                      ;;this presumes that both args are the same type
                      (number number)  -> (+ lhs rhs)
                      (string _)
                      (_ string)       -> (concat lhs rhs)
                      (list _)
                      (_ list)         -> (append lhs rhs)
                      (vector _)
                      (_ vector)       -> (vconcat lhs rhs) ;;faster way?
                      ;;should the right side be checked if its an object?
                      (object _)
                      (_ object)       -> (--add-- lhs rhs));;correct way to call it?
    
  
  (pyel-create-py-func - (l r)
                    (number number) -> (- l r)
                    (object _)
                    (_ object) -> (--sub-- l r))
  
  
  (pyel-create-py-func ** (l r) ;;pow
                    (number number) -> (expt l r)
                    (object _)
                    (_ object) -> (--pow-- l r))
  
  
  
  (pyel-create-py-func / (l r)
                       ;; (float _)
                       ;; (_ float) -> (/ l r)
                       (number _)
                       (_ number) -> (/ (* l 1.0) r)
                       (object _) -> (--truediv-- l r))
  ;;                    (_ object) ;;?
  
  
  (pyel-create-py-func // (l r) ;;floored (normal) division 
                       (number _)
                       (_ number) -> (/ l r)
                       (object _) -> (--floordiv-- l r))
  ;;                    (_ object) ;;?
  
  (pyel-create-py-func ^ (l r) ;;bit xor
                    (number number) -> (logxor l r)
                    (object _)
                    (_ object) -> (--xor-- l r))
  
  (pyel-create-py-func & (l r) ;;bit and
                    (number number) -> (logand l r)
                    (object _)
                    (_ object) -> (--and-- l r)) ;;?
  
  (pyel-create-py-func | (l r) ;;bit or
                    (number number) -> (logior l r)
                    (object _)
                    (_ object) -> (--or-- l r));;?
  
  
  (pyel-create-py-func % (l r) ;;bit or
                       (number number) -> (% l r)
                       (object _) -> (--mod-- l r));;?
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def BinOp(left, op, right):
      return l_str(["bin-op ", left, op, right])
        
  def Add():
      return "+"
  
  def Mult():
      return "*"
  def Sub():
      return "-"
  def Div():
      return "/"
  def FloorDiv():
      return "//"
  def Pow():
      return "**"
  def BitXor():
      return "^"
  def BitOr():
      return "|"
  def BitAnd():
      return "&"
  def Mod():
      return "%"
#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests TODO
(pyel-create-tests 'binop
"assert 1//2 == 0"
"assert 1/2 == 0.5")

#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-binop-full-transform nil
    (should
     (equal
      (pyel "assert 1//2 == 0")
      '(assert
        (pyel-==
         (pyel-// 1 2)
         0)
        t nil)))
    (should
     (equal
      (pyel "assert 1/2 == 0.5")
      '(assert
        (pyel-==
         (pyel-/ 1 2)
         0.5)
        t nil))))
  (ert-deftest pyel-binop-py-ast nil
    (should
     (equal
      (py-ast "assert 1//2 == 0")
      "Module(body=[Assert(test=Compare(left=BinOp(left=Num(n=1), op=FloorDiv(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "assert 1/2 == 0.5")
      "Module(body=[Assert(test=Compare(left=BinOp(left=Num(n=1), op=Div(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0.5)]), msg=None)])\n")))
  (ert-deftest pyel-binop-el-ast nil
    (should
     (string=
      (pyel "assert 1//2 == 0" t)
      "(assert  (compare  (bin-op  (num 1) // (num 2)) (\"==\") ((num 0))) nil)\n"))
    (should
     (string=
      (pyel "assert 1/2 == 0.5" t)
      "(assert  (compare  (bin-op  (num 1) / (num 2)) (\"==\") ((num 0.5))) nil)\n")))
  
#+END_SRC

* subscript,index,slice
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  
  (defclass PySlice nil ;;TODO: name?
    ((start :initarg :start)
     (end :initarg :end)
     (step :initarg :step)))
  
  
  (def-transform index pyel ()
    (lambda (value)
      (transform value)))
  
  (def-transform slice pyel ()
    (lambda (lower upper step)
      (PySlice "slice"
               :start (transform lower)
               :end (transform upper)
               :step (transform step))))
  
  
  (def-transform subscript pyel ()
    (lambda (value slice ctx)
      (pyel-subscript value slice ctx)))
  
  (pyel-create-py-func subscript-load-index (name value) 
                       (list _) -> (nth value name)
                       (object _) -> (--getitem-- name value)
                       (vector _) -> (aref name value)
                       (string _) -> (char-to-string (aref name value))
                       (hash _) -> (gethash value name))
  
  
  (pyel-create-py-func subscript-load-slice (name start end step)
                       (object _ _ _) -> (--getitem-- name (PySlice "slice"
                                                                     :start start
                                                                     :end  end
                                                                     :step  step))
                       ;;TODO implement step
                       (_ _ _ _) -> (subseq name start end))
  
  (pyel-create-py-func subscript-store-slice (name start end step assign)
                       (object _ _ _) -> (--setitem-- name
                                                      (PySlice "slice"
                                                               :start start
                                                               :end  end
                                                               :step  step)
                                                      assign)
                       
                       ;;TODO implement step
                       (_ _ _ _) -> (setf (subseq name start end) assign))
  
  (pyel-create-py-func subscript-store-index (name value assign) 
                       (list _) -> (setf (nth value name) assign)
                       (object _) -> (--setitem-- name value assign)
                       (vector _) -> (setf (aref name value) assign)
                       (hash _) -> (puthash value assign name))
  ;;                  (string _) -> not supported in python
  
  
  
  (defun pyel-subscript (value slice ctx)
    (let* (;(value (transform value))
           (slice (transform slice))
           (ctx (cond ((context-p 'force-load) 'load)
                      ((context-p 'force-store) 'store)
                      (t (eval ctx))))
           start stop step)
      
      (when (object-p slice)
        (setq start (oref slice start)
              stop (oref slice end)
              step (oref slice step)))
      (if (eq ctx 'load)
          (if (object-p slice)
              (call-transform 'subscript-load-slice value start stop step) ;;load slice
            (call-transform 'subscript-load-index value slice)) ;;load index
        ;;else: store
        (if (object-p slice)
            (call-transform 'subscript-store-slice value start stop step assign-value)
          (call-transform 'subscript-store-index value slice assign-value)) ;;load index
        
        ;;      (test value start stop step assign-value)
        )))
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Slice(lower, upper, step):
      step = step or "nil"
      lower = lower or 0
      upper = upper or "nil"
      return l_str(["slice", lower, upper, step])
        
  def Index(value):
      return "(index " + value + ")"
        
  def Subscript(value,slice,ctx):
      return ll_str(["subscript", value,slice,ctx])
        
    
    
#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests
 'subscript
 ;;load index====
 ;;string
 "a = '1X23'
assert a[1] == 'X'"
 ;;list
 "a = [1,2,3,4]
assert a[1] == 2"
 ;;vector
 "a = (1,2,3,4)
assert a[1] == 2"
 ;;object
 "class a:
 def __getitem__ (self, value):
  return value + 4
x = a()
assert x[1] == 5"
 ;;=load slice====
 ;;vector
 "a = (1,2,3,4,5)
assert a[1:4] == (2,3,4)
assert a[:4] == (1,2,3,4)
assert a[2:] == (3,4,5)
assert a[:] == (1,2,3,4,5)"
 ;;list
 "a = [1,2,3,4,5]
assert a[1:4] == [2,3,4]
assert a[:4] == [1,2,3,4]
assert a[2:] == [3,4,5]
assert a[:] == [1,2,3,4,5]"
 ;;strings
 "a = '012345678'
assert a[1:4] == '123'
assert a[:4] == '0123'
assert a[2:] == '2345678'
assert a[:] == '012345678'"
 ;;object
 "class a:
 def __getitem__ (self, value):
  return value.start + value.end
x = a()
assert x[1:2] == 3
assert x[5:7] == 12"

 ;;store index
 ;; list
 "def __add(a,b):
 return a+b
a = [1,2,3,4]
a[0] = __add(a[1],a[2])
assert a[0] == 5
a[2] = 'str'
assert a[2] == 'str'"
 ;;vector
 "a = (1,2,3,4)
a[0] = a[1] + a[2]
assert aa[0] == 5
a[2] = 'str'
assert a[2] == 'str'"
 ;;object
 "class a:
 def __setitem__ (self, index, value):
  self.index = index
  self.value = value
x = a()
x[3] = 5
assert x.index == 3
assert x.value == 5"

 ;;store slice
 ;;list
 "a = [1,2,3,4,5,6]
a[1:4] = [5,4,'f']
assert a == [1,5,4,'f',5,6]
a[:3] = ['a',4,2.2]
assert a == ['a',4,2.2,'f',5,6]
a[3:] = [3,3]
assert a == ['a', 4, 2.2, 3, 3, 6]#TODO: should == ['a', 4, 2.2, 3, 3]"
 ;;vector
 "a = (1,2,3,4,5,6)
a[1:4] = (5,4,'f')
assert a == (1,5,4,'f',5,6)
a[:3] = ('a',4,2.2)
assert a == ('a',4,2.2,'f',5,6)
a[3:] = (3,3)
assert a == ('a', 4, 2.2, 3, 3, 6)#TODO: should == ('a', 4, 2.2, 3, 3)"
 ;;string
 "a = '123456'
a[1:4] = '54f'
assert a == '154f56'
a[:3] = 'a42'
assert a == 'a42f56'
a[3:] = '33'
assert a == 'a42336'#TODO: should == 'a4233'"
 ;;object
 "class a:
 def __setitem__ (self, index, value):
  self.start = index.start
  self.end = index.end
  self.step = index.step
  self.value = value
x = a()
x[2:3] = [1,2,3]
assert x.start == 2
assert x.end == 3
assert x.value == [1,2,3]"

"a[2] += 3"
"a[2] += b[3]"

"[2,3,3][2]"
"assert [1,2,(3,2,8)][2][2] == 8"
 )

#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-subscript-full-transform nil
    (should
     (equal
      (pyel "a = '1X23'\nassert a[1] == 'X'")
      '(progn
         (pyel-set a "1X23")
         (assert
          (pyel-==
           (pyel-subscript-load-index a 1)
           "X")
          t nil))))
    (should
     (equal
      (pyel "a = [1,2,3,4]\nassert a[1] == 2")
      '(progn
         (pyel-set a
                   (list 1 2 3 4))
         (assert
          (pyel-==
           (pyel-subscript-load-index a 1)
           2)
          t nil))))
    (should
     (equal
      (pyel "a = (1,2,3,4)\nassert a[1] == 2")
      '(progn
         (pyel-set a
                   (vector 1 2 3 4))
         (assert
          (pyel-==
           (pyel-subscript-load-index a 1)
           2)
          t nil))))
    (should
     (equal
      (pyel "class a:\n def __getitem__ (self, value):\n  return value + 4\nx = a()\nassert x[1] == 5")
      '(progn
         (defclass a nil nil "pyel class")
         (defmethod --getitem--
           ((self a)
            value)
           (pyel-+ value 4))
         (defmethod --init--
           ((self a))
           "Default initializer")
         (pyel-set x
                   (let
                       ((__c
                         (a "obj")))
                     (--init-- __c)
                     __c))
         (assert
          (pyel-==
           (pyel-subscript-load-index x 1)
           5)
          t nil))))
    (should
     (equal
      (pyel "a = (1,2,3,4,5)\nassert a[1:4] == (2,3,4)\nassert a[:4] == (1,2,3,4)\nassert a[2:] == (3,4,5)\nassert a[:] == (1,2,3,4,5)")
      '(progn
         (pyel-set a
                   (vector 1 2 3 4 5))
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 1 4 nil)
           (vector 2 3 4))
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 0 4 nil)
           (vector 1 2 3 4))
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 2 nil nil)
           (vector 3 4 5))
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 0 nil nil)
           (vector 1 2 3 4 5))
          t nil))))
    (should
     (equal
      (pyel "a = [1,2,3,4,5]\nassert a[1:4] == [2,3,4]\nassert a[:4] == [1,2,3,4]\nassert a[2:] == [3,4,5]\nassert a[:] == [1,2,3,4,5]")
      '(progn
         (pyel-set a
                   (list 1 2 3 4 5))
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 1 4 nil)
           (list 2 3 4))
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 0 4 nil)
           (list 1 2 3 4))
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 2 nil nil)
           (list 3 4 5))
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 0 nil nil)
           (list 1 2 3 4 5))
          t nil))))
    (should
     (equal
      (pyel "a = '012345678'\nassert a[1:4] == '123'\nassert a[:4] == '0123'\nassert a[2:] == '2345678'\nassert a[:] == '012345678'")
      '(progn
         (pyel-set a "012345678")
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 1 4 nil)
           "123")
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 0 4 nil)
           "0123")
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 2 nil nil)
           "2345678")
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice a 0 nil nil)
           "012345678")
          t nil))))
    (should
     (equal
      (pyel "class a:\n def __getitem__ (self, value):\n  return value.start + value.end\nx = a()\nassert x[1:2] == 3\nassert x[5:7] == 12")
      '(progn
         (defclass a nil
           ((start :initarg :start :initform nil)
            (end :initarg :end :initform nil))
           "pyel class")
         (defmethod --getitem--
           ((self a)
            value)
           (pyel-+
            (oref value start)
            (oref value end)))
         (defmethod --init--
           ((self a))
           "Default initializer")
         (pyel-set x
                   (let
                       ((__c
                         (a "obj")))
                     (--init-- __c)
                     __c))
         (assert
          (pyel-==
           (pyel-subscript-load-slice x 1 2 nil)
           3)
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-slice x 5 7 nil)
           12)
          t nil))))
    (should
     (equal
      (pyel "def __add(a,b):\n return a+b\na = [1,2,3,4]\na[0] = __add(a[1],a[2])\nassert a[0] == 5\na[2] = 'str'\nassert a[2] == 'str'")
      '(progn
         (defun --add
           (a b)
           (pyel-+ a b))
         (pyel-set a
                   (list 1 2 3 4))
         (pyel-subscript-store-index a 0
                                     (--add
                                      (pyel-subscript-load-index a 1)
                                      (pyel-subscript-load-index a 2)))
         (assert
          (pyel-==
           (pyel-subscript-load-index a 0)
           5)
          t nil)
         (pyel-subscript-store-index a 2 "str")
         (assert
          (pyel-==
           (pyel-subscript-load-index a 2)
           "str")
          t nil))))
    (should
     (equal
      (pyel "a = (1,2,3,4)\na[0] = a[1] + a[2]\nassert aa[0] == 5\na[2] = 'str'\nassert a[2] == 'str'")
      '(progn
         (pyel-set a
                   (vector 1 2 3 4))
         (pyel-subscript-store-index a 0
                                     (pyel-+
                                      (pyel-subscript-load-index a 1)
                                      (pyel-subscript-load-index a 2)))
         (assert
          (pyel-==
           (pyel-subscript-load-index aa 0)
           5)
          t nil)
         (pyel-subscript-store-index a 2 "str")
         (assert
          (pyel-==
           (pyel-subscript-load-index a 2)
           "str")
          t nil))))
    (should
     (equal
      (pyel "class a:\n def __setitem__ (self, index, value):\n  self.index = index\n  self.value = value\nx = a()\nx[3] = 5\nassert x.index == 3\nassert x.value == 5")
      '(progn
         (defclass a nil
           ((value :initarg :value :initform nil)
            (index :initarg :index :initform nil))
           "pyel class")
         (defmethod --setitem--
           ((self a)
            index value)
           (oset self index index)
           (oset self value value))
         (defmethod --init--
           ((self a))
           "Default initializer")
         (pyel-set x
                   (let
                       ((__c
                         (a "obj")))
                     (--init-- __c)
                     __c))
         (pyel-subscript-store-index x 3 5)
         (assert
          (pyel-==
           (oref x index)
           3)
          t nil)
         (assert
          (pyel-==
           (oref x value)
           5)
          t nil))))
    (should
     (equal
      (pyel "a = [1,2,3,4,5,6]\na[1:4] = [5,4,'f']\nassert a == [1,5,4,'f',5,6]\na[:3] = ['a',4,2.2]\nassert a == ['a',4,2.2,'f',5,6]\na[3:] = [3,3]\nassert a == ['a', 4, 2.2, 3, 3, 6]#TODO: should == ['a', 4, 2.2, 3, 3]")
      '(progn
         (pyel-set a
                   (list 1 2 3 4 5 6))
         (pyel-subscript-store-slice a 1 4 nil
                                     (list 5 4 "f"))
         (assert
          (pyel-== a
                   (list 1 5 4 "f" 5 6))
          t nil)
         (pyel-subscript-store-slice a 0 3 nil
                                     (list "a" 4 2.2))
         (assert
          (pyel-== a
                   (list "a" 4 2.2 "f" 5 6))
          t nil)
         (pyel-subscript-store-slice a 3 nil nil
                                     (list 3 3))
         (assert
          (pyel-== a
                   (list "a" 4 2.2 3 3 6))
          t nil))))
    (should
     (equal
      (pyel "a = (1,2,3,4,5,6)\na[1:4] = (5,4,'f')\nassert a == (1,5,4,'f',5,6)\na[:3] = ('a',4,2.2)\nassert a == ('a',4,2.2,'f',5,6)\na[3:] = (3,3)\nassert a == ('a', 4, 2.2, 3, 3, 6)#TODO: should == ('a', 4, 2.2, 3, 3)")
      '(progn
         (pyel-set a
                   (vector 1 2 3 4 5 6))
         (pyel-subscript-store-slice a 1 4 nil
                                     (vector 5 4 "f"))
         (assert
          (pyel-== a
                   (vector 1 5 4 "f" 5 6))
          t nil)
         (pyel-subscript-store-slice a 0 3 nil
                                     (vector "a" 4 2.2))
         (assert
          (pyel-== a
                   (vector "a" 4 2.2 "f" 5 6))
          t nil)
         (pyel-subscript-store-slice a 3 nil nil
                                     (vector 3 3))
         (assert
          (pyel-== a
                   (vector "a" 4 2.2 3 3 6))
          t nil))))
    (should
     (equal
      (pyel "a = '123456'\na[1:4] = '54f'\nassert a == '154f56'\na[:3] = 'a42'\nassert a == 'a42f56'\na[3:] = '33'\nassert a == 'a42336'#TODO: should == 'a4233'")
      '(progn
         (pyel-set a "123456")
         (pyel-subscript-store-slice a 1 4 nil "54f")
         (assert
          (pyel-== a "154f56")
          t nil)
         (pyel-subscript-store-slice a 0 3 nil "a42")
         (assert
          (pyel-== a "a42f56")
          t nil)
         (pyel-subscript-store-slice a 3 nil nil "33")
         (assert
          (pyel-== a "a42336")
          t nil))))
    (should
     (equal
      (pyel "class a:\n def __setitem__ (self, index, value):\n  self.start = index.start\n  self.end = index.end\n  self.step = index.step\n  self.value = value\nx = a()\nx[2:3] = [1,2,3]\nassert x.start == 2\nassert x.end == 3\nassert x.value == [1,2,3]")
      '(progn
         (defclass a nil
           ((value :initarg :value :initform nil)
            (start :initarg :start :initform nil)
            (end :initarg :end :initform nil)
            (step :initarg :step :initform nil))
           "pyel class")
         (defmethod --setitem--
           ((self a)
            index value)
           (oset self start
                 (oref index start))
           (oset self end
                 (oref index end))
           (oset self step
                 (oref index step))
           (oset self value value))
         (defmethod --init--
           ((self a))
           "Default initializer")
         (pyel-set x
                   (let
                       ((__c
                         (a "obj")))
                     (--init-- __c)
                     __c))
         (pyel-subscript-store-slice x 2 3 nil
                                     (list 1 2 3))
         (assert
          (pyel-==
           (oref x start)
           2)
          t nil)
         (assert
          (pyel-==
           (oref x end)
           3)
          t nil)
         (assert
          (pyel-==
           (oref x value)
           (list 1 2 3))
          t nil))))
    (should
     (equal
      (pyel "a[2] += 3")
      '(pyel-subscript-store-index a 2
                                   (pyel-+
                                    (pyel-subscript-load-index a 2)
                                    3))))
    (should
     (equal
      (pyel "a[2] += b[3]")
      '(pyel-subscript-store-index a 2
                                   (pyel-+
                                    (pyel-subscript-load-index a 2)
                                    (pyel-subscript-load-index b 3)))))
    (should
     (equal
      (pyel "[2,3,3][2]")
      '(pyel-subscript-load-index
        (list 2 3 3)
        2)))
    (should
     (equal
      (pyel "assert [1,2,(3,2,8)][2][2] == 8")
      '(assert
        (pyel-==
         (pyel-subscript-load-index
          (pyel-subscript-load-index
           (list 1 2
                 (vector 3 2 8))
           2)
          2)
         8)
        t nil))))
  (ert-deftest pyel-subscript-py-ast nil
    (should
     (equal
      (py-ast "a = '1X23'\nassert a[1] == 'X'")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Str(s='1X23')), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Str(s='X')]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = [1,2,3,4]\nassert a[1] == 2")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=List(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4)], ctx=Load())), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Num(n=2)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = (1,2,3,4)\nassert a[1] == 2")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Tuple(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4)], ctx=Load())), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Num(n=2)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "class a:\n def __getitem__ (self, value):\n  return value + 4\nx = a()\nassert x[1] == 5")
      "Module(body=[ClassDef(name='a', bases=[], keywords=[], starargs=None, kwargs=None, body=[FunctionDef(name='__getitem__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Return(value=BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Num(n=4)))], decorator_list=[], returns=None)], decorator_list=[]), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='a', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assert(test=Compare(left=Subscript(value=Name(id='x', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Num(n=5)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = (1,2,3,4,5)\nassert a[1:4] == (2,3,4)\nassert a[:4] == (1,2,3,4)\nassert a[2:] == (3,4,5)\nassert a[:] == (1,2,3,4,5)")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Tuple(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4), Num(n=5)], ctx=Load())), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=1), upper=Num(n=4), step=None), ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Num(n=2), Num(n=3), Num(n=4)], ctx=Load())]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=None, upper=Num(n=4), step=None), ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4)], ctx=Load())]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Num(n=3), Num(n=4), Num(n=5)], ctx=Load())]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4), Num(n=5)], ctx=Load())]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = [1,2,3,4,5]\nassert a[1:4] == [2,3,4]\nassert a[:4] == [1,2,3,4]\nassert a[2:] == [3,4,5]\nassert a[:] == [1,2,3,4,5]")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=List(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4), Num(n=5)], ctx=Load())), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=1), upper=Num(n=4), step=None), ctx=Load()), ops=[Eq()], comparators=[List(elts=[Num(n=2), Num(n=3), Num(n=4)], ctx=Load())]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=None, upper=Num(n=4), step=None), ctx=Load()), ops=[Eq()], comparators=[List(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4)], ctx=Load())]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), ops=[Eq()], comparators=[List(elts=[Num(n=3), Num(n=4), Num(n=5)], ctx=Load())]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), ops=[Eq()], comparators=[List(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4), Num(n=5)], ctx=Load())]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = '012345678'\nassert a[1:4] == '123'\nassert a[:4] == '0123'\nassert a[2:] == '2345678'\nassert a[:] == '012345678'")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Str(s='012345678')), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=1), upper=Num(n=4), step=None), ctx=Load()), ops=[Eq()], comparators=[Str(s='123')]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=None, upper=Num(n=4), step=None), ctx=Load()), ops=[Eq()], comparators=[Str(s='0123')]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), ops=[Eq()], comparators=[Str(s='2345678')]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), ops=[Eq()], comparators=[Str(s='012345678')]), msg=None)])\n"))
    (should
     (equal
      (py-ast "class a:\n def __getitem__ (self, value):\n  return value.start + value.end\nx = a()\nassert x[1:2] == 3\nassert x[5:7] == 12")
      "Module(body=[ClassDef(name='a', bases=[], keywords=[], starargs=None, kwargs=None, body=[FunctionDef(name='__getitem__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Return(value=BinOp(left=Attribute(value=Name(id='value', ctx=Load()), attr='start', ctx=Load()), op=Add(), right=Attribute(value=Name(id='value', ctx=Load()), attr='end', ctx=Load())))], decorator_list=[], returns=None)], decorator_list=[]), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='a', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assert(test=Compare(left=Subscript(value=Name(id='x', ctx=Load()), slice=Slice(lower=Num(n=1), upper=Num(n=2), step=None), ctx=Load()), ops=[Eq()], comparators=[Num(n=3)]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='x', ctx=Load()), slice=Slice(lower=Num(n=5), upper=Num(n=7), step=None), ctx=Load()), ops=[Eq()], comparators=[Num(n=12)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "def __add(a,b):\n return a+b\na = [1,2,3,4]\na[0] = __add(a[1],a[2])\nassert a[0] == 5\na[2] = 'str'\nassert a[2] == 'str'")
      "Module(body=[FunctionDef(name='__add', args=arguments(args=[arg(arg='a', annotation=None), arg(arg='b', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Return(value=BinOp(left=Name(id='a', ctx=Load()), op=Add(), right=Name(id='b', ctx=Load())))], decorator_list=[], returns=None), Assign(targets=[Name(id='a', ctx=Store())], value=List(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4)], ctx=Load())), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Store())], value=Call(func=Name(id='__add', ctx=Load()), args=[Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load())], keywords=[], starargs=None, kwargs=None)), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Num(n=5)]), msg=None), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Store())], value=Str(s='str')), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load()), ops=[Eq()], comparators=[Str(s='str')]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = (1,2,3,4)\na[0] = a[1] + a[2]\nassert aa[0] == 5\na[2] = 'str'\nassert a[2] == 'str'")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Tuple(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4)], ctx=Load())), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Store())], value=BinOp(left=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Add(), right=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load()))), Assert(test=Compare(left=Subscript(value=Name(id='aa', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Num(n=5)]), msg=None), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Store())], value=Str(s='str')), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load()), ops=[Eq()], comparators=[Str(s='str')]), msg=None)])\n"))
    (should
     (equal
      (py-ast "class a:\n def __setitem__ (self, index, value):\n  self.index = index\n  self.value = value\nx = a()\nx[3] = 5\nassert x.index == 3\nassert x.value == 5")
      "Module(body=[ClassDef(name='a', bases=[], keywords=[], starargs=None, kwargs=None, body=[FunctionDef(name='__setitem__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='index', annotation=None), arg(arg='value', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='index', ctx=Store())], value=Name(id='index', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[], returns=None)], decorator_list=[]), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='a', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Subscript(value=Name(id='x', ctx=Load()), slice=Index(value=Num(n=3)), ctx=Store())], value=Num(n=5)), Assert(test=Compare(left=Attribute(value=Name(id='x', ctx=Load()), attr='index', ctx=Load()), ops=[Eq()], comparators=[Num(n=3)]), msg=None), Assert(test=Compare(left=Attribute(value=Name(id='x', ctx=Load()), attr='value', ctx=Load()), ops=[Eq()], comparators=[Num(n=5)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = [1,2,3,4,5,6]\na[1:4] = [5,4,'f']\nassert a == [1,5,4,'f',5,6]\na[:3] = ['a',4,2.2]\nassert a == ['a',4,2.2,'f',5,6]\na[3:] = [3,3]\nassert a == ['a', 4, 2.2, 3, 3, 6]#TODO: should == ['a', 4, 2.2, 3, 3]")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=List(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4), Num(n=5), Num(n=6)], ctx=Load())), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=1), upper=Num(n=4), step=None), ctx=Store())], value=List(elts=[Num(n=5), Num(n=4), Str(s='f')], ctx=Load())), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[List(elts=[Num(n=1), Num(n=5), Num(n=4), Str(s='f'), Num(n=5), Num(n=6)], ctx=Load())]), msg=None), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=None, upper=Num(n=3), step=None), ctx=Store())], value=List(elts=[Str(s='a'), Num(n=4), Num(n=2.2)], ctx=Load())), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[List(elts=[Str(s='a'), Num(n=4), Num(n=2.2), Str(s='f'), Num(n=5), Num(n=6)], ctx=Load())]), msg=None), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=3), upper=None, step=None), ctx=Store())], value=List(elts=[Num(n=3), Num(n=3)], ctx=Load())), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[List(elts=[Str(s='a'), Num(n=4), Num(n=2.2), Num(n=3), Num(n=3), Num(n=6)], ctx=Load())]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = (1,2,3,4,5,6)\na[1:4] = (5,4,'f')\nassert a == (1,5,4,'f',5,6)\na[:3] = ('a',4,2.2)\nassert a == ('a',4,2.2,'f',5,6)\na[3:] = (3,3)\nassert a == ('a', 4, 2.2, 3, 3, 6)#TODO: should == ('a', 4, 2.2, 3, 3)")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Tuple(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4), Num(n=5), Num(n=6)], ctx=Load())), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=1), upper=Num(n=4), step=None), ctx=Store())], value=Tuple(elts=[Num(n=5), Num(n=4), Str(s='f')], ctx=Load())), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Num(n=1), Num(n=5), Num(n=4), Str(s='f'), Num(n=5), Num(n=6)], ctx=Load())]), msg=None), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=None, upper=Num(n=3), step=None), ctx=Store())], value=Tuple(elts=[Str(s='a'), Num(n=4), Num(n=2.2)], ctx=Load())), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Str(s='a'), Num(n=4), Num(n=2.2), Str(s='f'), Num(n=5), Num(n=6)], ctx=Load())]), msg=None), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=3), upper=None, step=None), ctx=Store())], value=Tuple(elts=[Num(n=3), Num(n=3)], ctx=Load())), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Str(s='a'), Num(n=4), Num(n=2.2), Num(n=3), Num(n=3), Num(n=6)], ctx=Load())]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = '123456'\na[1:4] = '54f'\nassert a == '154f56'\na[:3] = 'a42'\nassert a == 'a42f56'\na[3:] = '33'\nassert a == 'a42336'#TODO: should == 'a4233'")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Str(s='123456')), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=1), upper=Num(n=4), step=None), ctx=Store())], value=Str(s='54f')), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Str(s='154f56')]), msg=None), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=None, upper=Num(n=3), step=None), ctx=Store())], value=Str(s='a42')), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Str(s='a42f56')]), msg=None), Assign(targets=[Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=3), upper=None, step=None), ctx=Store())], value=Str(s='33')), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Str(s='a42336')]), msg=None)])\n"))
    (should
     (equal
      (py-ast "class a:\n def __setitem__ (self, index, value):\n  self.start = index.start\n  self.end = index.end\n  self.step = index.step\n  self.value = value\nx = a()\nx[2:3] = [1,2,3]\nassert x.start == 2\nassert x.end == 3\nassert x.value == [1,2,3]")
      "Module(body=[ClassDef(name='a', bases=[], keywords=[], starargs=None, kwargs=None, body=[FunctionDef(name='__setitem__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='index', annotation=None), arg(arg='value', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='start', ctx=Store())], value=Attribute(value=Name(id='index', ctx=Load()), attr='start', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='end', ctx=Store())], value=Attribute(value=Name(id='index', ctx=Load()), attr='end', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='step', ctx=Store())], value=Attribute(value=Name(id='index', ctx=Load()), attr='step', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[], returns=None)], decorator_list=[]), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='a', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Subscript(value=Name(id='x', ctx=Load()), slice=Slice(lower=Num(n=2), upper=Num(n=3), step=None), ctx=Store())], value=List(elts=[Num(n=1), Num(n=2), Num(n=3)], ctx=Load())), Assert(test=Compare(left=Attribute(value=Name(id='x', ctx=Load()), attr='start', ctx=Load()), ops=[Eq()], comparators=[Num(n=2)]), msg=None), Assert(test=Compare(left=Attribute(value=Name(id='x', ctx=Load()), attr='end', ctx=Load()), ops=[Eq()], comparators=[Num(n=3)]), msg=None), Assert(test=Compare(left=Attribute(value=Name(id='x', ctx=Load()), attr='value', ctx=Load()), ops=[Eq()], comparators=[List(elts=[Num(n=1), Num(n=2), Num(n=3)], ctx=Load())]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a[2] += 3")
      "Module(body=[AugAssign(target=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Store()), op=Add(), value=Num(n=3))])\n"))
    (should
     (equal
      (py-ast "a[2] += b[3]")
      "Module(body=[AugAssign(target=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Store()), op=Add(), value=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=3)), ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "[2,3,3][2]")
      "Module(body=[Expr(value=Subscript(value=List(elts=[Num(n=2), Num(n=3), Num(n=3)], ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "assert [1,2,(3,2,8)][2][2] == 8")
      "Module(body=[Assert(test=Compare(left=Subscript(value=Subscript(value=List(elts=[Num(n=1), Num(n=2), Tuple(elts=[Num(n=3), Num(n=2), Num(n=8)], ctx=Load())], ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load()), ops=[Eq()], comparators=[Num(n=8)]), msg=None)])\n")))
  (ert-deftest pyel-subscript-el-ast nil
    (should
     (string=
      (pyel "a = '1X23'\nassert a[1] == 'X'" t)
      "(assign  ((name  \"a\" 'store)) (str \"1X23\"))\n(assert  (compare  (subscript (name  \"a\" 'load) (index (num 1)) 'load) (\"==\") ((str \"X\"))) nil)\n"))
    (should
     (string=
      (pyel "a = [1,2,3,4]\nassert a[1] == 2" t)
      "(assign  ((name  \"a\" 'store)) (list ((num 1) (num 2) (num 3) (num 4)) 'load))\n(assert  (compare  (subscript (name  \"a\" 'load) (index (num 1)) 'load) (\"==\") ((num 2))) nil)\n"))
    (should
     (string=
      (pyel "a = (1,2,3,4)\nassert a[1] == 2" t)
      "(assign  ((name  \"a\" 'store)) (tuple  ((num 1) (num 2) (num 3) (num 4)) 'load))\n(assert  (compare  (subscript (name  \"a\" 'load) (index (num 1)) 'load) (\"==\") ((num 2))) nil)\n"))
    (should
     (string=
      (pyel "class a:\n def __getitem__ (self, value):\n  return value + 4\nx = a()\nassert x[1] == 5" t)
      "(classdef a nil nil nil nil ((def \" __getitem__ \" ((arguments  ((arg \"self\"  nil) (arg \"value\"  nil)) nil nil nil nil nil nil nil )) ((return (bin-op  (name  \"value\" 'load) + (num 4)))) nil nil )) nil)\n(assign  ((name  \"x\" 'store)) (call  (name  \"a\" 'load) nil nil nil nil))\n(assert  (compare  (subscript (name  \"x\" 'load) (index (num 1)) 'load) (\"==\") ((num 5))) nil)\n"))
    (should
     (string=
      (pyel "a = (1,2,3,4,5)\nassert a[1:4] == (2,3,4)\nassert a[:4] == (1,2,3,4)\nassert a[2:] == (3,4,5)\nassert a[:] == (1,2,3,4,5)" t)
      "(assign  ((name  \"a\" 'store)) (tuple  ((num 1) (num 2) (num 3) (num 4) (num 5)) 'load))\n(assert  (compare  (subscript (name  \"a\" 'load) (slice (num 1) (num 4) nil) 'load) (\"==\") ((tuple  ((num 2) (num 3) (num 4)) 'load))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (slice 0 (num 4) nil) 'load) (\"==\") ((tuple  ((num 1) (num 2) (num 3) (num 4)) 'load))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (slice (num 2) nil nil) 'load) (\"==\") ((tuple  ((num 3) (num 4) (num 5)) 'load))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (slice 0 nil nil) 'load) (\"==\") ((tuple  ((num 1) (num 2) (num 3) (num 4) (num 5)) 'load))) nil)\n"))
    (should
     (string=
      (pyel "a = [1,2,3,4,5]\nassert a[1:4] == [2,3,4]\nassert a[:4] == [1,2,3,4]\nassert a[2:] == [3,4,5]\nassert a[:] == [1,2,3,4,5]" t)
      "(assign  ((name  \"a\" 'store)) (list ((num 1) (num 2) (num 3) (num 4) (num 5)) 'load))\n(assert  (compare  (subscript (name  \"a\" 'load) (slice (num 1) (num 4) nil) 'load) (\"==\") ((list ((num 2) (num 3) (num 4)) 'load))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (slice 0 (num 4) nil) 'load) (\"==\") ((list ((num 1) (num 2) (num 3) (num 4)) 'load))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (slice (num 2) nil nil) 'load) (\"==\") ((list ((num 3) (num 4) (num 5)) 'load))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (slice 0 nil nil) 'load) (\"==\") ((list ((num 1) (num 2) (num 3) (num 4) (num 5)) 'load))) nil)\n"))
    (should
     (string=
      (pyel "a = '012345678'\nassert a[1:4] == '123'\nassert a[:4] == '0123'\nassert a[2:] == '2345678'\nassert a[:] == '012345678'" t)
      "(assign  ((name  \"a\" 'store)) (str \"012345678\"))\n(assert  (compare  (subscript (name  \"a\" 'load) (slice (num 1) (num 4) nil) 'load) (\"==\") ((str \"123\"))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (slice 0 (num 4) nil) 'load) (\"==\") ((str \"0123\"))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (slice (num 2) nil nil) 'load) (\"==\") ((str \"2345678\"))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (slice 0 nil nil) 'load) (\"==\") ((str \"012345678\"))) nil)\n"))
    (should
     (string=
      (pyel "class a:\n def __getitem__ (self, value):\n  return value.start + value.end\nx = a()\nassert x[1:2] == 3\nassert x[5:7] == 12" t)
      "(classdef a nil nil nil nil ((def \" __getitem__ \" ((arguments  ((arg \"self\"  nil) (arg \"value\"  nil)) nil nil nil nil nil nil nil )) ((return (bin-op  (attribute  (name  \"value\" 'load) \"start\" 'load) + (attribute  (name  \"value\" 'load) \"end\" 'load)))) nil nil )) nil)\n(assign  ((name  \"x\" 'store)) (call  (name  \"a\" 'load) nil nil nil nil))\n(assert  (compare  (subscript (name  \"x\" 'load) (slice (num 1) (num 2) nil) 'load) (\"==\") ((num 3))) nil)\n(assert  (compare  (subscript (name  \"x\" 'load) (slice (num 5) (num 7) nil) 'load) (\"==\") ((num 12))) nil)\n"))
    (should
     (string=
      (pyel "def __add(a,b):\n return a+b\na = [1,2,3,4]\na[0] = __add(a[1],a[2])\nassert a[0] == 5\na[2] = 'str'\nassert a[2] == 'str'" t)
      "(def \" __add \" ((arguments  ((arg \"a\"  nil) (arg \"b\"  nil)) nil nil nil nil nil nil nil )) ((return (bin-op  (name  \"a\" 'load) + (name  \"b\" 'load)))) nil nil )\n(assign  ((name  \"a\" 'store)) (list ((num 1) (num 2) (num 3) (num 4)) 'load))\n(assign  ((subscript (name  \"a\" 'load) (index (num 0)) 'store)) (call  (name  \"__add\" 'load) ((subscript (name  \"a\" 'load) (index (num 1)) 'load) (subscript (name  \"a\" 'load) (index (num 2)) 'load)) nil nil nil))\n(assert  (compare  (subscript (name  \"a\" 'load) (index (num 0)) 'load) (\"==\") ((num 5))) nil)\n(assign  ((subscript (name  \"a\" 'load) (index (num 2)) 'store)) (str \"str\"))\n(assert  (compare  (subscript (name  \"a\" 'load) (index (num 2)) 'load) (\"==\") ((str \"str\"))) nil)\n"))
    (should
     (string=
      (pyel "a = (1,2,3,4)\na[0] = a[1] + a[2]\nassert aa[0] == 5\na[2] = 'str'\nassert a[2] == 'str'" t)
      "(assign  ((name  \"a\" 'store)) (tuple  ((num 1) (num 2) (num 3) (num 4)) 'load))\n(assign  ((subscript (name  \"a\" 'load) (index (num 0)) 'store)) (bin-op  (subscript (name  \"a\" 'load) (index (num 1)) 'load) + (subscript (name  \"a\" 'load) (index (num 2)) 'load)))\n(assert  (compare  (subscript (name  \"aa\" 'load) (index (num 0)) 'load) (\"==\") ((num 5))) nil)\n(assign  ((subscript (name  \"a\" 'load) (index (num 2)) 'store)) (str \"str\"))\n(assert  (compare  (subscript (name  \"a\" 'load) (index (num 2)) 'load) (\"==\") ((str \"str\"))) nil)\n"))
    (should
     (string=
      (pyel "class a:\n def __setitem__ (self, index, value):\n  self.index = index\n  self.value = value\nx = a()\nx[3] = 5\nassert x.index == 3\nassert x.value == 5" t)
      "(classdef a nil nil nil nil ((def \" __setitem__ \" ((arguments  ((arg \"self\"  nil) (arg \"index\"  nil) (arg \"value\"  nil)) nil nil nil nil nil nil nil )) ((assign  ((attribute  (name  \"self\" 'load) \"index\" 'store)) (name  \"index\" 'load)) (assign  ((attribute  (name  \"self\" 'load) \"value\" 'store)) (name  \"value\" 'load))) nil nil )) nil)\n(assign  ((name  \"x\" 'store)) (call  (name  \"a\" 'load) nil nil nil nil))\n(assign  ((subscript (name  \"x\" 'load) (index (num 3)) 'store)) (num 5))\n(assert  (compare  (attribute  (name  \"x\" 'load) \"index\" 'load) (\"==\") ((num 3))) nil)\n(assert  (compare  (attribute  (name  \"x\" 'load) \"value\" 'load) (\"==\") ((num 5))) nil)\n"))
    (should
     (string=
      (pyel "a = [1,2,3,4,5,6]\na[1:4] = [5,4,'f']\nassert a == [1,5,4,'f',5,6]\na[:3] = ['a',4,2.2]\nassert a == ['a',4,2.2,'f',5,6]\na[3:] = [3,3]\nassert a == ['a', 4, 2.2, 3, 3, 6]#TODO: should == ['a', 4, 2.2, 3, 3]" t)
      "(assign  ((name  \"a\" 'store)) (list ((num 1) (num 2) (num 3) (num 4) (num 5) (num 6)) 'load))\n(assign  ((subscript (name  \"a\" 'load) (slice (num 1) (num 4) nil) 'store)) (list ((num 5) (num 4) (str \"f\")) 'load))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((list ((num 1) (num 5) (num 4) (str \"f\") (num 5) (num 6)) 'load))) nil)\n(assign  ((subscript (name  \"a\" 'load) (slice 0 (num 3) nil) 'store)) (list ((str \"a\") (num 4) (num 2.2)) 'load))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((list ((str \"a\") (num 4) (num 2.2) (str \"f\") (num 5) (num 6)) 'load))) nil)\n(assign  ((subscript (name  \"a\" 'load) (slice (num 3) nil nil) 'store)) (list ((num 3) (num 3)) 'load))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((list ((str \"a\") (num 4) (num 2.2) (num 3) (num 3) (num 6)) 'load))) nil)\n"))
    (should
     (string=
      (pyel "a = (1,2,3,4,5,6)\na[1:4] = (5,4,'f')\nassert a == (1,5,4,'f',5,6)\na[:3] = ('a',4,2.2)\nassert a == ('a',4,2.2,'f',5,6)\na[3:] = (3,3)\nassert a == ('a', 4, 2.2, 3, 3, 6)#TODO: should == ('a', 4, 2.2, 3, 3)" t)
      "(assign  ((name  \"a\" 'store)) (tuple  ((num 1) (num 2) (num 3) (num 4) (num 5) (num 6)) 'load))\n(assign  ((subscript (name  \"a\" 'load) (slice (num 1) (num 4) nil) 'store)) (tuple  ((num 5) (num 4) (str \"f\")) 'load))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((tuple  ((num 1) (num 5) (num 4) (str \"f\") (num 5) (num 6)) 'load))) nil)\n(assign  ((subscript (name  \"a\" 'load) (slice 0 (num 3) nil) 'store)) (tuple  ((str \"a\") (num 4) (num 2.2)) 'load))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((tuple  ((str \"a\") (num 4) (num 2.2) (str \"f\") (num 5) (num 6)) 'load))) nil)\n(assign  ((subscript (name  \"a\" 'load) (slice (num 3) nil nil) 'store)) (tuple  ((num 3) (num 3)) 'load))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((tuple  ((str \"a\") (num 4) (num 2.2) (num 3) (num 3) (num 6)) 'load))) nil)\n"))
    (should
     (string=
      (pyel "a = '123456'\na[1:4] = '54f'\nassert a == '154f56'\na[:3] = 'a42'\nassert a == 'a42f56'\na[3:] = '33'\nassert a == 'a42336'#TODO: should == 'a4233'" t)
      "(assign  ((name  \"a\" 'store)) (str \"123456\"))\n(assign  ((subscript (name  \"a\" 'load) (slice (num 1) (num 4) nil) 'store)) (str \"54f\"))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((str \"154f56\"))) nil)\n(assign  ((subscript (name  \"a\" 'load) (slice 0 (num 3) nil) 'store)) (str \"a42\"))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((str \"a42f56\"))) nil)\n(assign  ((subscript (name  \"a\" 'load) (slice (num 3) nil nil) 'store)) (str \"33\"))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((str \"a42336\"))) nil)\n"))
    (should
     (string=
      (pyel "class a:\n def __setitem__ (self, index, value):\n  self.start = index.start\n  self.end = index.end\n  self.step = index.step\n  self.value = value\nx = a()\nx[2:3] = [1,2,3]\nassert x.start == 2\nassert x.end == 3\nassert x.value == [1,2,3]" t)
      "(classdef a nil nil nil nil ((def \" __setitem__ \" ((arguments  ((arg \"self\"  nil) (arg \"index\"  nil) (arg \"value\"  nil)) nil nil nil nil nil nil nil )) ((assign  ((attribute  (name  \"self\" 'load) \"start\" 'store)) (attribute  (name  \"index\" 'load) \"start\" 'load)) (assign  ((attribute  (name  \"self\" 'load) \"end\" 'store)) (attribute  (name  \"index\" 'load) \"end\" 'load)) (assign  ((attribute  (name  \"self\" 'load) \"step\" 'store)) (attribute  (name  \"index\" 'load) \"step\" 'load)) (assign  ((attribute  (name  \"self\" 'load) \"value\" 'store)) (name  \"value\" 'load))) nil nil )) nil)\n(assign  ((name  \"x\" 'store)) (call  (name  \"a\" 'load) nil nil nil nil))\n(assign  ((subscript (name  \"x\" 'load) (slice (num 2) (num 3) nil) 'store)) (list ((num 1) (num 2) (num 3)) 'load))\n(assert  (compare  (attribute  (name  \"x\" 'load) \"start\" 'load) (\"==\") ((num 2))) nil)\n(assert  (compare  (attribute  (name  \"x\" 'load) \"end\" 'load) (\"==\") ((num 3))) nil)\n(assert  (compare  (attribute  (name  \"x\" 'load) \"value\" 'load) (\"==\") ((list ((num 1) (num 2) (num 3)) 'load))) nil)\n"))
    (should
     (string=
      (pyel "a[2] += 3" t)
      "(aug-assign (subscript (name  \"a\" 'load) (index (num 2)) 'store) + (num 3))\n"))
    (should
     (string=
      (pyel "a[2] += b[3]" t)
      "(aug-assign (subscript (name  \"a\" 'load) (index (num 2)) 'store) + (subscript (name  \"b\" 'load) (index (num 3)) 'load))\n"))
    (should
     (string=
      (pyel "[2,3,3][2]" t)
      "(subscript (list ((num 2) (num 3) (num 3)) 'load) (index (num 2)) 'load)\n"))
    (should
     (string=
      (pyel "assert [1,2,(3,2,8)][2][2] == 8" t)
      "(assert  (compare  (subscript (subscript (list ((num 1) (num 2) (tuple  ((num 3) (num 2) (num 8)) 'load)) 'load) (index (num 2)) 'load) (index (num 2)) 'load) (\"==\") ((num 8))) nil)\n")))
  
#+END_SRC

* class
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform classdef pyel ()
    (lambda (name bases keywords starargs kwargs body decorator_list)
      (pyel-defclass name bases keywords starargs kwargs body decorator_list)))
  
  (defun pyel-defclass (name bases keywords starargs kwargs body decorator_list)
    (let ((class-def-methods nil) ;; list of methods that are part of this class
          (class-def-slots nil) ;;list of slots that are part of this class
          (class-def-name (transform name)))
  
      ;;transform body with the class-def context, the transformed code
      ;;will store its methods and slots in class-def-methods and class-def-slots
      ;;respectively.
      (setq _x body)
      (using-context class-def
  
                     (add-to-list 'pyel-defined-classes name)
                     
                     (setq body (mapcar 'transform body))
                     (setq _x body)
  
                     ;;add default initializer if one has not been defined
                     (unless (member '--init-- (mapcar 'cadr class-def-methods))
                       (push (read (format pyel-default--init--method name))
                             class-def-methods))
                     
                     `(@ (defclass ,class-def-name  () ;; ,bases ??
                           (,@(reverse class-def-slots))
                           "pyel class")
                         
                         ,@(reverse class-def-methods)))))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def ClassDef (name, bases, keywords, starargs, kwargs, body, decorator_list):
    return ll_str(["classdef",
                   name,
                   ll_str(bases),
                   ll_str(keywords),
                   starargs or "nil",
                   kwargs or "nil",
                   ll_str(body),
                   ll_str(decorator_list)])
                   
#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests 'class
		   "class test:
 def __init__(self,aa,bb):
  self.a = aa
  self.b = bb
 def geta(self):
  return self.a
 def getb(self):
  return self.b
x = test(5,6)
assert x.geta() == 5
assert x.getb() == 6
x.b = 2
assert x.getb() == 2")

#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-class-full-transform nil
    (should
     (equal
      (pyel "class test:\n def __init__(self,aa,bb):\n  self.a = aa\n  self.b = bb\n def geta(self):\n  return self.a\n def getb(self):\n  return self.b\nx = test(5,6)\nassert x.geta() == 5\nassert x.getb() == 6\nx.b = 2\nassert x.getb() == 2")
      '(progn
         (defclass test nil
           ((b :initarg :b :initform nil)
            (a :initarg :a :initform nil))
           "pyel class")
         (defmethod --init--
           ((self test)
            aa bb)
           (oset self a aa)
           (oset self b bb))
         (defmethod geta
           ((self test))
           (oref self a))
         (defmethod getb
           ((self test))
           (oref self b))
         (pyel-set x
                   (let
                       ((__c
                         (test "obj")))
                     (--init-- __c 5 6)
                     __c))
         (assert
          (pyel-==
           (geta x)
           5)
          t nil)
         (assert
          (pyel-==
           (getb x)
           6)
          t nil)
         (oset x b 2)
         (assert
          (pyel-==
           (getb x)
           2)
          t nil)))))
  (ert-deftest pyel-class-py-ast nil
    (should
     (equal
      (py-ast "class test:\n def __init__(self,aa,bb):\n  self.a = aa\n  self.b = bb\n def geta(self):\n  return self.a\n def getb(self):\n  return self.b\nx = test(5,6)\nassert x.geta() == 5\nassert x.getb() == 6\nx.b = 2\nassert x.getb() == 2")
      "Module(body=[ClassDef(name='test', bases=[], keywords=[], starargs=None, kwargs=None, body=[FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='aa', annotation=None), arg(arg='bb', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='a', ctx=Store())], value=Name(id='aa', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='b', ctx=Store())], value=Name(id='bb', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='geta', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='a', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='getb', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='b', ctx=Load()))], decorator_list=[], returns=None)], decorator_list=[]), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='test', ctx=Load()), args=[Num(n=5), Num(n=6)], keywords=[], starargs=None, kwargs=None)), Assert(test=Compare(left=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='geta', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=5)]), msg=None), Assert(test=Compare(left=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='getb', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=6)]), msg=None), Assign(targets=[Attribute(value=Name(id='x', ctx=Load()), attr='b', ctx=Store())], value=Num(n=2)), Assert(test=Compare(left=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='getb', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=2)]), msg=None)])\n")))
  (ert-deftest pyel-class-el-ast nil
    (should
     (string=
      (pyel "class test:\n def __init__(self,aa,bb):\n  self.a = aa\n  self.b = bb\n def geta(self):\n  return self.a\n def getb(self):\n  return self.b\nx = test(5,6)\nassert x.geta() == 5\nassert x.getb() == 6\nx.b = 2\nassert x.getb() == 2" t)
      "(classdef test nil nil nil nil ((def \" __init__ \" ((arguments  ((arg \"self\"  nil) (arg \"aa\"  nil) (arg \"bb\"  nil)) nil nil nil nil nil nil nil )) ((assign  ((attribute  (name  \"self\" 'load) \"a\" 'store)) (name  \"aa\" 'load)) (assign  ((attribute  (name  \"self\" 'load) \"b\" 'store)) (name  \"bb\" 'load))) nil nil ) (def \" geta \" ((arguments  ((arg \"self\"  nil)) nil nil nil nil nil nil nil )) ((return (attribute  (name  \"self\" 'load) \"a\" 'load))) nil nil ) (def \" getb \" ((arguments  ((arg \"self\"  nil)) nil nil nil nil nil nil nil )) ((return (attribute  (name  \"self\" 'load) \"b\" 'load))) nil nil )) nil)\n(assign  ((name  \"x\" 'store)) (call  (name  \"test\" 'load) ((num 5) (num 6)) nil nil nil))\n(assert  (compare  (call  (attribute  (name  \"x\" 'load) \"geta\" 'load) nil nil nil nil) (\"==\") ((num 5))) nil)\n(assert  (compare  (call  (attribute  (name  \"x\" 'load) \"getb\" 'load) nil nil nil nil) (\"==\") ((num 6))) nil)\n(assign  ((attribute  (name  \"x\" 'load) \"b\" 'store)) (num 2))\n(assert  (compare  (call  (attribute  (name  \"x\" 'load) \"getb\" 'load) nil nil nil nil) (\"==\") ((num 2))) nil)\n")))
  
#+END_SRC

* assert
** transform
;;TODO: have custom option for t/nil value of assert's 2nd parameter

;;TODO: fix this case:
  (pyel "assert (True,1), 'message'")
   -> (assert (vector True 1) t "message")
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform assert pyel ()
    (lambda (test msg) 
      (pyel-assert test msg)))
  
  (defun pyel-assert (test msg)
      `(assert ,(transform test) t ,(transform msg)))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Assert(test, msg):
      return ll_str(["assert ", test , msg or "nil"])
#+END_SRC
** tests
(pyel-create-tests 'assert
		   "assert sldk()"
		   "assert adk,'messsage'")
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-assert-full-transform nil
    (should
     (equal
      (pyel "assert sldk()")
      '(assert
        (sldk)
        t nil)))
    (should
     (equal
      (pyel "assert adk,'messsage'")
      '(assert adk t "messsage"))))
  (ert-deftest pyel-assert-py-ast nil
    (should
     (equal
      (py-ast "assert sldk()")
      "Module(body=[Assert(test=Call(func=Name(id='sldk', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), msg=None)])\n"))
    (should
     (equal
      (py-ast "assert adk,'messsage'")
      "Module(body=[Assert(test=Name(id='adk', ctx=Load()), msg=Str(s='messsage'))])\n")))
  (ert-deftest pyel-assert-el-ast nil
    (should
     (string=
      (pyel "assert sldk()" t)
      "(assert  (call  (name  \"sldk\" 'load) nil nil nil nil) nil)\n"))
    (should
     (string=
      (pyel "assert adk,'messsage'" t)
      "(assert  (name  \"adk\" 'load) (str \"messsage\"))\n")))
  
  
#+END_SRC

* primitive type methods
** doc  TODO: move or tangle 
*Defining method transforms for build in types*
In python, primitive types such as the list and string are objects. We need to 
define the way in which these method calls will be transformed to function
calls in Emacs Lisp. The macro `pyel-method-transform' is used for this.

Definition form is just like normal type transforms, with a few extra requirement
- The first argument is the potential object
- these transforms are responsible for creating the normal
  method call if obj is actually an object and not a primative type
  this must always be last with the type selector (_ _ ... _ ) ->
Example:
#+Begin_SRC emacs-lisp
 (pyel-method-transform append (obj thing)
 		(list _) -> (setq ,obj (append ,obj (list ,thing)))
 		(_ _)    -> (append ,thing))
#+End_Src
** append
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el

(pyel-method-transform append (obj thing)
                  (list _) -> (setq $obj (append obj (list thing)))
                  (_ _)    -> (append obj thing))
#+END_SRC
*** tests
(pyel-create-tests 'append
"a=[1,2,3]
a.append('str')
assert len(a) == 4
assert a[3] == 'str'"
)
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-append-full-transform nil
    (should
     (equal
      (pyel "a=[1,2,3]\na.append('str')\nassert len(a) == 4\nassert a[3] == 'str'")
      '(progn
         (pyel-set a
                   (list 1 2 3))
         (pyel-append-method a "str")
         (assert
          (pyel-==
           (pyel-len-function a)
           4)
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-index a 3)
           "str")
          t nil)))))
  (ert-deftest pyel-append-py-ast nil
    (should
     (equal
      (py-ast "a=[1,2,3]\na.append('str')\nassert len(a) == 4\nassert a[3] == 'str'")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=List(elts=[Num(n=1), Num(n=2), Num(n=3)], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='append', ctx=Load()), args=[Str(s='str')], keywords=[], starargs=None, kwargs=None)), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=4)]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=3)), ctx=Load()), ops=[Eq()], comparators=[Str(s='str')]), msg=None)])\n")))
  (ert-deftest pyel-append-el-ast nil
    (should
     (string=
      (pyel "a=[1,2,3]\na.append('str')\nassert len(a) == 4\nassert a[3] == 'str'" t)
      "(assign  ((name  \"a\" 'store)) (list ((num 1) (num 2) (num 3)) 'load))\n(call  (attribute  (name  \"a\" 'load) \"append\" 'load) ((str \"str\")) nil nil nil)\n(assert  (compare  (call  (name  \"len\" 'load) ((name  \"a\" 'load)) nil nil nil) (\"==\") ((num 4))) nil)\n(assert  (compare  (subscript (name  \"a\" 'load) (index (num 3)) 'load) (\"==\") ((str \"str\"))) nil)\n")))
  
#+END_SRC

* function transforms
TODO: tests!
** len
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-func-transform len (thing)
		     (object) -> (--len-- thing)
		     (_)      -> (length thing))
#+END_SRC
*** tests
(pyel-create-tests 'len
"a = [1,2,3,'5']
assert len(a) == 4"
"a = []
assert len(a) == 0"
"a = 'str'
assert len(a) == 3"
"a = (1,2)
assert len(a) == 2"
"assert len('')==0"
)

#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-len-full-transform nil
    (should
     (equal
      (pyel "a = [1,2,3,'5']\nassert len(a) == 4")
      '(progn
         (pyel-set a
                   (list 1 2 3 "5"))
         (assert
          (pyel-==
           (pyel-len-function a)
           4)
          t nil))))
    (should
     (equal
      (pyel "a = []\nassert len(a) == 0")
      '(progn
         (pyel-set a
                   (list))
         (assert
          (pyel-==
           (pyel-len-function a)
           0)
          t nil))))
    (should
     (equal
      (pyel "a = 'str'\nassert len(a) == 3")
      '(progn
         (pyel-set a "str")
         (assert
          (pyel-==
           (pyel-len-function a)
           3)
          t nil))))
    (should
     (equal
      (pyel "a = (1,2)\nassert len(a) == 2")
      '(progn
         (pyel-set a
                   (vector 1 2))
         (assert
          (pyel-==
           (pyel-len-function a)
           2)
          t nil))))
    (should
     (equal
      (pyel "assert len('')==0")
      '(assert
        (pyel-==
         (pyel-len-function "")
         0)
        t nil))))
  (ert-deftest pyel-len-py-ast nil
    (should
     (equal
      (py-ast "a = [1,2,3,'5']\nassert len(a) == 4")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=List(elts=[Num(n=1), Num(n=2), Num(n=3), Str(s='5')], ctx=Load())), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=4)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = []\nassert len(a) == 0")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=List(elts=[], ctx=Load())), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=0)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = 'str'\nassert len(a) == 3")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Str(s='str')), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=3)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a = (1,2)\nassert len(a) == 2")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Tuple(elts=[Num(n=1), Num(n=2)], ctx=Load())), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=2)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "assert len('')==0")
      "Module(body=[Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Str(s='')], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=0)]), msg=None)])\n")))
  (ert-deftest pyel-len-el-ast nil
    (should
     (string=
      (pyel "a = [1,2,3,'5']\nassert len(a) == 4" t)
      "(assign  ((name  \"a\" 'store)) (list ((num 1) (num 2) (num 3) (str \"5\")) 'load))\n(assert  (compare  (call  (name  \"len\" 'load) ((name  \"a\" 'load)) nil nil nil) (\"==\") ((num 4))) nil)\n"))
    (should
     (string=
      (pyel "a = []\nassert len(a) == 0" t)
      "(assign  ((name  \"a\" 'store)) (list nil 'load))\n(assert  (compare  (call  (name  \"len\" 'load) ((name  \"a\" 'load)) nil nil nil) (\"==\") ((num 0))) nil)\n"))
    (should
     (string=
      (pyel "a = 'str'\nassert len(a) == 3" t)
      "(assign  ((name  \"a\" 'store)) (str \"str\"))\n(assert  (compare  (call  (name  \"len\" 'load) ((name  \"a\" 'load)) nil nil nil) (\"==\") ((num 3))) nil)\n"))
    (should
     (string=
      (pyel "a = (1,2)\nassert len(a) == 2" t)
      "(assign  ((name  \"a\" 'store)) (tuple  ((num 1) (num 2)) 'load))\n(assert  (compare  (call  (name  \"len\" 'load) ((name  \"a\" 'load)) nil nil nil) (\"==\") ((num 2))) nil)\n"))
    (should
     (string=
      (pyel "assert len('')==0" t)
      "(assert  (compare  (call  (name  \"len\" 'load) ((str \"\")) nil nil nil) (\"==\") ((num 0))) nil)\n")))
  
#+END_SRC

** range
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (push '(range py-range) pyel-function-name-translations)
#+END_SRC
*** python el lib
#+Begin_SRC python :tangle py-lib.el
(defun py-range (start &optional end step)
  (unless end
    (setq end start
	  start 0))
  (number-sequence start (1- end) step))
#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** input
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'input 'read-string)
#+END_SRC

** list
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'list 'py-list)
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun py-list (&rest things)
    "tries to be like python's list function"
    (if (> (length things) 1)
        things
      (setq thing (car things))
      (cond
       ((stringp thing)
        (split-string thing "" :omit-nulls))
       ((vectorp thing)
        (mapcar 'identity thing))
       ((hash-table-p thing)
        (let (keys)
          (maphash (lambda (key value)
                     (setq keys (cons key keys))) thing)
          keys))
       ((listp thing) (copy-list thing)))))
  
#+END_SRC

*** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-py-list nil
    (should (equal (py-list "string")
                    '("s" "t" "r" "i" "n" "g")))
    (should (equal (py-list [2 3 4 4])
                   '(2 3 4 4)))
    (should (equal  (py-list '(2 3 4 4))
                    '(2 3 4 4)))
    (should (equal (py-list 23 4 2 "h")
                   '(23 4 2 "h")))
    (should (equal (py-list (let ((__h__ (make-hash-table :test (quote equal)))) (puthash 1 "1" __h__) (puthash "3" 3 __h__) (puthash 23 2 __h__) __h__))
                   '(23 "3" 1))))
  ;;(pyel "{1:'1','3':3,23:2}")  
#+END_SRC

** simple name changes
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-translate-function-name 'map 'mapcar)
(pyel-translate-function-name 'chr 'byte-to-string)
#+END_SRC
*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* built-in method transforms
TODO: tests!
** append
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-method-transform extend(obj thing)
                  (list _) -> (setq $obj (append obj thing))
                  (_ _)    -> (append obj thing))
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** insert
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-method-transform insert (obj i x)
		       (list _) -> (let () (setq $obj (append (subseq obj 0 i)
							      (list x)
							      (subseq obj i))))
		       (object _) -> (insert obj i x))
#+END_SRC
*** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** index
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform index (obj elem)
                    (list _) -> (list-index elem obj)
                    (string _) -> (string-match elem obj);;TODO: this uses regex, python does not
                    (vector _) -> (vector-index elem obj)
  
                    (object _)    -> (__index__ obj thing)) ;;?
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun list-index (elem list)
    "return the index of ELEM in LIST"
    (let ((m (member elem list)))
      (when m
        (- (length list) (length m)))))
  
  
  
  (defun vector-index (elem vector)
   "return the index of ELEM in VECTOR"
   (let ((i 0)
         (len (length vector))
         found)
  
      (while (and (< i len)
              (not found))
       (if (equal (aref vector i) elem)
        (setq found i)
        (setq i (1+ i))))
    found))
#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** remove
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(pyel-method-transform remove (obj x)
		       (list _) ->  (let ((i (list-index x obj)))
				      (if i
					  (setq $obj (append (subseq obj 0 i)
							     (subseq obj (1+ i))))
					(error "ValueError: list.remove(x): x not in list")))
		       (object _) -> (remove obj x))
#+END_SRC
*** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** count
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform count (obj elem)
                    (string _) -> (count-str-matches obj elem)
                    (list _) -> (count-elems-list obj elem)
                    (vector _) -> (count-elems-vector obj elem)
                    (object _)  -> (count thing));;
#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
  (defun count-str-matches (string substr)
    "count number of occurrences of SUBSTR in STRING"
    (with-temp-buffer
      (insert string)
      (goto-char 1)
      (how-many substr)))
  
  (defun count-elems-list (list elem)
    "return how many times ELEM occurs in LIST"
    (let ((c 0))
      (dolist (x list)
        (if (equal x elem)
            (setq c (1+ c))))
      c))
  
  (defun count-elems-vector (vector elem)
    "return how many times ELEM occurs in VECTOR"
    (let ((c 0)
          (i 0)
          (len (length vector)))
      (while (< i len)
        (if (equal (aref vector i) elem)
            (setq c (1+ c)))
        (setq i (1+ i)))
      c))
#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC emacs-lisp :tangle py-lib.el

#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

** join
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (pyel-method-transform join (obj elem)
                    (string _) ->  (mapconcat 'identity elem obj) 
                    (_ _)      -> (join obj thing))
#+END_SRC
*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC


* macro transforms
macros and macroish primitives
** cond
*** tests
(pyel-create-tests 'cond
"x = cond([1 > 2, 'first']
   [2 == 2, 'second']
   [5 == 7, 'third']
   [True, error('wtf')])
assert x == 'second'"
)
NOTE: had to change __pyel_marker_2__ to __pyel_marker_1__ in generated test
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-cond-full-transform nil
    (should
     (equal
      (pyel "x = cond([1 > 2, 'first']\n   [2 == 2, 'second']\n   [5 == 7, 'third']\n   [True, error('wtf')])\nassert x == 'second'")
      '(progn
         (pyel-set x
                   (cond
                    ((pyel-> 1 2)
                     "first")
                    ((pyel-== 2 2)
                     "second")
                    ((pyel-== 5 7)
                     "third")
                    (t
                     (error "wtf"))))
         (assert
          (pyel-== x "second")
          t nil)))))
  (ert-deftest pyel-cond-py-ast nil
    (should
     (equal
      (py-ast "x = cond([1 > 2, 'first']\n   [2 == 2, 'second']\n   [5 == 7, 'third']\n   [True, error('wtf')])\nassert x == 'second'")
      "Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='cond', ctx=Load()), args=[Subscript(value=Subscript(value=Subscript(value=List(elts=[Compare(left=Num(n=1), ops=[Gt()], comparators=[Num(n=2)]), Str(s='first')], ctx=Load()), slice=Index(value=Tuple(elts=[Compare(left=Num(n=2), ops=[Eq()], comparators=[Num(n=2)]), Str(s='second')], ctx=Load())), ctx=Load()), slice=Index(value=Tuple(elts=[Compare(left=Num(n=5), ops=[Eq()], comparators=[Num(n=7)]), Str(s='third')], ctx=Load())), ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='True', ctx=Load()), Call(func=Name(id='error', ctx=Load()), args=[Str(s='wtf')], keywords=[], starargs=None, kwargs=None)], ctx=Load())), ctx=Load())], keywords=[], starargs=None, kwargs=None)), Assert(test=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Str(s='second')]), msg=None)])\n")))
  (ert-deftest pyel-cond-el-ast nil
    (should
     (string=
      (pyel "x = cond([1 > 2, 'first']\n   [2 == 2, 'second']\n   [5 == 7, 'third']\n   [True, error('wtf')])\nassert x == 'second'" t)
      "(assign  ((name  \"x\" 'store)) (name  \"test_marker\" 'load))\n(assert  (compare  (name  \"x\" 'load) (\"==\") ((str \"second\"))) nil)\n")))
  
#+END_SRC
** lambda
*** tests
(pyel-create-tests 'lambda
"x = [2,3,4]
square = lambda([x]
 x*x)
y = mapcar(square,x)
assert y == [4,9,16]
"
"f = lambda([x,y]
if x > y:
 'x'
else:
 'y')
x=cl_mapcar(f, [1, 2, 3, 4, 5], [4, 2, 1, 6, 3])
assert x == ['y', 'y', 'x', 'y', 'x']")
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-lambda-full-transform nil
    (should
     (equal
      (pyel "x = [2,3,4]\nsquare = lambda([x]\n x*x)\ny = mapcar(square,x)\nassert y == [4,9,16]\n")
      '(progn
         (setq x
               (list 2 3 4))
         (setq square
               (lambda
                 (x)
                 (pyel-* x x)))
         (setq y
               (mapcar square x))
         (assert
          (pyel-== y
                   (list 4 9 16))
          t nil))))
    (should
     (equal
      (pyel "f = lambda([x,y]\nif x > y:\n 'x'\nelse:\n 'y')\nx=cl_mapcar(f, [1, 2, 3, 4, 5], [4, 2, 1, 6, 3])\nassert x == ['y', 'y', 'x', 'y', 'x']")
      '(progn
         (setq f
               (lambda
                 (x y)
                 (if
                     (pyel-> x y)
                     (progn "x")
                   "y")))
         (setq x
               (cl_mapcar f
                          (list 1 2 3 4 5)
                          (list 4 2 1 6 3)))
         (assert
          (pyel-== x
                   (list "y" "y" "x" "y" "x"))
          t nil)))))
  (ert-deftest pyel-lambda-py-ast nil
    (should
     (equal
      (py-ast "x = [2,3,4]\nsquare = lambda([x]\n x*x)\ny = mapcar(square,x)\nassert y == [4,9,16]\n")
      "Traceback (most recent call last):\n  File \"/tmp/py2el.py\", line 7, in <module>\n    \"\"\")))\n  File \"/usr/lib/python3.2/ast.py\", line 36, in parse\n    return compile(source, filename, mode, PyCF_ONLY_AST)\n  File \"<unknown>\", line 2\n    square = lambda([x]\n                   ^\nSyntaxError: invalid syntax\n"))
    (should
     (equal
      (py-ast "f = lambda([x,y]\nif x > y:\n 'x'\nelse:\n 'y')\nx=cl_mapcar(f, [1, 2, 3, 4, 5], [4, 2, 1, 6, 3])\nassert x == ['y', 'y', 'x', 'y', 'x']")
      "Traceback (most recent call last):\n  File \"/tmp/py2el.py\", line 8, in <module>\n    assert x == ['y', 'y', 'x', 'y', 'x']\"\"\")))\n  File \"/usr/lib/python3.2/ast.py\", line 36, in parse\n    return compile(source, filename, mode, PyCF_ONLY_AST)\n  File \"<unknown>\", line 1\n    f = lambda([x,y]\n              ^\nSyntaxError: invalid syntax\n")))
  (ert-deftest pyel-lambda-el-ast nil
    (should
     (string=
      (pyel "x = [2,3,4]\nsquare = lambda([x]\n x*x)\ny = mapcar(square,x)\nassert y == [4,9,16]\n" t)
      "(assign  ((name  \"x\" 'store)) (list ((num 2) (num 3) (num 4)) 'load))\n(assign  ((name  \"square\" 'store)) (name  \"__pyel_marker_81__\" 'load))\n(assign  ((name  \"y\" 'store)) (call  (name  \"mapcar\" 'load) ((name  \"square\" 'load) (name  \"x\" 'load)) nil nil nil))\n(assert  (compare  (name  \"y\" 'load) (\"==\") ((list ((num 4) (num 9) (num 16)) 'load))) nil)\n"))
    (should
     (string=
      (pyel "f = lambda([x,y]\nif x > y:\n 'x'\nelse:\n 'y')\nx=cl_mapcar(f, [1, 2, 3, 4, 5], [4, 2, 1, 6, 3])\nassert x == ['y', 'y', 'x', 'y', 'x']" t)
      "(assign  ((name  \"f\" 'store)) (name  \"__pyel_marker_79__\" 'load))\n(assign  ((name  \"x\" 'store)) (call  (name  \"cl_mapcar\" 'load) ((name  \"f\" 'load) (list ((num 1) (num 2) (num 3) (num 4) (num 5)) 'load) (list ((num 4) (num 2) (num 1) (num 6) (num 3)) 'load)) nil nil nil))\n(assert  (compare  (name  \"x\" 'load) (\"==\") ((list ((str \"y\") (str \"y\") (str \"x\") (str \"y\") (str \"x\")) 'load))) nil)\n")))
  
#+END_SRC

** transform template
*** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
*** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
*** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

*** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* for loop
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform for pyel ()
    (lambda (target iter body orelse)
      (pyel-for target iter body orelse)))
  
  ;;TODO: for a,y in thing: ...
  ;;TODO: check if iter is an object, then do the iterator thing
  
  (defun pyel-for (target iter body orelse)
    (if (eq (car target) 'tuple)
        "TODO: var unpacking"
      ;;create a temp target variable
      ;;in body, unpack that into the provided target variables
      
      (let* ((continue-for nil)
             (break-for nil)
             (code (using-context for (mapcar 'transform body)))
             (break-code (if break-for '(catch '__break__)
                           pyel-nothing))
             (continue-code (if continue-for '(catch '__continue__)
                              pyel-nothing)))
        (setq _x break-for)
        `(,@break-code
          (loop for ,(using-context for-loop-target
                                    (transform target))
                in (py-list ,(transform iter))
                do (,@continue-code
                    ,@(mapcar 'transform body)))
          ,@(mapcar 'transform orelse)))))
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def For(target, iter, body, orelse):
      return l_str(["for ", target, iter, ll_str(body), ll_str(orelse)])
#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests 'for-loop
"b = [1,2,3,4]
c = 0
for a in b:
 c = c + a
assert c==10"

"for i in range(n):
 break"

"for i in range(n):
 continue"

"x = []
for i in range(5):
 if i == 2:
  continue
 x.append(i)
assert x == [0,1,3,4]"

)
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-for-loop-full-transform nil
    (should
     (equal
      (pyel "b = [1,2,3,4]\nc = 0\nfor a in b:\n c = c + a\nassert c==10")
      '(progn
         (pyel-set b
                   (list 1 2 3 4))
         (pyel-set c 0)
         (loop for a in
               (py-list b)
               do
               (pyel-set c
                         (pyel-+ c a)))
         (assert
          (pyel-== c 10)
          t nil))))
    (should
     (equal
      (pyel "for i in range(n):\n break")
      '(catch '__break__
         (loop for i in
               (py-list
                (py-range n))
               do
               (throw '__break__ nil)))))
    (should
     (equal
      (pyel "for i in range(n):\n continue")
      '(loop for i in
             (py-list
              (py-range n))
             do
             (catch '__continue__
               (throw '__continue__ nil)))))
    (should
     (equal
      (pyel "x = []\nfor i in range(5):\n if i == 2:\n  continue\n x.append(i)\nassert x == [0,1,3,4]")
      '(progn
         (pyel-set x
                   (list))
         (loop for i in
               (py-list
                (py-range 5))
               do
               (catch '__continue__
                 (if
                     (pyel-== i 2)
                     (throw '__continue__ nil))
                 (pyel-append-method x i)))
         (assert
          (pyel-== x
                   (list 0 1 3 4))
          t nil)))))
  (ert-deftest pyel-for-loop-py-ast nil
    (should
     (equal
      (py-ast "b = [1,2,3,4]\nc = 0\nfor a in b:\n c = c + a\nassert c==10")
      "Module(body=[Assign(targets=[Name(id='b', ctx=Store())], value=List(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4)], ctx=Load())), Assign(targets=[Name(id='c', ctx=Store())], value=Num(n=0)), For(target=Name(id='a', ctx=Store()), iter=Name(id='b', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=BinOp(left=Name(id='c', ctx=Load()), op=Add(), right=Name(id='a', ctx=Load())))], orelse=[]), Assert(test=Compare(left=Name(id='c', ctx=Load()), ops=[Eq()], comparators=[Num(n=10)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "for i in range(n):\n break")
      "Module(body=[For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[], starargs=None, kwargs=None), body=[Break()], orelse=[])])\n"))
    (should
     (equal
      (py-ast "for i in range(n):\n continue")
      "Module(body=[For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[], starargs=None, kwargs=None), body=[Continue()], orelse=[])])\n"))
    (should
     (equal
      (py-ast "x = []\nfor i in range(5):\n if i == 2:\n  continue\n x.append(i)\nassert x == [0,1,3,4]")
      "Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=5)], keywords=[], starargs=None, kwargs=None), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[Num(n=2)]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[], starargs=None, kwargs=None))], orelse=[]), Assert(test=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[List(elts=[Num(n=0), Num(n=1), Num(n=3), Num(n=4)], ctx=Load())]), msg=None)])\n")))
  (ert-deftest pyel-for-loop-el-ast nil
    (should
     (string=
      (pyel "b = [1,2,3,4]\nc = 0\nfor a in b:\n c = c + a\nassert c==10" t)
      "(assign  ((name  \"b\" 'store)) (list ((num 1) (num 2) (num 3) (num 4)) 'load))\n(assign  ((name  \"c\" 'store)) (num 0))\n(for  (name  \"a\" 'store) (name  \"b\" 'load) ((assign  ((name  \"c\" 'store)) (bin-op  (name  \"c\" 'load) + (name  \"a\" 'load)))) nil)\n(assert  (compare  (name  \"c\" 'load) (\"==\") ((num 10))) nil)\n"))
    (should
     (string=
      (pyel "for i in range(n):\n break" t)
      "(for  (name  \"i\" 'store) (call  (name  \"range\" 'load) ((name  \"n\" 'load)) nil nil nil) ((break)) nil)\n"))
    (should
     (string=
      (pyel "for i in range(n):\n continue" t)
      "(for  (name  \"i\" 'store) (call  (name  \"range\" 'load) ((name  \"n\" 'load)) nil nil nil) ((continue)) nil)\n"))
    (should
     (string=
      (pyel "x = []\nfor i in range(5):\n if i == 2:\n  continue\n x.append(i)\nassert x == [0,1,3,4]" t)
      "(assign  ((name  \"x\" 'store)) (list nil 'load))\n(for  (name  \"i\" 'store) (call  (name  \"range\" 'load) ((num 5)) nil nil nil) ((if  (compare  (name  \"i\" 'load) (\"==\") ((num 2))) ((continue)) nil) (call  (attribute  (name  \"x\" 'load) \"append\" 'load) ((name  \"i\" 'load)) nil nil nil)) nil)\n(assert  (compare  (name  \"x\" 'load) (\"==\") ((list ((num 0) (num 1) (num 3) (num 4)) 'load))) nil)\n")))
  
#+END_SRC
  
* global
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform global pyel ()
    (lambda (names)
      (if (context-p 'function-def)
          (progn (mapc (lambda (x) (add-to-list 'global-vars (_to- x))) names)
                 pyel-nothing)
        (pyel-not-implemented "'global' calls outside of function definitions"))))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Global(names):
    return l_str(['global', l_str(names)])
#+END_SRC
** tests
(pyel-create-tests 'global
		   
"def a():
 global x
 x = 3
 y = 1"

"x = 1
y = 1
def func():
 global x
 x = 7
 y = 7
func()
assert x == 7
assert y == 1
"
)
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-global-full-transform nil
    (should
     (equal
      (pyel "def a():\n global x\n x = 3\n y = 1")
      '(defun a nil
         (let
             (y)
           (pyel-set x 3)
           (pyel-set y 1)))))
    (should
     (equal
      (pyel "x = 1\ny = 1\ndef func():\n global x\n x = 7\n y = 7\nfunc()\nassert x == 7\nassert y == 1\n")
      '(progn
         (pyel-set x 1)
         (pyel-set y 1)
         (defun func nil
           (let
               (y)
             (pyel-set x 7)
             (pyel-set y 7)))
         (func)
         (assert
          (pyel-== x 7)
          t nil)
         (assert
          (pyel-== y 1)
          t nil)))))
  (ert-deftest pyel-global-py-ast nil
    (should
     (equal
      (py-ast "def a():\n global x\n x = 3\n y = 1")
      "Module(body=[FunctionDef(name='a', args=arguments(args=[], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Global(names=['x']), Assign(targets=[Name(id='x', ctx=Store())], value=Num(n=3)), Assign(targets=[Name(id='y', ctx=Store())], value=Num(n=1))], decorator_list=[], returns=None)])\n"))
    (should
     (equal
      (py-ast "x = 1\ny = 1\ndef func():\n global x\n x = 7\n y = 7\nfunc()\nassert x == 7\nassert y == 1\n")
      "Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='y', ctx=Store())], value=Num(n=1)), FunctionDef(name='func', args=arguments(args=[], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=[Global(names=['x']), Assign(targets=[Name(id='x', ctx=Store())], value=Num(n=7)), Assign(targets=[Name(id='y', ctx=Store())], value=Num(n=7))], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)), Assert(test=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Num(n=7)]), msg=None), Assert(test=Compare(left=Name(id='y', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), msg=None)])\n")))
  (ert-deftest pyel-global-el-ast nil
    (should
     (string=
      (pyel "def a():\n global x\n x = 3\n y = 1" t)
      "(def \" a \" ((arguments  nil nil nil nil nil nil nil nil )) ((global (x)) (assign  ((name  \"x\" 'store)) (num 3)) (assign  ((name  \"y\" 'store)) (num 1))) nil nil )\n"))
    (should
     (string=
      (pyel "x = 1\ny = 1\ndef func():\n global x\n x = 7\n y = 7\nfunc()\nassert x == 7\nassert y == 1\n" t)
      "(assign  ((name  \"x\" 'store)) (num 1))\n(assign  ((name  \"y\" 'store)) (num 1))\n(def \" func \" ((arguments  nil nil nil nil nil nil nil nil )) ((global (x)) (assign  ((name  \"x\" 'store)) (num 7)) (assign  ((name  \"y\" 'store)) (num 7))) nil nil )\n(call  (name  \"func\" 'load) nil nil nil nil)\n(assert  (compare  (name  \"x\" 'load) (\"==\") ((num 7))) nil)\n(assert  (compare  (name  \"y\" 'load) (\"==\") ((num 1))) nil)\n")))
  
#+END_SRC

* nonlocal
DOC: 'nonlocal' is currently equivalent to 'global'
     It seems to be working fine...

** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el

 #+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Nonlocal(names):
    return l_str(['global', l_str(names)])
#+END_SRC
** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC


* lambda
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform lambda pyel ()
    (lambda (args body)
      (using-context lambda-def
                     (pyel-def "dkl" args body nil nil))))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Lambda(args, body):
      return ll_str(["lambda", ll_str(args),'('+ll_str(body)+')'])
  
#+END_SRC
** tests
(pyel-create-tests 'lambda
"lambda x,y,z=4,*g: print(z);x()"
"x = range(2, 9)
x2 = reduce(lambda a,b:a+b, x)
assert x2 == 35"
)
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-lambda-full-transform nil
    (should
     (equal
      (pyel "lambda x,y,z=4,*g: print(z);x()")
      '(progn
         (lambda
           (x y &optional z &rest g)
           (setq z
                 (or z 4))
           (print z))
         (x))))
    (should
     (equal
      (pyel "x = range(2, 9)\nx2 = reduce(lambda a,b:a+b, x)\nassert x2 == 35")
      '(progn
         (pyel-set x
                   (py-range 2 9))
         (pyel-set x2
                   (reduce
                    (lambda
                      (a b)
                      (pyel-+ a b))
                    x))
         (assert
          (pyel-== x2 35)
          t nil)))))
  (ert-deftest pyel-lambda-py-ast nil
    (should
     (equal
      (py-ast "lambda x,y,z=4,*g: print(z);x()")
      "Module(body=[Expr(value=Lambda(args=arguments(args=[arg(arg='x', annotation=None), arg(arg='y', annotation=None), arg(arg='z', annotation=None)], vararg='g', varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[Num(n=4)], kw_defaults=[]), body=Call(func=Name(id='print', ctx=Load()), args=[Name(id='z', ctx=Load())], keywords=[], starargs=None, kwargs=None))), Expr(value=Call(func=Name(id='x', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])\n"))
    (should
     (equal
      (py-ast "x = range(2, 9)\nx2 = reduce(lambda a,b:a+b, x)\nassert x2 == 35")
      "Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='range', ctx=Load()), args=[Num(n=2), Num(n=9)], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='x2', ctx=Store())], value=Call(func=Name(id='reduce', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='a', annotation=None), arg(arg='b', annotation=None)], vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None, kwargannotation=None, defaults=[], kw_defaults=[]), body=BinOp(left=Name(id='a', ctx=Load()), op=Add(), right=Name(id='b', ctx=Load()))), Name(id='x', ctx=Load())], keywords=[], starargs=None, kwargs=None)), Assert(test=Compare(left=Name(id='x2', ctx=Load()), ops=[Eq()], comparators=[Num(n=35)]), msg=None)])\n")))
  (ert-deftest pyel-lambda-el-ast nil
    (should
     (string=
      (pyel "lambda x,y,z=4,*g: print(z);x()" t)
      "(lambda ((arguments  ((arg \"x\"  nil) (arg \"y\"  nil) (arg \"z\"  nil)) g nil nil nil nil ((num 4)) nil )) ((call  (name  \"print\" 'load) ((name  \"z\" 'load)) nil nil nil)))\n(call  (name  \"x\" 'load) nil nil nil nil)\n"))
    (should
     (string=
      (pyel "x = range(2, 9)\nx2 = reduce(lambda a,b:a+b, x)\nassert x2 == 35" t)
      "(assign  ((name  \"x\" 'store)) (call  (name  \"range\" 'load) ((num 2) (num 9)) nil nil nil))\n(assign  ((name  \"x2\" 'store)) (call  (name  \"reduce\" 'load) ((lambda ((arguments  ((arg \"a\"  nil) (arg \"b\"  nil)) nil nil nil nil nil nil nil )) ((bin-op  (name  \"a\" 'load) + (name  \"b\" 'load)))) (name  \"x\" 'load)) nil nil nil))\n(assert  (compare  (name  \"x2\" 'load) (\"==\") ((num 35))) nil)\n")))
  
#+END_SRC

* unary op
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  
  def UnaryOp(op, operand):
      return l_str(["unary-op ", op, operand])
  
  def Not():
      return "not"
  
  def USub():
      return "usub"
#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* augmented assignment
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform aug-assign pyel (target op value)
    (lambda (target op value)
      (call-transform 'assign
                       `(,target)
                       (call-transform  op
                                        ;;TODO: what if this is something else
                                        ;;other then a simple name?
                                        ;;=> ok as long as nothing acknowledges
                                        ;;   the  force-load context
                                        (using-context force-load
                                                       (transform target))
                                        value))))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def AugAssign(target, op, value):
      return l_str(['aug-assign', target, op, value])
#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC
** tests
(pyel-create-tests 'aug-assign
		   "a += b"
		   "a -= b"
		   "a /= b"
		   "a *= b"
		   "a **= b"
		   "a ^= b"
		   "a |= b"
		   "a = 3
b = 4
a += b + 1
assert a == 8"

"a.b += a[2]"
"a.b += 4"
"a.b += d.e"
)
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-aug-assign-full-transform nil
    (should
     (equal
      (pyel "a += b")
      '(pyel-set a
                 (pyel-+ a b))))
    (should
     (equal
      (pyel "a -= b")
      '(pyel-set a
                 (pyel-- a b))))
    (should
     (equal
      (pyel "a /= b")
      '(pyel-set a
                 (pyel-/ a b))))
    (should
     (equal
      (pyel "a *= b")
      '(pyel-set a
                 (pyel-* a b))))
    (should
     (equal
      (pyel "a **= b")
      '(pyel-set a
                 (pyel-** a b))))
    (should
     (equal
      (pyel "a ^= b")
      '(pyel-set a
                 (pyel-^ a b))))
    (should
     (equal
      (pyel "a |= b")
      '(pyel-set a
                 (pyel-| a b))))
    (should
     (equal
      (pyel "a = 3\nb = 4\na += b + 1\nassert a == 8")
      '(progn
         (pyel-set a 3)
         (pyel-set b 4)
         (pyel-set a
                   (pyel-+ a
                           (pyel-+ b 1)))
         (assert
          (pyel-== a 8)
          t nil))))
    (should
     (equal
      (pyel "a.b += a[2]")
      '(oset a b
             (pyel-+
              (oref a b)
              (pyel-subscript-load-index a 2)))))
    (should
     (equal
      (pyel "a.b += 4")
      '(oset a b
             (pyel-+
              (oref a b)
              4))))
    (should
     (equal
      (pyel "a.b += d.e")
      '(oset a b
             (pyel-+
              (oref a b)
              (oref d e))))))
  (ert-deftest pyel-aug-assign-py-ast nil
    (should
     (equal
      (py-ast "a += b")
      "Module(body=[AugAssign(target=Name(id='a', ctx=Store()), op=Add(), value=Name(id='b', ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "a -= b")
      "Module(body=[AugAssign(target=Name(id='a', ctx=Store()), op=Sub(), value=Name(id='b', ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "a /= b")
      "Module(body=[AugAssign(target=Name(id='a', ctx=Store()), op=Div(), value=Name(id='b', ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "a *= b")
      "Module(body=[AugAssign(target=Name(id='a', ctx=Store()), op=Mult(), value=Name(id='b', ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "a **= b")
      "Module(body=[AugAssign(target=Name(id='a', ctx=Store()), op=Pow(), value=Name(id='b', ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "a ^= b")
      "Module(body=[AugAssign(target=Name(id='a', ctx=Store()), op=BitXor(), value=Name(id='b', ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "a |= b")
      "Module(body=[AugAssign(target=Name(id='a', ctx=Store()), op=BitOr(), value=Name(id='b', ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "a = 3\nb = 4\na += b + 1\nassert a == 8")
      "Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Num(n=3)), Assign(targets=[Name(id='b', ctx=Store())], value=Num(n=4)), AugAssign(target=Name(id='a', ctx=Store()), op=Add(), value=BinOp(left=Name(id='b', ctx=Load()), op=Add(), right=Num(n=1))), Assert(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=8)]), msg=None)])\n"))
    (should
     (equal
      (py-ast "a.b += a[2]")
      "Module(body=[AugAssign(target=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Store()), op=Add(), value=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load()))])\n"))
    (should
     (equal
      (py-ast "a.b += 4")
      "Module(body=[AugAssign(target=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Store()), op=Add(), value=Num(n=4))])\n"))
    (should
     (equal
      (py-ast "a.b += d.e")
      "Module(body=[AugAssign(target=Attribute(value=Name(id='a', ctx=Load()), attr='b', ctx=Store()), op=Add(), value=Attribute(value=Name(id='d', ctx=Load()), attr='e', ctx=Load()))])\n")))
  (ert-deftest pyel-aug-assign-el-ast nil
    (should
     (string=
      (pyel "a += b" t)
      "(aug-assign (name  \"a\" 'store) + (name  \"b\" 'load))\n"))
    (should
     (string=
      (pyel "a -= b" t)
      "(aug-assign (name  \"a\" 'store) - (name  \"b\" 'load))\n"))
    (should
     (string=
      (pyel "a /= b" t)
      "(aug-assign (name  \"a\" 'store) / (name  \"b\" 'load))\n"))
    (should
     (string=
      (pyel "a *= b" t)
      "(aug-assign (name  \"a\" 'store) * (name  \"b\" 'load))\n"))
    (should
     (string=
      (pyel "a **= b" t)
      "(aug-assign (name  \"a\" 'store) ** (name  \"b\" 'load))\n"))
    (should
     (string=
      (pyel "a ^= b" t)
      "(aug-assign (name  \"a\" 'store) ^ (name  \"b\" 'load))\n"))
    (should
     (string=
      (pyel "a |= b" t)
      "(aug-assign (name  \"a\" 'store) | (name  \"b\" 'load))\n"))
    (should
     (string=
      (pyel "a = 3\nb = 4\na += b + 1\nassert a == 8" t)
      "(assign  ((name  \"a\" 'store)) (num 3))\n(assign  ((name  \"b\" 'store)) (num 4))\n(aug-assign (name  \"a\" 'store) + (bin-op  (name  \"b\" 'load) + (num 1)))\n(assert  (compare  (name  \"a\" 'load) (\"==\") ((num 8))) nil)\n"))
    (should
     (string=
      (pyel "a.b += a[2]" t)
      "(aug-assign (attribute  (name  \"a\" 'load) \"b\" 'store) + (subscript (name  \"a\" 'load) (index (num 2)) 'load))\n"))
    (should
     (string=
      (pyel "a.b += 4" t)
      "(aug-assign (attribute  (name  \"a\" 'load) \"b\" 'store) + (num 4))\n"))
    (should
     (string=
      (pyel "a.b += d.e" t)
      "(aug-assign (attribute  (name  \"a\" 'load) \"b\" 'store) + (attribute  (name  \"d\" 'load) \"e\" 'load))\n")))
  
#+END_SRC

* return
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform return pyel (value)
    (lambda (value)
      
      (if (context-p 'last-function-line)
          (transform value)
        (setq return-middle t)
        `(throw '__return__ ,(transform value)))))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Return(value):
      return "(return " + str(value) + ")"
#+END_SRC
** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* break and continue
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform break pyel ()
    (lambda ()
      ;;TODO verify that it is ok to just use one inter-template var for this
      (context-switch
       (while (setq break-while t))
       (for (setq break-for t)))
      '(throw '__break__ nil)))
  
  (def-transform continue pyel ()
    (lambda ()
      ;;TODO verify that it is ok to just use one inter-template var for this
      (context-switch
       (while (setq continue-while t))
       (for (setq continue-for t)))
      '(throw '__continue__ nil)))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Break():
      return "(break)"
      
  def Continue():
      return "(continue)"
  
#+END_SRC
** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* exception handler
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform except-handler pyel (type name body)
    ;;TODO: name?
    (lambda (type name body)
      `(,(or (transform type) 'error)
        ,@(mapcar 'transform body))))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def ExceptHandler(type, name, body):
      return l_str(["except-handler", type or 'nil', name or 'nil', l_str(body)])
#+END_SRC

** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* try except
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform try pyel (body handlers orelse)
    ;;TODO: orelse
    (lambda (body handlers orelse)
      `(condition-case nil
           ,@(mapcar 'transform body)
         ,@(mapcar 'transform handlers))))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def TryExcept(body, handlers, orelse):
      return l_str(["try", l_str(body), l_str(handlers), l_str(orelse)])
#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests 'try
"x = ''
try:
 1 / 0
 x = 'yes'
except:
 x = 'no'
assert x == 'no'"

"try:
 _a()
except:
 try:
  _x()
 except:
  _b()"
)

#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-try-full-transform nil
    (should
     (equal
      (pyel "x = ''\ntry:\n 1 / 0\n x = 'yes'\nexcept:\n x = 'no'\nassert x == 'no'")
      '(progn
         (pyel-set x "")
         (condition-case nil
             (pyel-/ 1 0)
           (pyel-set x "yes")
           (error
            (pyel-set x "no")))
         (assert
          (pyel-== x "no")
          t nil))))
    (should
     (equal
      (pyel "try:\n _a()\nexcept:\n try:\n  _x()\n except:\n  _b()")
      '(condition-case nil
           (-a)
         (error
          (condition-case nil
              (-x)
            (error
             (-b))))))))
  (ert-deftest pyel-try-py-ast nil
    (should
     (equal
      (py-ast "x = ''\ntry:\n 1 / 0\n x = 'yes'\nexcept:\n x = 'no'\nassert x == 'no'")
      "Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=Str(s='')), TryExcept(body=[Expr(value=BinOp(left=Num(n=1), op=Div(), right=Num(n=0))), Assign(targets=[Name(id='x', ctx=Store())], value=Str(s='yes'))], handlers=[ExceptHandler(type=None, name=None, body=[Assign(targets=[Name(id='x', ctx=Store())], value=Str(s='no'))])], orelse=[]), Assert(test=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Str(s='no')]), msg=None)])\n"))
    (should
     (equal
      (py-ast "try:\n _a()\nexcept:\n try:\n  _x()\n except:\n  _b()")
      "Module(body=[TryExcept(body=[Expr(value=Call(func=Name(id='_a', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))], handlers=[ExceptHandler(type=None, name=None, body=[TryExcept(body=[Expr(value=Call(func=Name(id='_x', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))], handlers=[ExceptHandler(type=None, name=None, body=[Expr(value=Call(func=Name(id='_b', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None))])], orelse=[])])], orelse=[])])\n")))
  (ert-deftest pyel-try-el-ast nil
    (should
     (string=
      (pyel "x = ''\ntry:\n 1 / 0\n x = 'yes'\nexcept:\n x = 'no'\nassert x == 'no'" t)
      "(assign  ((name  \"x\" 'store)) (str \"\"))\n(try ((bin-op  (num 1) / (num 0)) (assign  ((name  \"x\" 'store)) (str \"yes\"))) ((except-handler nil nil ((assign  ((name  \"x\" 'store)) (str \"no\"))))) ())\n(assert  (compare  (name  \"x\" 'load) (\"==\") ((str \"no\"))) nil)\n"))
    (should
     (string=
      (pyel "try:\n _a()\nexcept:\n try:\n  _x()\n except:\n  _b()" t)
      "(try ((call  (name  \"_a\" 'load) nil nil nil nil)) ((except-handler nil nil ((try ((call  (name  \"_x\" 'load) nil nil nil nil)) ((except-handler nil nil ((call  (name  \"_b\" 'load) nil nil nil nil)))) ())))) ())\n")))
  
#+END_SRC

* unary op, not, usub
TODO: tests!
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform unary-op pyel ()
    (lambda (op operand)
      (call-transform op operand)))
  
  (pyel-create-py-func not (x)
                       (object) -> (--not-- x) ;;?
                       (_) -> (not x))
  
  (pyel-create-py-func usub (x)
                       (number) -> (- x)
                       (object) -> (--usub-- x) ;;?
                       )
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* in, not in
TODO: tests!
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  ;;a not in b
  ;; function:    is_not(a, b)  (in the operator module)
  (pyel-create-py-func not-in (l r)
                       (_ list) -> (not (member l r))
                       (_ vector) -> (not (vector-member l r))
                       (_ object) -> (--not-in-- r l) ;;?
                       )
  
  
  ;;a in b
  ;; function:    is_(a, b)
  (pyel-create-py-func in (l r)
                       (_ list) -> (member l r)
                       (_ vector) -> (vector-member l r)
                       (_ object) -> (--in-- r l);;?
                       )
#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el
  (defun vector-member (elt vector)
   "Return non-nil if ELT is an element of VECTOR.  Comparison done with `equal'."
   (let ((i 0)
         (len (length vector))
         found)
    (while (and (not found)
            (< i len))
     (if (equal (elt vector i) elt)
      (setq found t)
      (setq i (1+ i))))
    found))
#+END_SRC

** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* comprehensions
DOC: generator expressions are translated to list comprehensions

** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform comprehension pyel (target iter ifs)
    (lambda (target iter ifs) (pyel-comprehension target iter ifs)))
  
  
  
  (defun pyel-comprehension (target iter ifs)
    ;;this uses the inter-transform var 'comprehension-body'
    (assert (boundp 'comprehension-body)
            "`comprehension-body' must be defined for this transform")
    ;;TODO: ifs
    `(loop for ,(using-context for-loop-target
                               (transform target))
           in (py-list ,(transform iter))
           ,(if ifs
                (list '@ 'if 
                         (cons (if (> (length ifs) 1)
                                   'and
                                 '@)
                               (mapcar 'transform ifs)))
              pyel-nothing) 
           do ,comprehension-body))
  
  
  (def-transform list-comp pyel (elt generators)
    (lambda (elt generators) (pyel-list-comp elt generators)))
  
  (defun pyel-list-comp (elt generators)
    (let* ((list-var '__list__)
           (comprehension-body `(setq ,list-var (cons ,(transform elt) ,list-var)))
           (i (length generators))
           code)
      ;;`comprehension-body' is an inter-transform var
      (while (> i 0)
        (setq i (1- i))
        ;;'comprehension-body' holds the inner code, and each transform
        ;; is the inner code for the preceding generator in 'generators'
        ;; (loop ... collect ...) produces a list, so no additional work is needed
        (setq comprehension-body (transform (nth i generators))))
      
      `(let ((,list-var nil))
         ,comprehension-body
         (reverse ,list-var))))
  
  
  (def-transform dict-comp pyel (key value generators)
    (lambda (key value generators) (pyel-dict-comp key value generators)))
  
  (defun pyel-dict-comp (key value generators)
    (let* ((hash-var '__dict__)
           (comprehension-body (list 'puthash (transform key)
                                     (transform value)
                                     hash-var))
           (i (length generators))
           code)
      (while (> i 0)
        (setq i (1- i))
        (setq comprehension-body (transform (nth i generators))))
      
      `(let ((,hash-var (make-hash-table :test 'equal)))
         ,comprehension-body
         ,hash-var)))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def comprehension(target, iter, ifs):
      return l_str(["comprehension", target, iter, l_str(ifs)])
  
  def GeneratorExp(elt, generators):
      return l_str(["list-comp", elt, l_str(generators)])
      
  def ListComp(elt, generators):
      return l_str(["list-comp", elt, l_str(generators)])
  
  def DictComp(key, value, generators):
      return l_str(["dict-comp", key, value, l_str(generators)])    
  
  def SetComp(elt, generators):
      return "(unimplemented \"set comprehension\")"
  
  
#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests 'list-comprehensions
"[x*x for x in range(10)]"
"[x*x for x in range(10) if x > 5]"
"[x*x for x in range(10) if x > 5 if x < 8]"

"assert [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] == [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

"
matrix = [[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],]
_x = [[row[i] for row in matrix] for i in range(4)]
assert _x == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

"
transposed = []
for i in range(4):
 transposed.append([row[i] for row in matrix])
assert transposed == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
"

"{x: [y*y for y in range(x)] for x in range(20)}"

"x = {x: number_to_string(x) for x in range(10)}
assert hash_table_count(x) == 10
assert x[1] == '1'
assert x[9] == '9'
"

)
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-list-comprehensions-full-transform nil
    (should
     (equal
      (pyel "[x*x for x in range(10)]")
      '(let
           ((__list__ nil))
         (loop for x in
               (py-list
                (py-range 10))
               do
               (setq __list__
                     (cons
                      (pyel-* x x)
                      __list__)))
         (reverse __list__))))
    (should
     (equal
      (pyel "[x*x for x in range(10) if x > 5]")
      '(let
           ((__list__ nil))
         (loop for x in
               (py-list
                (py-range 10))
               if
               (pyel-> x 5)
               do
               (setq __list__
                     (cons
                      (pyel-* x x)
                      __list__)))
         (reverse __list__))))
    (should
     (equal
      (pyel "[x*x for x in range(10) if x > 5 if x < 8]")
      '(let
           ((__list__ nil))
         (loop for x in
               (py-list
                (py-range 10))
               if
               (and
                (pyel-> x 5)
                (pyel-< x 8))
               do
               (setq __list__
                     (cons
                      (pyel-* x x)
                      __list__)))
         (reverse __list__))))
    (should
     (equal
      (pyel "assert [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] == [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]")
      '(assert
        (pyel-==
         (let
             ((__list__ nil))
           (loop for x in
                 (py-list
                  (list 1 2 3))
                 do
                 (loop for y in
                       (py-list
                        (list 3 1 4))
                       if
                       (pyel-!= x y)
                       do
                       (setq __list__
                             (cons
                              (vector x y)
                              __list__))))
           (reverse __list__))
         (list
          (vector 1 3)
          (vector 1 4)
          (vector 2 3)
          (vector 2 1)
          (vector 2 4)
          (vector 3 1)
          (vector 3 4)))
        t nil)))
    (should
     (equal
      (pyel "\nmatrix = [[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],]\n_x = [[row[i] for row in matrix] for i in range(4)]\nassert _x == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]")
      '(progn
         (pyel-set matrix
                   (list
                    (list 1 2 3 4)
                    (list 5 6 7 8)
                    (list 9 10 11 12)))
         (pyel-set -x
                   (let
                       ((__list__ nil))
                     (loop for i in
                           (py-list
                            (py-range 4))
                           do
                           (setq __list__
                                 (cons
                                  (let
                                      ((__list__ nil))
                                    (loop for row in
                                          (py-list matrix)
                                          do
                                          (setq __list__
                                                (cons
                                                 (pyel-subscript-load-index row i)
                                                 __list__)))
                                    (reverse __list__))
                                  __list__)))
                     (reverse __list__)))
         (assert
          (pyel-== -x
                   (list
                    (list 1 5 9)
                    (list 2 6 10)
                    (list 3 7 11)
                    (list 4 8 12)))
          t nil))))
    (should
     (equal
      (pyel "\ntransposed = []\nfor i in range(4):\n transposed.append([row[i] for row in matrix])\nassert transposed == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n")
      '(progn
         (pyel-set transposed
                   (list))
         (loop for i in
               (py-list
                (py-range 4))
               do
               (pyel-append-method transposed
                                   (let
                                       ((__list__ nil))
                                     (loop for row in
                                           (py-list matrix)
                                           do
                                           (setq __list__
                                                 (cons
                                                  (pyel-subscript-load-index row i)
                                                  __list__)))
                                     (reverse __list__))))
         (assert
          (pyel-== transposed
                   (list
                    (list 1 5 9)
                    (list 2 6 10)
                    (list 3 7 11)
                    (list 4 8 12)))
          t nil))))
    (should
     (equal
      (pyel "{x: [y*y for y in range(x)] for x in range(20)}")
      '(let
           ((__dict__
             (make-hash-table :test 'equal)))
         (loop for x in
               (py-list
                (py-range 20))
               do
               (puthash x
                        (let
                            ((__list__ nil))
                          (loop for y in
                                (py-list
                                 (py-range x))
                                do
                                (setq __list__
                                      (cons
                                       (pyel-* y y)
                                       __list__)))
                          (reverse __list__))
                        __dict__))
         __dict__)))
    (should
     (equal
      (pyel "x = {x: number_to_string(x) for x in range(10)}\nassert hash_table_count(x) == 10\nassert x[1] == '1'\nassert x[9] == '9'\n")
      '(progn
         (pyel-set x
                   (let
                       ((__dict__
                         (make-hash-table :test 'equal)))
                     (loop for x in
                           (py-list
                            (py-range 10))
                           do
                           (puthash x
                                    (number-to-string x)
                                    __dict__))
                     __dict__))
         (assert
          (pyel-==
           (hash-table-count x)
           10)
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-index x 1)
           "1")
          t nil)
         (assert
          (pyel-==
           (pyel-subscript-load-index x 9)
           "9")
          t nil)))))
  (ert-deftest pyel-list-comprehensions-py-ast nil
    (should
     (equal
      (py-ast "[x*x for x in range(10)]")
      "Module(body=[Expr(value=ListComp(elt=BinOp(left=Name(id='x', ctx=Load()), op=Mult(), right=Name(id='x', ctx=Load())), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=10)], keywords=[], starargs=None, kwargs=None), ifs=[])]))])\n"))
    (should
     (equal
      (py-ast "[x*x for x in range(10) if x > 5]")
      "Module(body=[Expr(value=ListComp(elt=BinOp(left=Name(id='x', ctx=Load()), op=Mult(), right=Name(id='x', ctx=Load())), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=10)], keywords=[], starargs=None, kwargs=None), ifs=[Compare(left=Name(id='x', ctx=Load()), ops=[Gt()], comparators=[Num(n=5)])])]))])\n"))
    (should
     (equal
      (py-ast "[x*x for x in range(10) if x > 5 if x < 8]")
      "Module(body=[Expr(value=ListComp(elt=BinOp(left=Name(id='x', ctx=Load()), op=Mult(), right=Name(id='x', ctx=Load())), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=10)], keywords=[], starargs=None, kwargs=None), ifs=[Compare(left=Name(id='x', ctx=Load()), ops=[Gt()], comparators=[Num(n=5)]), Compare(left=Name(id='x', ctx=Load()), ops=[Lt()], comparators=[Num(n=8)])])]))])\n"))
    (should
     (equal
      (py-ast "assert [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] == [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]")
      "Module(body=[Assert(test=Compare(left=ListComp(elt=Tuple(elts=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=List(elts=[Num(n=1), Num(n=2), Num(n=3)], ctx=Load()), ifs=[]), comprehension(target=Name(id='y', ctx=Store()), iter=List(elts=[Num(n=3), Num(n=1), Num(n=4)], ctx=Load()), ifs=[Compare(left=Name(id='x', ctx=Load()), ops=[NotEq()], comparators=[Name(id='y', ctx=Load())])])]), ops=[Eq()], comparators=[List(elts=[Tuple(elts=[Num(n=1), Num(n=3)], ctx=Load()), Tuple(elts=[Num(n=1), Num(n=4)], ctx=Load()), Tuple(elts=[Num(n=2), Num(n=3)], ctx=Load()), Tuple(elts=[Num(n=2), Num(n=1)], ctx=Load()), Tuple(elts=[Num(n=2), Num(n=4)], ctx=Load()), Tuple(elts=[Num(n=3), Num(n=1)], ctx=Load()), Tuple(elts=[Num(n=3), Num(n=4)], ctx=Load())], ctx=Load())]), msg=None)])\n"))
    (should
     (equal
      (py-ast "\nmatrix = [[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],]\n_x = [[row[i] for row in matrix] for i in range(4)]\nassert _x == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]")
      "Module(body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=List(elts=[List(elts=[Num(n=1), Num(n=2), Num(n=3), Num(n=4)], ctx=Load()), List(elts=[Num(n=5), Num(n=6), Num(n=7), Num(n=8)], ctx=Load()), List(elts=[Num(n=9), Num(n=10), Num(n=11), Num(n=12)], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='_x', ctx=Store())], value=ListComp(elt=ListComp(elt=Subscript(value=Name(id='row', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='row', ctx=Store()), iter=Name(id='matrix', ctx=Load()), ifs=[])]), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=4)], keywords=[], starargs=None, kwargs=None), ifs=[])])), Assert(test=Compare(left=Name(id='_x', ctx=Load()), ops=[Eq()], comparators=[List(elts=[List(elts=[Num(n=1), Num(n=5), Num(n=9)], ctx=Load()), List(elts=[Num(n=2), Num(n=6), Num(n=10)], ctx=Load()), List(elts=[Num(n=3), Num(n=7), Num(n=11)], ctx=Load()), List(elts=[Num(n=4), Num(n=8), Num(n=12)], ctx=Load())], ctx=Load())]), msg=None)])\n"))
    (should
     (equal
      (py-ast "\ntransposed = []\nfor i in range(4):\n transposed.append([row[i] for row in matrix])\nassert transposed == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n")
      "Module(body=[Assign(targets=[Name(id='transposed', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=4)], keywords=[], starargs=None, kwargs=None), body=[Expr(value=Call(func=Attribute(value=Name(id='transposed', ctx=Load()), attr='append', ctx=Load()), args=[ListComp(elt=Subscript(value=Name(id='row', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='row', ctx=Store()), iter=Name(id='matrix', ctx=Load()), ifs=[])])], keywords=[], starargs=None, kwargs=None))], orelse=[]), Assert(test=Compare(left=Name(id='transposed', ctx=Load()), ops=[Eq()], comparators=[List(elts=[List(elts=[Num(n=1), Num(n=5), Num(n=9)], ctx=Load()), List(elts=[Num(n=2), Num(n=6), Num(n=10)], ctx=Load()), List(elts=[Num(n=3), Num(n=7), Num(n=11)], ctx=Load()), List(elts=[Num(n=4), Num(n=8), Num(n=12)], ctx=Load())], ctx=Load())]), msg=None)])\n"))
    (should
     (equal
      (py-ast "{x: [y*y for y in range(x)] for x in range(20)}")
      "Module(body=[Expr(value=DictComp(key=Name(id='x', ctx=Load()), value=ListComp(elt=BinOp(left=Name(id='y', ctx=Load()), op=Mult(), right=Name(id='y', ctx=Load())), generators=[comprehension(target=Name(id='y', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[], starargs=None, kwargs=None), ifs=[])]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=20)], keywords=[], starargs=None, kwargs=None), ifs=[])]))])\n"))
    (should
     (equal
      (py-ast "x = {x: number_to_string(x) for x in range(10)}\nassert hash_table_count(x) == 10\nassert x[1] == '1'\nassert x[9] == '9'\n")
      "Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=DictComp(key=Name(id='x', ctx=Load()), value=Call(func=Name(id='number_to_string', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[], starargs=None, kwargs=None), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=10)], keywords=[], starargs=None, kwargs=None), ifs=[])])), Assert(test=Compare(left=Call(func=Name(id='hash_table_count', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[], starargs=None, kwargs=None), ops=[Eq()], comparators=[Num(n=10)]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='x', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), msg=None), Assert(test=Compare(left=Subscript(value=Name(id='x', ctx=Load()), slice=Index(value=Num(n=9)), ctx=Load()), ops=[Eq()], comparators=[Str(s='9')]), msg=None)])\n")))
  (ert-deftest pyel-list-comprehensions-el-ast nil
    (should
     (string=
      (pyel "[x*x for x in range(10)]" t)
      "(list-comp (bin-op  (name  \"x\" 'load) * (name  \"x\" 'load)) ((comprehension (name  \"x\" 'store) (call  (name  \"range\" 'load) ((num 10)) nil nil nil) ())))\n"))
    (should
     (string=
      (pyel "[x*x for x in range(10) if x > 5]" t)
      "(list-comp (bin-op  (name  \"x\" 'load) * (name  \"x\" 'load)) ((comprehension (name  \"x\" 'store) (call  (name  \"range\" 'load) ((num 10)) nil nil nil) ((compare  (name  \"x\" 'load) (\">\") ((num 5)))))))\n"))
    (should
     (string=
      (pyel "[x*x for x in range(10) if x > 5 if x < 8]" t)
      "(list-comp (bin-op  (name  \"x\" 'load) * (name  \"x\" 'load)) ((comprehension (name  \"x\" 'store) (call  (name  \"range\" 'load) ((num 10)) nil nil nil) ((compare  (name  \"x\" 'load) (\">\") ((num 5))) (compare  (name  \"x\" 'load) (\"<\") ((num 8)))))))\n"))
    (should
     (string=
      (pyel "assert [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] == [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]" t)
      "(assert  (compare  (list-comp (tuple  ((name  \"x\" 'load) (name  \"y\" 'load)) 'load) ((comprehension (name  \"x\" 'store) (list ((num 1) (num 2) (num 3)) 'load) ()) (comprehension (name  \"y\" 'store) (list ((num 3) (num 1) (num 4)) 'load) ((compare  (name  \"x\" 'load) (\"!=\") ((name  \"y\" 'load))))))) (\"==\") ((list ((tuple  ((num 1) (num 3)) 'load) (tuple  ((num 1) (num 4)) 'load) (tuple  ((num 2) (num 3)) 'load) (tuple  ((num 2) (num 1)) 'load) (tuple  ((num 2) (num 4)) 'load) (tuple  ((num 3) (num 1)) 'load) (tuple  ((num 3) (num 4)) 'load)) 'load))) nil)\n"))
    (should
     (string=
      (pyel "\nmatrix = [[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],]\n_x = [[row[i] for row in matrix] for i in range(4)]\nassert _x == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]" t)
      "(assign  ((name  \"matrix\" 'store)) (list ((list ((num 1) (num 2) (num 3) (num 4)) 'load) (list ((num 5) (num 6) (num 7) (num 8)) 'load) (list ((num 9) (num 10) (num 11) (num 12)) 'load)) 'load))\n(assign  ((name  \"_x\" 'store)) (list-comp (list-comp (subscript (name  \"row\" 'load) (index (name  \"i\" 'load)) 'load) ((comprehension (name  \"row\" 'store) (name  \"matrix\" 'load) ()))) ((comprehension (name  \"i\" 'store) (call  (name  \"range\" 'load) ((num 4)) nil nil nil) ()))))\n(assert  (compare  (name  \"_x\" 'load) (\"==\") ((list ((list ((num 1) (num 5) (num 9)) 'load) (list ((num 2) (num 6) (num 10)) 'load) (list ((num 3) (num 7) (num 11)) 'load) (list ((num 4) (num 8) (num 12)) 'load)) 'load))) nil)\n"))
    (should
     (string=
      (pyel "\ntransposed = []\nfor i in range(4):\n transposed.append([row[i] for row in matrix])\nassert transposed == [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n" t)
      "(assign  ((name  \"transposed\" 'store)) (list nil 'load))\n(for  (name  \"i\" 'store) (call  (name  \"range\" 'load) ((num 4)) nil nil nil) ((call  (attribute  (name  \"transposed\" 'load) \"append\" 'load) ((list-comp (subscript (name  \"row\" 'load) (index (name  \"i\" 'load)) 'load) ((comprehension (name  \"row\" 'store) (name  \"matrix\" 'load) ())))) nil nil nil)) nil)\n(assert  (compare  (name  \"transposed\" 'load) (\"==\") ((list ((list ((num 1) (num 5) (num 9)) 'load) (list ((num 2) (num 6) (num 10)) 'load) (list ((num 3) (num 7) (num 11)) 'load) (list ((num 4) (num 8) (num 12)) 'load)) 'load))) nil)\n"))
    (should
     (string=
      (pyel "{x: [y*y for y in range(x)] for x in range(20)}" t)
      "(dict-comp (name  \"x\" 'load) (list-comp (bin-op  (name  \"y\" 'load) * (name  \"y\" 'load)) ((comprehension (name  \"y\" 'store) (call  (name  \"range\" 'load) ((name  \"x\" 'load)) nil nil nil) ()))) ((comprehension (name  \"x\" 'store) (call  (name  \"range\" 'load) ((num 20)) nil nil nil) ())))\n"))
    (should
     (string=
      (pyel "x = {x: number_to_string(x) for x in range(10)}\nassert hash_table_count(x) == 10\nassert x[1] == '1'\nassert x[9] == '9'\n" t)
      "(assign  ((name  \"x\" 'store)) (dict-comp (name  \"x\" 'load) (call  (name  \"number_to_string\" 'load) ((name  \"x\" 'load)) nil nil nil) ((comprehension (name  \"x\" 'store) (call  (name  \"range\" 'load) ((num 10)) nil nil nil) ()))))\n(assert  (compare  (call  (name  \"hash_table_count\" 'load) ((name  \"x\" 'load)) nil nil nil) (\"==\") ((num 10))) nil)\n(assert  (compare  (subscript (name  \"x\" 'load) (index (num 1)) 'load) (\"==\") ((str \"1\"))) nil)\n(assert  (compare  (subscript (name  \"x\" 'load) (index (num 9)) 'load) (\"==\") ((str \"9\"))) nil)\n")))
  
#+END_SRC

* boolop, and, or
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  (def-transform boolop pyel (op values)
    (lambda (op values)
      (cons op (mapcar 'transform values))))
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def BoolOp(op, values):
      return l_str(["boolop", op, l_str(values)])
  def Or():
      return "or"
  def And():
      return "and"
#+END_SRC

** tests
(pyel-create-tests 'boolop
"a or b"
"a or b or c"
"a.c or b.c() or a[2]"
"a and b"
"a and b or c"
"a[2] and b.f() or c.e"
"a.e and b[2] or c.e() and 2 ")
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-boolop-full-transform nil
    (should
     (equal
      (pyel "a or b")
      '(or a b)))
    (should
     (equal
      (pyel "a or b or c")
      '(or a b c)))
    (should
     (equal
      (pyel "a.c or b.c() or a[2]")
      '(or
        (oref a c)
        (c b)
        (pyel-subscript-load-index a 2))))
    (should
     (equal
      (pyel "a and b")
      '(and a b)))
    (should
     (equal
      (pyel "a and b or c")
      '(or
        (and a b)
        c)))
    (should
     (equal
      (pyel "a[2] and b.f() or c.e")
      '(or
        (and
         (pyel-subscript-load-index a 2)
         (f b))
        (oref c e))))
    (should
     (equal
      (pyel "a.e and b[2] or c.e() and 2 ")
      '(or
        (and
         (oref a e)
         (pyel-subscript-load-index b 2))
        (and
         (e c)
         2)))))
  (ert-deftest pyel-boolop-py-ast nil
    (should
     (equal
      (py-ast "a or b")
      "Module(body=[Expr(value=BoolOp(op=Or(), values=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())]))])\n"))
    (should
     (equal
      (py-ast "a or b or c")
      "Module(body=[Expr(value=BoolOp(op=Or(), values=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load()), Name(id='c', ctx=Load())]))])\n"))
    (should
     (equal
      (py-ast "a.c or b.c() or a[2]")
      "Module(body=[Expr(value=BoolOp(op=Or(), values=[Attribute(value=Name(id='a', ctx=Load()), attr='c', ctx=Load()), Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='c', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load())]))])\n"))
    (should
     (equal
      (py-ast "a and b")
      "Module(body=[Expr(value=BoolOp(op=And(), values=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())]))])\n"))
    (should
     (equal
      (py-ast "a and b or c")
      "Module(body=[Expr(value=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())]), Name(id='c', ctx=Load())]))])\n"))
    (should
     (equal
      (py-ast "a[2] and b.f() or c.e")
      "Module(body=[Expr(value=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load()), Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='f', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)]), Attribute(value=Name(id='c', ctx=Load()), attr='e', ctx=Load())]))])\n"))
    (should
     (equal
      (py-ast "a.e and b[2] or c.e() and 2 ")
      "Module(body=[Expr(value=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Attribute(value=Name(id='a', ctx=Load()), attr='e', ctx=Load()), Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load())]), BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='c', ctx=Load()), attr='e', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), Num(n=2)])]))])\n")))
  (ert-deftest pyel-boolop-el-ast nil
    (should
     (string=
      (pyel "a or b" t)
      "(boolop or ((name  \"a\" 'load) (name  \"b\" 'load)))\n"))
    (should
     (string=
      (pyel "a or b or c" t)
      "(boolop or ((name  \"a\" 'load) (name  \"b\" 'load) (name  \"c\" 'load)))\n"))
    (should
     (string=
      (pyel "a.c or b.c() or a[2]" t)
      "(boolop or ((attribute  (name  \"a\" 'load) \"c\" 'load) (call  (attribute  (name  \"b\" 'load) \"c\" 'load) nil nil nil nil) (subscript (name  \"a\" 'load) (index (num 2)) 'load)))\n"))
    (should
     (string=
      (pyel "a and b" t)
      "(boolop and ((name  \"a\" 'load) (name  \"b\" 'load)))\n"))
    (should
     (string=
      (pyel "a and b or c" t)
      "(boolop or ((boolop and ((name  \"a\" 'load) (name  \"b\" 'load))) (name  \"c\" 'load)))\n"))
    (should
     (string=
      (pyel "a[2] and b.f() or c.e" t)
      "(boolop or ((boolop and ((subscript (name  \"a\" 'load) (index (num 2)) 'load) (call  (attribute  (name  \"b\" 'load) \"f\" 'load) nil nil nil nil))) (attribute  (name  \"c\" 'load) \"e\" 'load)))\n"))
    (should
     (string=
      (pyel "a.e and b[2] or c.e() and 2 " t)
      "(boolop or ((boolop and ((attribute  (name  \"a\" 'load) \"e\" 'load) (subscript (name  \"b\" 'load) (index (num 2)) 'load))) (boolop and ((call  (attribute  (name  \"c\" 'load) \"e\" 'load) nil nil nil nil) (num 2)))))\n")))
  
#+END_SRC

* pass
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
 (def-transform pass pyel ()
   (lambda () nil))
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
  def Pass():
      return "(pass)"
#+END_SRC
** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC



* unimplemented
This will help notify the user when some syntax has not been implemented
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
  
  (def-transform unimplemented pyel (name)
    (lambda (name)
      (pyel-notify-error "Set comprehensions have not been implemented")
      pyel-error-string))
  
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC


* conditional expressions
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(def-transform if-exp pyel ()
  (lambda (test body orelse)
      (let ((tst (transform test)))
        `(if ,(if (equal tst []) nil tst)
	     ,(transform body)
 	   ,(transform orelse)))))
#+END_SRC

** python ast
#+Begin_SRC python :tangle py-ast.py
  def IfExp (test, body, orelse):
      return l_str(["if-exp", test, body, orelse])
#+END_SRC
** tests
(pyel-create-tests 'conditional-expressions
"1 if True else 0"
"true() if tst() else false()"
"a[1] if a[2:2] else a[2]"
)

#+Begin_SRC emacs-lisp :tangle pyel-tests.el
  (ert-deftest pyel-conditional-expressions-full-transform nil
    (should
     (equal
      (pyel "1 if True else 0")
      '(if t 1 0)))
    (should
     (equal
      (pyel "true() if tst() else false()")
      '(if
           (tst)
           (true)
         (false))))
    (should
     (equal
      (pyel "a[1] if a[2:2] else a[2]")
      '(if
           (pyel-subscript-load-slice a 2 2 nil)
           (pyel-subscript-load-index a 1)
         (pyel-subscript-load-index a 2)))))
  (ert-deftest pyel-conditional-expressions-py-ast nil
    (should
     (equal
      (py-ast "1 if True else 0")
      "Module(body=[Expr(value=IfExp(test=Name(id='True', ctx=Load()), body=Num(n=1), orelse=Num(n=0)))])\n"))
    (should
     (equal
      (py-ast "true() if tst() else false()")
      "Module(body=[Expr(value=IfExp(test=Call(func=Name(id='tst', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), body=Call(func=Name(id='true', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None), orelse=Call(func=Name(id='false', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)))])\n"))
    (should
     (equal
      (py-ast "a[1] if a[2:2] else a[2]")
      "Module(body=[Expr(value=IfExp(test=Subscript(value=Name(id='a', ctx=Load()), slice=Slice(lower=Num(n=2), upper=Num(n=2), step=None), ctx=Load()), body=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), orelse=Subscript(value=Name(id='a', ctx=Load()), slice=Index(value=Num(n=2)), ctx=Load())))])\n")))
  (ert-deftest pyel-conditional-expressions-el-ast nil
    (should
     (string=
      (pyel "1 if True else 0" t)
      "(if-exp (name  \"True\" 'load) (num 1) (num 0))\n"))
    (should
     (string=
      (pyel "true() if tst() else false()" t)
      "(if-exp (call  (name  \"tst\" 'load) nil nil nil nil) (call  (name  \"true\" 'load) nil nil nil nil) (call  (name  \"false\" 'load) nil nil nil nil))\n"))
    (should
     (string=
      (pyel "a[1] if a[2:2] else a[2]" t)
      "(if-exp (subscript (name  \"a\" 'load) (slice (num 2) (num 2) nil) 'load) (subscript (name  \"a\" 'load) (index (num 1)) 'load) (subscript (name  \"a\" 'load) (index (num 2)) 'load))\n")))
  
#+END_SRC

* transform template
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* ---------------------
* misc
#+Begin_SRC emacs-lisp :tangle pyel.el
(defun char-split-string (string)
  "split a string into its charaters"
  (cdr (butlast (split-string string ""))))


(defun strip-end (string &optional char)
  "if CHAR occurs at the end of STRING, remove it"
  (let ((split (char-split-string string))
	(char (or char " ")))

    (while (string= char (car (last split)))
      (setq split (butlast split)))
    (mapconcat 'identity split "")))

(defun strip-start (string &optional char)
  "if CHAR occurs at the beginning of STRING, remove all occurrences"
  (let ((split (char-split-string string))
	(char (or char " ")))
    
    (while (string= char (car split))
      (setq split (cdr split)))
    (mapconcat 'identity split "")))

;;built-in equivalent?
(defun file-path-concat (&rest dirs)
  "concatenate strings representing file paths
prevents multiple/none '/' seporating file names"
  (let* ((first (strip-end (car dirs) "/"))
	 (last (strip-start (car (last dirs)) "/"))
	 (dirs (append (list first)
		       (mapcar '(lambda (x)  (strip-start (strip-end x "/") "/")) 
			       (cdr (butlast dirs)))
		       (list last))))
    (mapconcat 'identity dirs "/")))

#+END_SRC

* EOF

** main
#+Begin_SRC emacs-lisp :tangle pyel.el
  (require 'transformer)
  (require 'pyel-transforms)
  (require 'pyel-tests-generated)
  (require 'pyel-preprocessor)  
  
  (require 'pyel-mode)
  
  (provide 'pyel)
  ;;pyel.el ends here
#+END_SRC
** transforms
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
(provide 'pyel-transforms)
;;pyel-transforms.el ends here
#+END_SRC
** tests
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
(provide 'pyel-tests)
;;pyel-tests.el ends here
#+END_SRC
** py-lib
#+Begin_SRC emacs-lisp :tangle py-lib.el
(provide 'py-lib)
;;py-lib.el ends here
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py
#py-ast.py ends here
#+END_SRC  

* ------------------
* transform template
** transform
#+Begin_SRC emacs-lisp :tangle pyel-transforms.el
;;
#+END_SRC
** python ast
#+Begin_SRC python :tangle py-ast.py

#+END_SRC
** python el lib
#+Begin_SRC python :tangle py-lib.el

#+END_SRC

** tests
(pyel-create-tests '<name>
#+Begin_SRC emacs-lisp :tangle pyel-tests.el
;;
#+END_SRC

* .emacs config (move)
#+Begin_SRC emacs-lisp :tangle pyel.el
(setq pyel-use-list-for-varargs t)
;;(setq pyel-directory "path/to/pyel/directory")
;;(require 'pyel)
#+END_SRC

