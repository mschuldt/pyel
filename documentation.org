* About the files
Pyel is an experiment with literate programming using org mode.
py-ast.py, pyel-preprocessor.el, pyel.el, pyel-transforms.el, pyel-tests.el, and py-lib.el contain code that is tangled from pyel.org and should not be edited directly.

* partial and non-supported features
** empty lists
Python lists are translated directly into elisp list. This is the fastest
way but raises a problem for empty lists. In python each empty list is a 
separate object but in elisp all empty lists are 'nil',(e-lisp's 
equivalent of False. Because of this you cannot have multiple references to
an empty list. If multiple references to the same list is needed, at least
one element must be added before the list is assigned to other variables.

#+Begin_SRC emacs-lisp
x = []
y = x
x.append(3)
x is y //True in Python, False in translated code

x = [1]
y = x
x.append(3)
x is y //ok
#+END_SRC

* Internals
Pyel utilized the AST generated by the python interpreter. After the AST is converted to an s-expression format e-lisp is used to do the rest of the work.

The python is first preprocessed and known e-lisp macros calls are pulled out for AST generation. These seporate ASTs are then merged with the main one. 

Code transforms are defined in e-lisp that transform the syntactic features as independently as possible. Some transforms communicate with one another using 'inter-transform variables'.

A special kind of transform template defines translations of python functions and methods that operate on multiple types in Python but fewer or different types in e-lisp. The e-lisp functions are generated from these definitions at translation time and take advantage of the known type possibilities of their arguments, allowing them to eliminate unnecessary type testing, ideally eliminating it altogether. Currently no kind of type inference exits so Pyel generates the worst possible code.

list, tuple, and dict from python are mapped to list, vector, and hash tables in elisp, respectively.

* defining new transforms
Their are several kinds transformations, here are examples for each of them.

** Changing a function name

#+Begin_SRC emacs-lisp
(pyel-translate-function-name 'range 'py-range)
(pyel-translate-function-name 'map 'mapcar)
#+END_SRC

** Changing a variable (or constant) name
#+Begin_SRC emacs-lisp
(pyel-translate-variable-name 'None 'nil)
#+END_SRC

** General transform
#+Begin_SRC emacs-lisp
(def-transform assert pyel ()
    (lambda (test msg) 
      `(assert ,(transform test) t ,(transform msg))))
#+END_SRC

** Type switching transforms
#+Begin_SRC emacs-lisp
(pyel-create-py-func ** (l r) ;;pow
                    (number number) -> (expt l r)
                    (object _ ) 
                    (_ object) -> (--pow-- l r))
#+END_SRC

** Method translation
#+Begin_SRC emacs-lisp
(pyel-method-transform append (obj thing)
                  (list _) -> (setq $obj (append obj (list thing)))
                  (_ _)    -> (append obj thing))
#+END_SRC

** Function type-switch translation
#+Begin_SRC emacs-lisp
(pyel-func-transform len (thing)
                       (object) -> (__len__ ,thing)
                       (_)      -> (length ,thing))
#+END_SRC

** Function direct translation
#+Begin_SRC emacs-lisp
(pyel-define-function-translation
   print
   `(py-print ,(cadr (assoc 'sep kwargs))
              ,(cadr (assoc 'end kwargs))
              nil ;;TODO: file=sys.stdout
              ,@args))
#+END_SRC
** Declare a name to be a macro

#+Begin_SRC emacs-lisp
(pyel-declare-macro "save_excursion")
#+END_SRC
