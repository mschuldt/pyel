
;; This is a tangled file  -- DO NOT EDIT --  Edit in pyel.org

(add-to-list 'load-path "~/programming/pyel/")
  (add-to-list 'load-path "~/programming/code-transformer/")  
  (require 'eieio)
  (require 'cl) 
;;other requires are at the end

;; This is a tangled file  -- DO NOT HAND-EDIT -- 
;;PYEL -> translate PYthon to Emacs Lisp

(defun mpp (code)
  (let ((pp (pp-to-string code)))
    (insert "\n" pp)))


;;TODO: more robust checking, return type of error as well
(defun pyel-is-error (code)
  "return the line of the error in CODE, else nil"
  (let ((line))
    (if (string-match "^Traceback" code)
        (with-temp-buffer
          (insert code)
          (goto-char (point-max))
          (if (re-search-backward "line \\([0-9]+\\)")
              (setq line (match-string 1)))))
    ;;TODO: why is this the actual line number...it should be relative the a bunch of code it's appended to ...
    (and line (string-to-number line))))

(defvar pyel-transform-status nil
  "indicate status (success/fail) of last pyel transform
status types:
nil for no error
('python ast transform error'  <line number>) 
")

(defvar pyel-error-string "PYEL ERROR"
  "string returned by `pyel' when it failed to transform")

(defun pyel-py-ast-file-name ()
  "return the full file name of py-ast.el"
  (file-path-concat pyel-directory "py-ast.py"))


(defun pyel (python &optional py-ast-only include-defuns)
  "translate PYTHON into Emacs Lisp.
PYTHON is a string.
If PY-AST-ONLY, return the un-evaled ast.
If INCLUDE-DEFUNS, include the list of pyel defined functions in the output
  this is ignored if PY-AST-ONLY is non-nil"
  (assert (eq lexical-binding nil) "pyel requires dynamic scoping")
  
  (setq pyel-marked-ast-pieces nil)
  (setq pyel-transform-status nil) ;;so far so good...

  (let* (;;Q general way of replacing backslashes?
         (python (replace-regexp-in-string "\"" "\\\\\"" python))
         ;(python (replace-regexp-in-string "\n" "\\\\n" python nil :literal))
         
         ;; (pyel "x = 'x\n'")
        (py-ast "")
        (el-code "")
        (current-transform-table (get-transform-table 'pyel))
        (python (with-temp-buffer
                  (insert python)
                  (pyel-preprocess-buffer2)
                  (buffer-string)))
        (pyel-context nil)
        line ret
        )
    
    ;;?? setting the mark?
    (with-temp-buffer
      ;;    (find-file file)
      ;;    (erase-buffer)
      (insert-file-contents-literally (pyel-py-ast-file-name))
      (goto-char (point-max))
      (insert "\n")
      (setq line (line-number-at-pos))
      (insert (format "print(eval(ast.dump(ast.parse(\"\"\"%s\"\"\"))))" python))
      (write-region
       nil
       nil
       pyel-tmp-file nil 'silent))
    
    (setq py-ast (shell-command-to-string (format "python3 %s" pyel-tmp-file)))

    (if (setq py-error (pyel-is-error py-ast))
        (progn
          (setq pyel-python-error-line py-error)
          pyel-error-string)
        ;;else: no error
    (if py-ast-only
        py-ast
      ;;      (pyel-do-splices (transform (read py-ast))))))
      ;;read can only return one sexp so we need to put it in a progn or something
      ;;similar
      
      (setq ret (pyel-do-splices (if include-defuns
                           (list '@ (cons '@ pyel-function-definitions)
                                    (transform (read (format "(@ %s)" py-ast))))
                         (transform (read  (format "(@ %s)" py-ast))))))
      ;;TODO: this is a temp solution for convenience
      (mapc 'eval pyel-function-definitions) 
      ret
      ))))


(defun pyel-buffer-to-string (&optional ast-only)
  "transform python in current buffer and return a string"
  ;;THIS DOES NOT RETURN A STRING!
  (pyel (buffer-string) ast-only))


(defvar pyel-pp-function 'pp-to-string
      "function that pretty prints pyel e-lisp code")
      
(defun pyel-buffer (&optional out-buff)
  "transform python in current buffer and display in OUT-BUFF,
OUT-BUFF defaults to *pyel-output*"
  (interactive)
  (let ((out (pyel-buffer-to-string)))
    (switch-to-buffer-other-window "*pyel-output*")
    (erase-buffer)
    (insert (funcall 'pyel-pp-function out))
    (emacs-lisp-mode)))

(defun pyel-transform-ast (ast &optional no-splice)
  "transform a python AST to Emacs Lisp, AST must be a string
AST can be generated by `pyel' with (pyel py-string t)"
  (with-transform-table 'pyel
                        (let ((code (transform (read  (format "(@ %s)" ast)))))
                          (if no-splice
                              code
                            (pyel-do-splices code)))))


(defun pyel-file-ast (file-name)
  "return the ast from .py file FILE-NAME"
  )
      
(defmacro pyel-with-known-types (known-types &rest code)
  "translate CODE while faking the known types"
  `(flet ((pyel-get-possible-types
           (&rest args)
           (mapcar* (lambda (arg type) (cons arg type))
                    args ,known-types)))
     
     (pyel ,@code)))


(defun py-ast (code &optional pp)
  "Return the python abstract syntax tree for python CODE"
  (let ((py-ast "")
        (el-code "")
        ret)
    
    (with-temp-buffer
      (insert "import ast" "\n")
      (insert (format "print(ast.dump(ast.parse(\"\"\"%s\"\"\")))" code))
      (write-region nil nil pyel-tmp-file nil 'silent))
    
    (setq ret (shell-command-to-string (format "python3 %s" pyel-tmp-file)))
    (if pp
        (mapconcat 'identity (split-string ret ",") ",\n")
      ret)))


;;'(a (@ b (c)))) => (a b (c))
;;'(a (@ b c)))   => (a b c)
;;'(@ a b c) => (progn a b c)
;;'(@ (a b)) = > (a b)
;;'(a (@) b) = > (a b)

(defun pyel-do-splices (code)
  (if (listp code)
      (let (c)
        (if (eq (car code) '@) ;;special case: outer most list 
            (if (> (length code) 2)
                (pyel-do-splices `(progn ,code))
              (pyel-do-splices (cadr code)))
          (let ((ncode nil))
            (while code
              (setq c (pop code))
              (if (listp c)
                  (if (equal (car c) '@)
                      (setq ncode (append (reverse (pyel-do-splices (cdr c))) ncode))
                    (push (pyel-do-splices c) ncode))
                (push c ncode)))
            (if (listp ncode) (reverse ncode) ncode))))
    code))



(defun pyel-reload ()
    (interactive)
    (dolist (f '(pyel
                 pyel-tests
                 pyel-transforms
                 pyel-mode
                 pyel-pp
                 pyel-preprocessor
                 transformer))
      (setq features (remove f features)))
    (require 'pyel))


(defun pyel-method-transform-name(method-name)
  "return the name of the temlate that transform the method METHOD-NAME.
template names are modified to avoid potential conflict with other templates"
  (intern (format "_%s-method_" (symbol-name method-name))))


(defun pyel-func-transform-name (func-name)
  "like `pyel-method-transform-name' for functions"
  (intern (format "_%s-function_" (symbol-name func-name))))



(defmacro push-back (val place)
  "Add VAL to the end of the sequence stored in PLACE. Return the new
value."
  `(setq ,place (append ,place (list ,val))))

(defun pyel-translate-function-name (name new-name)
  "translate python NAME to e-lisp NEW-NAME"
  (push (list name new-name) pyel-function-name-translations))

(defun pyel-translate-variable-name (name new-name)
  "translate python  NAME to e-lisp NEW-NAME"
  (push (list name new-name) pyel-variable-name-translations))


(defun pyel-not-implemented (message)
  "signify that a feature is not implemented"
  ;;TODO
  (message message) ;;tmp
  )


(defmacro insert-at (list nth value)
  "insert VALUE at NTH index in LIST"
  `(setq ,list (append (subseq ,list 0 ,nth)
                       (list ,value)
                       (subseq ,list  ,nth))))

(defun list-to-vector (list)
  (eval `(vector ,@list))) ;;this is gross


(defun _to- (thing)
  (cond
   ((stringp thing)

    (replace-regexp-in-string "_" "-"  thing))
   ((symbolp thing)
    (intern (replace-regexp-in-string "_" "-"  (symbol-name thing))))
   ((listp thing) (mapcar '_to- thing))
   (t (error "ERROR in _to-. invalid thing"))))


(defun pyel-change-ctx (form ctx)
  "change ctx of form to CTX"
  (let ((type (and (listp form) (car form))))
    (cond ((eq type 'name)
           (list (car form) (cadr form) (list 'quote ctx)))
          ;;TODO: attribute and other forms (if needed)
          (t form))))


(defun pyel-make-ast (type &rest args)
  "Generate pyhon ast.
This is used when the ast form is needed by a transform that is manually
 called from another transform"
  (flet ((assert_n_args (type expect have)
                        (assert (= expect have)
                                (format "pyel-make-ast -- ast type '%s'expects %s args. received %s args" type expect have)))
         (correct_ctx (ctx)
                      (if (symbolp ctx)
                          (pyel-make-ast ctx)
                        ctx))
         (correct_to_string (name)
                            (if (stringp name)
                                name
                              (if (symbolp name)
                                  (symbol-name name)
                                (error "invalid type for 'name'")))))
    
    ;;TODO: should have seporate functions to check
    ;;      the validity of the ast instead of having
    ;;      the correction functions do it
    (case type
      
      (subscript ;;args: value slice ctx
       (assert_n_args 'subscript 3 (length args))
       
       (let ((ctx (correct_ctx (car (last args)))))
         (list 'subscript (car args) (cadr args) ctx)))
      
      (name ;;args: name ctx
       (assert_n_args 'name 2 (length args))
       (let* ((name (correct_to_string (car args)))
              
              (ctx (correct_ctx (car (last args)))))
         
         (list 'name name ctx)))
      
      (load
       '(quote load))
      (store
       '(quote store)))))


(defmacro macrop (sym)
  (if (boundp sym)
      (list 'macrop-1 sym)
    `(macrop-1 (quote ,sym))))

(defun macrop-1 (function)
  ;;this is mostly taken from `describe-function-1'
  (let* ((advised (and (symbolp function) (featurep 'advice)
                       (ad-get-advice-info function)))
         ;; If the function is advised, use the symbol that has the
         ;; real definition, if that symbol is already set up.
         (real-function
          (or (and advised
                   (let ((origname (cdr (assq 'origname advised))))
                     (and (fboundp origname) origname)))
              function))
         ;; Get the real definition.
         (def (if (symbolp real-function)
                  (symbol-function real-function)
                function)))
    (eq (car-safe def) 'macro)))

(defun callable-p (object)
  (if (symbolp object)
      (or (fboundp object)
          (functionp object)) ;;necessary?
    (functionp object)))

(defvar pyel-directory ""
    "Path to pyel files. must include py-ast.py, pyel.el etc")

(defmacro vfunction-p (f)
  `(and (boundp ',f)
        (functionp ,f)))

(set (defvar pyel-type-test-funcs nil  
       "alist of types used in pyel-call-transform for the switch-type
      and the function used to test for that type")
     '((string stringp)
       (number numberp)
       (integer integerp)
       (int integerp)
       (float floatp)
       (vector vectorp)
       (list listp)
       (cons consp)
       (hash hash-table-p)
       (hash-table hash-table-p)
       (symbol symbolp)
       (array arrayp)
       (object object-p)
       (function functionp)
       (func fboundp)
       (vfunction vfunction-p)
       (vfunc vfunction-p)
       (callable callable-p)))

(defvar pyel-negated-function-tests nil
  "A list of automatically created negated functions from `pyel-type-test-funcs'
stored here just for convenient inspection")

;;create negated test functions
(let (new func fname)
  (setq pyel-negated-function-tests nil)
  (mapc (lambda (x)
          (setq name (cadr x)
                !name (intern (concat "!" (symbol-name name)))
                func `(defsubst ,!name (x) (not (,name x))))
          (add-to-list 'pyel-negated-function-tests func)
          (eval func)
          (push (list (intern (concat "!" (symbol-name (car x))))
                      !name)
                new))
        pyel-type-test-funcs)
  (setq pyel-type-test-funcs (append pyel-type-test-funcs new)))
  
  
  (defvar pyel-defined-classes nil
    "list of call class names defined by pyel")
  
  
  
  (defvar pyel-defined-functions nil
    "list of some functions defined pyel
    used by some templates to determine if a needed function has been defined yet")
  
  (defvar pyel-function-definitions nil
    "used to store function definitions created by pyel, not the user.")
  
  (defvar pyel-replace-args nil
    "if non-nil, pyel-do-call-transform will replace the arg symbols with their
    value, used if the code is to be inlined
    TODO: the option to replace the args should probably be obsoletede")
  
  (defvar pyel-unique-obj-names nil
    "if non-nil, uniquely name object instantces")
  
  
  (defvar pyel-context-groups nil ;;TODO: still used?
    "groups of contexts that cannot exist at the same time.
  `context-p' will stop at the first one in the list,")
  
  (setq pyel-context-groups
        '((assign-target assign-value)))
  
  (defvar pyel-function-name-translations nil
    "alist of function name translations, python->e-lisp.
  
  Entries in `pyel-function-name-translations' are applied before
  checking for function transforms.
  If a translation len->length is defined then the function transform for
  'len' will not be detected because the name is now 'length'
  ")
  
  (defvar pyel-variable-name-translations nil
    "alist of variable name translations, python->e-lisp.")
  
  (setq pyel-function-name-translations `(
                                          
                                          ))
  ;;TODO: list, vector, etc
  ;;      map?               
  
  (setq pyel-variable-name-translations '((True t)
                                          (False nil)
                                          (None nil)))
  
  (defvar pyel-method-transforms nil
    "List of names of methods for which a transform has been defined
  For internal use only--do not modify by hand"
    )
  
  (defvar pyel-func-transforms nil
    "list of function names that have transforms defined for them")
  
  
  (defconst pyel-nothing '(@)
    "value to return from a function/transform when it should
  not contribute to the output code")
  
  (defconst pyel-python-version "3.2.3"
    "python interpreter version whose ast pyel is written for")
  
  
  
  (defvar test-variable-values nil
    "variables values for running tests")
  

  (setq test-variable-values
        '((pyel-defined-classes nil)
          (pyel-function-definitions nil)
          (pyel-defined-functions nil)
          (pyel-obj-counter 0)
          (pyel-unique-obj-names nil)
          ;;(pyel-method-transforms nil)
          ;;(pyel-func-transforms nil)
          (pyel-marker-counter 0)))    
  
  (defvar pyel-marker-counter 0)
  
(defvar pyel-tmp-file  "/tmp/pyel-ast.py"
  "Name of temp file to use for AST generation")

(defvar pyel-default--init--method
    "(defmethod --init-- ((self %s))
     \"Default initializer\"
    )"
    
    "default initializer for pyel objects.")

  (defvar pyel-use-list-for-varargs nil
      "Determines if *varargs will be passed to function as a list or a vector,
  non-nil for list, otherwise vector.
  To be like python (vectors), this should be nil
  To be consistent with Emacs-Lisp (lists), this should be t.
     On the python side, this means that *varargs is a list instead of a tuple")

(defmacro pyel-block (&rest code)
  `(progn ,@ code))

;;TODO: this should be generalized and added to the transform code
(defvar pyel-context nil
  "list of current expansion contexts")

(defmacro using-context (context &rest code)
  `(progn
     (push ',context pyel-context)
     (let ((ret (progn ,@code)))
       (pop pyel-context)
       ret)))
(def-edebug-spec using-context (symbolp &rest form))


(defmacro remove-context (context &rest code)
  "remove CONTEXT and translate CODE, then restore context"
  `(let ((pyel-context (remove ',context pyel-context)))
     ,@code))
(def-edebug-spec remove-context (symbolp &rest form))

(defmacro context-switch (&rest forms)
  `(cond ,@(mapcar (lambda (x)
                     `(,(let ((context (car x)))
                          (if (eq context t) t
                            `(member ',context pyel-context))) ,@(cdr x)))
                   forms)))

(defun get-context-group (context)
  (let ((groups pyel-context-groups)
        (found nil)
        group)
    (while groups
      (setq group (car groups)
            groups (cdr groups))
      (dolist (g group)
        (when (equal g context)
          (setq found group
                groups nil))))
    found))

;; (defun context-p (context)
;;   (member context pyel-context))
(defun context-p (context)
    ;;;;TODO: the extra features that this provides is probably not being used anywere...
  (let ((group (get-context-group context))
        (cont pyel-context)
        (ret nil)
        c)
    (while cont
      (setq c (car cont)
            cont (cdr cont))
      ;;if the context is in a group only return t if it is the first one in pyel-context
      (if (member c group)
          (setq ret (equal c context)
                cont nil)
        (when (equal c context)
          (setq ret t
                cont nil))))
    ret))



(defun context-depth (context)
  "get the depth of CONTEXT in `pyel-context'"
  ;;TODO:
  )

;;this is all temp for testing
(setq known-types '((number object ) (number string)))

;;prevents error: "Wrong type argument: listp, string"
;;TODO: this is a bit of a mess now. types 'func' and 'function' in type
;;transforms result in different tests but func/function still kind of mean the
;;same thing when it comes to python. if func is known type, function should
;;also be know. need some kind of an alias mechanism
(setq known-types
      '((number list vector string object hash function func symbol vfunc)
        (number list vector string object hash function func symbol vfunc)
        (number list vector string object hash function func symbol vfunc)
        (number list vector string object hash function func symbol vfunc)
        (number list vector string object hash function func symbol vfunc)
        (number list vector string object hash function func symbol vfunc)
        (number list vector string object hash function func symbol vfunc)
        (number list vector string object hash function func symbol vfunc)
        (number list vector string object hash function func symbol vfunc)
        (number list vector string object hash function func symbol vfunc)))
(push (list 'known-types known-types) test-variable-values)

(defun pyel-get-possible-types (&rest args)
  "return a list in the form (arg types).
  The car is the argument and the cdr is a list of possible types"
  
  ;;FOR TESTING
  (let ((types (if (>= (length known-types) (length args))
                   known-types
                 (append known-types '(string number list vector integer float))))
        (args (filter (lambda (x) (not (or (eq x '&optional)
                                           (eq x '&rest)))) args)))
    
    (mapcar* (lambda (arg type) (cons arg type))
             args types)))

(defun pyel-filter-non-args(args)
  "remove '&optional' and '&rest' from ARGS list"
  (filter (lambda (x) (not (or (eq x '&optional)
                               (eq x '&rest))))
          args))

  
;;TODO: have functions saved in another file,
;;      instead of putting them all at the top of the file, have some type of
;;      require/import mechanism to functions are not constantly being redefined
;;    option to place insert function defs instead of requires
(defmacro pyel-create-py-func (name args &rest type-switches)
  "return the function name"
  ;;create a template that will resolve arg types and create a new function 
  
  ;;-determine if enough type info is available to eliminate testing
  ;;-if testing is necessary, use `pyel-do-call-transform' like function to generate
  ;; the testing and calling structure and put that in a function
  ;;-create defun code if not yet defined
  ;;  add new func name to defined code list
  
  ;;temp solution: does not check types etc
  (let* ((striped-args (mapcar 'strip_ args))
         (args-just-vars (pyel-filter-non-args striped-args))
         (rest-arg (if (eq (car (last striped-args 2)) '&rest)
                       (car (last striped-args)) nil)))

    `(def-transform ,name pyel ()
       (lambda ,striped-args
         (let ((fsym ',(intern (concat "pyel-" (symbol-name name) "")))
               ;;      (body (pyel-do-call-transform (pyel-get-possible-types ,@(mapcar (lambda (x) `(quote ,x))args))
               (body (pyel-do-call-transform (pyel-get-possible-types
                                              ,@args-just-vars)
                                             ',args
                                             ',type-switches))
               (known-types nil)) ;;tmp
           (unless (member fsym pyel-defined-functions)
             (push (list 'defmacro fsym ',striped-args
                         body)
                   pyel-function-definitions)
             (push fsym pyel-defined-functions)
             (fset fsym (lambda () nil)))
           ;;(if (eq (car (last args 2)) '&rest)
               
           ;; (cons fsym (mapcar 'eval ,(if rest-arg
           ;;                               `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
           ;;                             `(quote ,args-just-vars))))
           (cons fsym ,(if rest-arg
                          `(append (list ,@(subseq args-just-vars 0 -1)) ,rest-arg)
                        (cons 'list args-just-vars)))
           )))))

(defmacro pyel-method-transform (name args &rest type-switches)
  "define transforms for method calls on primative types"
  ;;method transforms are defined like normal type-transforms
  ;;when a method call is being transformed the name is looked up in the list
  ;;of defined method transforms, if it found, this transform will override
  ;;the normal transform.
  (add-to-list 'pyel-method-transforms name)
  ;;TODO: should name be modified to avoid conflicts ?
  `(def-transform ,(pyel-method-transform-name name) pyel () 
     (lambda ,args
       (let ((fsym (intern (concat "pyel-" (symbol-name ',name) "-method")))
             (body (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                           ',args
                                           ',type-switches))
             (known-types nil)) ;;tmp -- should this be before 'body' is set!!??
         
         (unless (member fsym pyel-defined-functions)
           (push (list 'defmacro fsym ',(mapcar 'strip_ args)
                       body)
                 pyel-function-definitions)
           (push fsym pyel-defined-functions)
           (fset fsym (lambda () nil)))
         (cons fsym (mapcar 'eval ',args))))))

(defmacro pyel-func-transform (name args &rest type-switches)
  "define transforms for function calls"
  ;;function transforms are defined like normal type-transforms
  ;;when a function call is being transformed the name is looked up in the list
  ;;of defined function transforms, if it found, this transform will override
  ;;the normal function call transform.
  (add-to-list 'pyel-func-transforms name)
  ;;TODO: should name be modified to avoid conflicts ?
  `(def-transform ,(pyel-func-transform-name name) pyel () 
     (lambda ,args
       (let ((fsym (intern (concat "pyel-" (symbol-name ',name) "-function")))
             (body (pyel-do-call-transform (pyel-get-possible-types ,@args)
                                           ',args
                                           ',type-switches))
             (known-types nil)) ;;tmp -- should this be before 'body' is set!!??
         
         (unless (member fsym pyel-defined-functions)
           (push (list 'defmacro fsym ',(mapcar 'strip_ args)
                       body)
                 pyel-function-definitions)
           (push fsym pyel-defined-functions)
           (fset fsym (lambda () nil)))
         (cons fsym (mapcar 'eval ',args))))))


;;TODO: this should be more general to allow for things like subscript to use it

;;TODO: rename pyel-def-funcall -> pyel-create-py-func
(defmacro pyel-def-funcall (name args &rest type-switches)
  "Define how to call the function NAME.
      NAME is a function that is called differently based on its argument types.
      An attempt will be made to test the least possible number of types.
      
      This defines a transforms in the pyel transform table with NAME and ARGS"
  `(def-transform ,name pyel ()
     (lambda ,args
       (pyel-do-call-transform (pyel-get-possible-types ,@args)
                               ',args
                               ',type-switches))))

;;TODO: rename pyel-def-funcall -> pyel-def-type-transform
(defmacro pyel-def-type-transform (name args &rest type-switches)
  "Define a transform NAME that produces code based on the types of ARGS
    TYPE-SWITCHES
    
    This defines a transforms in the pyel transform table with NAME and ARGS"
  `(def-transform ,name pyel ()
     (lambda ,args
       (pyel-do-call-transform (pyel-get-possible-types ,@args)
                               ',args
                               ',type-switches))))

;; (defmacro pyel-def-call-func (name args &rest type-switches)
;;   "like `pyel-def-call-template' except that it generates a macro that
;; is called directly, because of this NAME must be unique"
;;   `(defun ,name ,args
;;      ;;   (let (,(mapcar (lambda (arg) `(,arg ',arg)) args))
;;      (pyel-do-call-transform (pyel-get-possible-types ,@args)
;;                              ',args
;;                              ',type-switches)))


(defun pyel-expand-type-switch (type-switch)
  "expands the types switch form to a list of cond clauses"
  (flet ((helper (arg form)
                 (let ((type (car form))
                       (varlist (cadr form))
                       mod types ret and-or)
                   (if (consp type)
                       (progn
                         ;;TODO: this can never be 'and'
                         (setq and-or (car type))
                         (dolist (tp (cdr type))
                           (push `((,arg ,tp) ,varlist) ret))
                         `(,and-or ,@(reverse ret)))
                     `((,arg ,type) ,varlist))))
         (expander (type-switch)
                   
                   
                   (let ((args (car type-switch))
                         (forms (cdr type-switch))
                         and-or ret inner tmp tests)
                     (if (consp args)
                         (progn
                           (setq and-or (car args)) ;;TODO: verify and/or
                           (if (eq and-or 'and)
                               (dolist (form forms)
                                 (setq tests nil)
                                 (dolist (arg (cdr args))
                                   (push (car (helper arg form)) tests))
                                 (push `(and ,(reverse tests) ,(cadr form)) ret))
                             ;;else == or
                             (dolist (form forms)
                               (dolist (arg (cdr args))
                                 (setq tmp (helper arg form))
                                 (if (equal (car tmp) 'or)
                                     (dolist (x (cdr tmp))
                                       (push x ret))
                                   (push (helper arg form) ret))))))
                       
                       ;;else single arg
                       (dolist (form forms)
                         (setq tmp (helper args form))
                         (if (equal (car tmp) 'or)
                             (dolist (x (cdr tmp))
                               (push x ret))
                           (push tmp ret))))
                     (reverse ret))))
    (let ((ret nil))
      (dolist (ts type-switch)
        (dolist (e (expander ts))
          (push e ret)))
      (reverse ret))))


;;TODO: fix bug with  `pyel-expand-type-switch-2'
;;      the arg pattern (x x) should not expand unless
;;      x is a possible type of both args


(defun pyel-expand-type-switch-2 (arglist patterns)
  "has output identical to `pyel-expand-type-switch' just translates
      different syntax"
  (let ((group nil) 
        (groups nil)
        (ngroups nil)
        (ret nil)
        code)
    
    
    ;;stage1: collect into groups
    (while patterns
      (setq p (pop patterns))
      
      (if (not (eq p '->))
          (push-back p group)
        (push-back (pop patterns) group)
        (push-back group groups)
        (setq group nil)))
    
    (dolist (g groups)
      (let* ((g (reverse g))
             (code (car g))
             (g (cdr g))
             ;;      (param-types (make-vector (length (car g)) nil))
             type)
        
        (dolist (arg-pattern (reverse g)) ;;for each arg pattern
          (setq group-patterns nil)
          (dotimes (i (length arg-pattern)) ;;for each type or '_
            (setq type (nth i arg-pattern))
            (if  (not (eq type '_))
                (push `((,(nth i arglist) ,type) ,code) group-patterns)))
          (if (null group-patterns) ;;all types where _
              (setq ret (append ret (list (list t code))))
            (if (= (length group-patterns) 1)
                (setq ret (append ret (reverse group-patterns)))
              (setq ret (append ret (list (cons 'and 
                                                (list (mapcar 'car
                                                              (reverse group-patterns))
                                                      code))))))))))
    ret))


(defun pyel-do-call-transform (possible-types args type-switch)
  "This is responsible for  producing a call to NAME in the most
      efficient way possible with the known types"
  (let* ((possible-types (let ((ret nil)
                               arg)
                           ;;get entries in form (arg . type)
                           (dolist (p-t possible-types)
                             (setq arg (car p-t))
                             (dolist (type (cdr p-t))
                               (push (cons arg type) ret)))
                           ret))
         (c 0)

         (args-just-vars (pyel-filter-non-args (mapcar 'strip_ args)))
         (new-args (loop for a in args ;;doing: check for leading underscore
                         collect (if (or (eq a '&optional)
                                         (eq a '&rest)
                                         (string-match-p "\\(^_\\)\\(.+\\)"
                                                         (symbol-name a))) nil
                                     (intern (format "__%s__" (symbol-name a))))))
         (arg-replacements4 (let (ar)
                              (mapcar (lambda (x) (if (string-match-p "\\(^_\\)\\(.+\\)"
                                                                      (symbol-name x))
                                                      (push (list (strip_ x) (list '\, (strip_ x))) ar)))
                                      
                                      args)
                              ar))
         ;;list of symbols to replace
         ;;format: (symbol replace)
         (let-vars (let (lv) (mapcar* (lambda (a b) (if b
                                                        (push (list a b) lv)))
                                      args-just-vars new-args)
                        lv))
         ;;strip any leading underscores
         (args (mapcar (lambda (a)
                            (if (string-match "\\(^_\\)\\(.+\\)" (symbol-name a))
                              (intern (match-string 2 (symbol-name a))) a))
                              args))
                     
         ;;the __x__ type replacements interfere with the (\, x) type replacements
         ;;so they must be seporated and done one at a time
         (arg-replacements1 let-vars)
         (arg-replacements2 (mapcar (lambda (x)
                                      (list  (intern (format "$%s" x)) (list '\, x)))
                                    args-just-vars))
         (arg-replacements3 (mapcar (lambda (x)
                                      (list (intern (format "$$%s" x)) (list 'quote (list '\, x))))
                                    args-just-vars))
         (arg-replacements (append arg-replacements1 arg-replacements2))

         (current-replace-list nil)
         ;; (arg-replacements (append let-vars
         ;;                           (mapcar (lambda (x)
         ;;                                     (list  (intern (format "$%s" x)) (list '\, x)))
         ;;                                   args)))
         
         (ts ) ;;??
         (valid nil) ;;list of valid arg--types
         (found nil)
         (lets nil)
         var value type all-good var-vals len)
    ;;        (print "possible types = ")
    ;;        (print possible-types)
    
    
    ;;collect all the arg-type--code pairs that are valid possibilities,
    ;;that is, members of possible-types.
    ;;This essentially throws out all the arg types that have been ruled out.
    (dolist (t-s (pyel-expand-type-switch-2 args-just-vars type-switch))
      (if (equal (car t-s) 'and)
          (progn (setq all-good t
                       found nil)
                 (dolist  (x (cadr t-s)) ;;for each 'and' member type-switch
                   (dolist (pos-type possible-types) ;;for each arg type
                     (if (and (equal (eval (car x)) (car pos-type)) 
                              (equal (cadr x) (cdr pos-type)))
                         (setq found t)))
                   (setq all-good (if (and all-good found) t nil)))
                 (when all-good
                   (push t-s valid)))
        ;;else
        (if (eq (car t-s) t) ;;when all types are _
            (push t-s valid)
          ;;otherwise check if the type is one of the valid types
               
          (setq _xx t-s)
          (dolist(pos-type possible-types)
            (when (and (equal (eval (caar t-s)) (car pos-type))
                       (equal (strip$ (cadar t-s)) (cdr pos-type)))
              (push t-s valid))))));;TODO: break if found?
    
    
    
    ;;generate code to call NAME
    ;;if there is 2 posible types, use IF. For more use COND
    (setq len (length valid))
    
    (flet ((replace (code replacements)
                    (let ((ret nil)
                          found)
                      
                      (dolist (c code)
                        (setq found nil)
                        (dolist (r replacements)
                          (if (consp c)
                              (setq c (replace c replacements))
                            (if (and (equal c (car r))
                                     (not found))
                                (progn (push (cadr r) ret)
                                       (setq found t)))))
                        (unless found
                          (push c ret)))
                      (reverse ret)))

           (type-tester (x) (cadr (assoc x pyel-type-test-funcs)))
           (and-type-tester (x) (cadr (assoc (car x) pyel-type-test-funcs)))
           ;;(get-replacement (arg) ;;returns arg replacement
           ;;                 (cadr (assoc arg arg-replacements)))
           (get-replacement (arg) ;;returns arg replacement
                            (cadr (assoc arg current-replace-list)))

           ;;bug fix maybe...
           (get-replacement-OLD (arg) ;;returns arg replacement
                                (or (cadr (assoc arg arg-replacements))
                                    (cadr (assoc arg arg-replacements4))))

           ;;replaces the vars, one type at a time
           (replace-vars (code)
                         (let* ((current-replace-list arg-replacements1)
                                (code (replace code arg-replacements1))
                                (current-replace-list arg-replacements2)
                                (code (replace code arg-replacements2))
                                (current-replace-list arg-replacements3))
                           (replace code arg-replacements3)))
           
           (gen-cond-clause (t-s--c) ;;Type-Switch--Code
                            (if (equal (car t-s--c) 'and)
                                (progn (setq __x t-s--c)
                                       `((and ,@(mapcar '(lambda (x)
                                                           ;;TODO: test
                                                           `(,(type-tester (cadr x))
                                                             ,(get-replacement-OLD
                                                               (car x))))
                                                        (cadr t-s--c)))
                                         ,(replace-vars (caddr t-s--c))))
                              
                              ;;TODO
                              (progn (setq __x t-s--c)
                                     (if (equal (car t-s--c) t) ;;all types where _
                                         `(t ,(replace-vars (cadr t-s--c)))
                                       (let* ((str (symbol-name (cadar t-s--c)))
                                              (quote-arg-p (string-match-p "\\(^\\$\\)\\(.+\\)"
                                                                           str))
                                              (type (if quote-arg-p (intern (match-string 2 str)) (cadar t-s--c)))
                                              (tester (type-tester type))
                                              (body (replace-vars (cadr t-s--c)))
                                              (arg (get-replacement-OLD (caar t-s--c))))
                                         `((,tester ,(if quote-arg-p (list 'quote (list '\, (caar t-s--c))) arg))
                                           ,body))

                                       ))))

           (gen-varlist ()
                        (mapcar (lambda (x) `(,(cadr x) ,(list '\, (car x))))
                                let-vars)
                        ))
      
      (cond ((<= len 0) "ERROR: no valid type")
            ((= len 1)
             (if (eq (caar valid) 'and)
                 ;;; (eval (caddar valid))
                 (caddar valid)
               ;;;(eval  (cadar valid))
               (cadar valid)
               ))
            ;;?TODO: are there possible problems with evaluating the arguments
            ;;       multiple times? Maybe they should be put in a list
            (t (let* ((clauses (mapcar 'gen-cond-clause valid))
                      (clauses (if (eq (caar clauses) t)
                                   clauses
                                 (cons
                                  '(t (error "invalid type, expected <TODO>"))
                                  clauses)))
                      (varlist (gen-varlist)))
                 `(backquote ,(if varlist
                                 `(let ,varlist
                                   (cond ,@(reverse clauses)))
                                `(cond ,@(reverse clauses)))
                               )))))))


(defun call-transform (template-name &rest args)
  "expand TEMPLATE-NAME with ARGS in the same way that `transform' would
if was called as (transform '(template-name args))
NOTE: this calls `transform' on all ARGS, but not TEMPLATE-NAME"
  (eval `(transform '(,template-name ,@(mapcar 'transform args)))))

(defun strip$ (sym)
  (let ((str (symbol-name sym)))
    (if (string-match "\\(^\\$\\)\\(.+\\)" str)
        (intern (match-string 2 str))
      sym)))
(defun strip_ (sym)
  (let ((str (symbol-name sym)))
    (if (string-match "\\(^_\\)\\(.+\\)" str)
        (intern (match-string 2 str))
      sym)))

(defvar pyel-translation-messages nil
  "collects messages during pyel translations")

(defvar pyel-message-formats '((error "ERROR: %s")
                               (warn "WARNING: %s")
                               (recommend "RECOMMENDATION: %s"))
  "alist of message type and their format strings")

(defun pyel-notify (type msg)
  "add MSG to `pyel-translation-messages', TYPE specifies the format string
in `pyel-message-formats'"
  (push (format (or (cadr (assoc type pyel-message-formats))
                    (format "[%s]: %%s" (upcase (symbol-name type))))
                msg) pyel-translation-messages))

(defvar pyel-test-py-functions nil
  "list of generated python test functions.
when `pyel-run-tests' is run, these are translated to e-lisp
and compared to expected values")

(setq _pyel-tests nil)    

(defvar pyel-test-func-counter 0
  "just another counter")
  
(defun pyel-make-test-func-name ()
  (setq pyel-test-func-counter (1+ pyel-test-func-counter)))


(defmacro pyel-create-tests (name &rest py-tests)
  (let ((complete nil)
        (py-ast nil)
        (el-ast nil)
        (c 0)
        ert-tests
        tests
        trans)
    (message "creating tests for '%s'" name)
    (progv
        (mapcar 'car test-variable-values)
        (mapcar 'cadr test-variable-values)
      
      (flet ((pyel-create-new-marker () "test_marker"))
        
        (dolist (test (reverse py-tests))
          (cond ((and (consp test)
                      (>= (length test) 2)
                      (consp (cadr test)))
                 (let* ((tests)  ;;form: ("test" ("test1" result1) ("test2" result2) ...)
                        (name-str (replace-regexp-in-string "-" "_" (symbol-name name)))
                        (test-name (concat "pyel_test_" name-str "_" (number-to-string (pyel-make-test-func-name))))
                        (d 0))
                   
                   (push (setq _x (pyel-functionize (concat (car test)
                                                                  (if (= (length test) 2)
                                                                      (if (and (listp (cadr test))
                                                                               ;;form:  ("setup" ("test" expect))
                                                                               (not (eq (cadr test) 'lambda)))
                                                                                  (concat "\nreturn " (caadr test))
                                                                          ;;form: ("test" expect)
                                                                          (concat "return " (caaddr (cdr test))))
                                                                    ;;form ("setup" ("test1setup" ("test1" result1)) ...)
                                                                    (mapconcat (lambda (x) (concat "\nif n == " (number-to-string (setq d (1+ d))) ":\n"
                                                                                                   (if (and (listp (cadr x))
                                                                                                            ;;form:  ("setup" ("test" expect))
                                                                                                            (not (eq (caadr x) 'lambda)))
                                                                                                       (concat (pyel-indent-py-code (car x)) "\n"
                                                                                                               (concat " return " (caadr x)))
                                                                                                     ;;form: ("test" expect)
                                                                                                       (concat " return " (car x)))))
                                                                               (cdr test) "\n")))
                                                    test-name (if (= (length test) 2) nil "n")))
                         pyel-test-py-functions)
                   (setq d 0)
                   (mapc (lambda (x)
                           (push `(ert-deftest
                                      ,(intern (concat "pyel-" name-str
                                                       (number-to-string (setq c (1+ c))))) ()
                                    (should (equal (eval (pyel ,(if (= (length test) 2)
                                                                    (format "%s()" test-name)
                                                                  (format "%s(%s)" test-name (setq d (1+ d))))))
                                                   ,(cadr x))))
                                 tests))
                         (cdr test))
                   (setq _pyel-tests (append _pyel-tests (reverse tests)))
                   ))
                
              ((consp test) ;;form: ("test" expect)
               (push `(ert-deftest
                            ,(intern (concat "pyel-" (symbol-name name)
                                             (number-to-string (setq c (1+ c))))) ()
                          (should (equal (eval (pyel ,(concat (pyel-functionize (car test))
                                                              "\nf()")))
                                         ,(cadr test))))
                       _pyel-tests))
            
              (t (progn ;;form "test"
                   ;;check complete code transformation
                   (setq trans (pyel test))
                   (push `(push '(should (equal
                                          (pyel ,test)
                                          ',trans))
                                pyel-transform-tests)
                         _pyel-tests)
                   ;;check python ast
                   (push `(push '(should (equal (py-ast ,test)
                                                ,(py-ast test)))
                                pyel-py-ast-tests)
                         _pyel-tests)
                   
                   ;;check transformed .py syntax tree
                   (push `(push '(should (string= (pyel ,test t)
                                                  ,(pyel test t)))
                                pyel-el-ast-tests)
                         _pyel-tests))
          )))))))

(defun pyel-create-tests-with-known-types (name known-types &rest py-code)
  "just like `pyel-create-tests-with-known-types' fakes the known types during the tests"
  ;;99% of the code is the same...
  (let ((complete nil)
        (py-ast nil)
        (el-ast nil)    
        trans)
    (progv
        (mapcar 'car test-variable-values)
        (mapcar 'cadr test-variable-values)

      
      (dolist (code (reverse py-code))
        ;;check complete code transformation
        (setq trans (pyel-with-known-types known-types code))
        (push `(should (equal
                        (pyel-with-known-types ',known-types ,code)
                        ',trans))
              complete)
        ;;check pure .py syntax tree
        (push `(should (equal (py-ast ,code)
                              ,(py-ast code)))
              py-ast)
        ;;check transformed .py syntax tree
        (push `(should (string= (pyel ,code t)
                                ,(pyel code t)))
              el-ast))
      
      (kill-new (pp-to-string `(ert-deftest ,(intern (concat "pyel-" (symbol-name name) "-full-transform"))
                                   () ,@complete)))
      (kill-append (pp-to-string `(ert-deftest ,(intern (concat "pyel-" (symbol-name name) "-py-ast"))
                                      () ,@py-ast)) nil)

      (kill-append (pp-to-string `(ert-deftest ,(intern (concat "pyel-" (symbol-name name) "-el-ast"))
                                      () ,@el-ast)) nil)
      (message "Tests copied to kill ring"))))

(defun pyel-indent-py-code (code &optional indent)
  "Indent CODE by INDENT. CODE is a string. INDENT defaults to one space"
  (let ((indent (or indent " ")))
    (mapconcat 'identity (mapcar (lambda (x) (concat indent x))
                                 (split-string code "\n"))
               "\n")))

(defun pyel-generate-tests ()
  (interactive)
  ;;read in tests from pyel-tests.el
  ;;save resulting tests in  pyel-tests-generated.el
  ;;evaluate all the tests
  (let ((pyel-test-func-counter 0)
        pyel-transform-tests
        pyel-py-ast-tests
        pyel-el-ast-tests
        pyel-test-py-functions
        _pyel-tests
        )

    (load-file (file-path-concat pyel-directory "pyel-tests.el"))
    (with-temp-buffer
      
      ;;save py test functions
      (insert (format "(setq pyel-test-py-functions '%s)"
                      (prin1-to-string pyel-test-py-functions)))
      

      ;;insert ert tests and collect the others
      (mapc (lambda (x)
              (if (eq (car x) 'ert-deftest)
                  (insert (prin1-to-string x) "\n")
                (eval x))) 
            _pyel-tests)

      ;;how insert the other tests
      (mapc 
       (lambda (x) (insert (format "(setq %s '%s)"
                                   (symbol-name x)
                                   (prin1-to-string (eval x)))))
       '(pyel-transform-tests
         pyel-py-ast-tests
         pyel-el-ast-tests
         ))
      
      (insert "\n(provide 'pyel-tests-generated)")
      
      (write-file (file-path-concat pyel-directory "pyel-tests-generated.el")))))

(defalias 'pyel-verify 'pyel-run-tests)
(defun pyel-run-tests ()
  (interactive)
  (flet ((pyel-create-new-marker () "test_marker"))
    (progv
        (mapcar 'car test-variable-values)
        (mapcar 'cadr test-variable-values)
      (let ((_ (message "Running transform tests..."))
            (transform-passed (reduce '+ (mapcar (lambda (test)
                                                   (if (condition-case nil
                                                           (eval test)
                                                         (error nil)) 1 0))
                                                 pyel-transform-tests)))
            (_ (message "Running python AST tests..."))
            (py-ast-passed (reduce '+ (mapcar (lambda (test)
                                                (if (condition-case nil
                                                        (eval test)
                                                      (error nil)) 1 0))
                                              pyel-py-ast-tests)))
            (_ (message "Running lisp AST tests..."))
            (el-ast-passed (reduce '+ (mapcar (lambda (test)
                                                (if (condition-case nil
                                                        (eval test)
                                                      (error nil)) 1 0))
                                              pyel-el-ast-tests))))
        (message "transform: %s/%s\npy-ast: %s/%s\nel-ast: %s/%s\n"
                 transform-passed (length pyel-transform-tests)
                 py-ast-passed (length pyel-py-ast-tests)
                 el-ast-passed (length pyel-el-ast-tests))
        (message "Evaluating test functions...")
        (mapc (lambda (x) (eval (pyel x))) pyel-test-py-functions)
        (message "Running ert tests...")
        (ert-run-tests-interactively "pyel")
        ))))

(defun pyel-run-ert-tests ()
  (interactive)
  (flet ((pyel-create-new-marker () "test_marker"))
    (progv
        (mapcar 'car test-variable-values)
        (mapcar 'cadr test-variable-values)
      
        (mapc (lambda (x) (eval (pyel x))) pyel-test-py-functions)
        (ert-run-tests-interactively "pyel"))))

(defun pyel-functionize (py-code &optional func-name &rest args)
  "wrap PY-CODE in a function definition
FUNC-NAME defaults to 'f'"
  (concat  "def " (or func-name "f") (if args (format "(%s)" (mapconcat 'identity args ", ")) "()") ":\n"
           (mapconcat 'identity (mapcar (lambda (x) (concat " " x))
                                        (split-string py-code "\n"))
                      "\n")))

(defun char-split-string (string)
  "split a string into its charaters"
  (cdr (butlast (split-string string ""))))


(defun strip-end (string &optional char)
  "if CHAR occurs at the end of STRING, remove it"
  (let ((split (char-split-string string))
        (char (or char " ")))

    (while (string= char (car (last split)))
      (setq split (butlast split)))
    (mapconcat 'identity split "")))

(defun strip-start (string &optional char)
  "if CHAR occurs at the beginning of STRING, remove all occurrences"
  (let ((split (char-split-string string))
        (char (or char " ")))
    
    (while (string= char (car split))
      (setq split (cdr split)))
    (mapconcat 'identity split "")))

;;built-in equivalent?
(defun file-path-concat (&rest dirs)
  "concatenate strings representing file paths
prevents multiple/none '/' seporating file names"
  (let* ((first (strip-end (car dirs) "/"))
         (last (strip-start (car (last dirs)) "/"))
         (dirs (append (list first)
                       (mapcar '(lambda (x)  (strip-start (strip-end x "/") "/")) 
                               (cdr (butlast dirs)))
                       (list last))))
    (mapconcat 'identity dirs "/")))

(require 'transformer)
(require 'pyel-transforms)
(require 'pyel-tests-generated)
(require 'pyel-preprocessor)  

(require 'pyel-mode)

(provide 'pyel)
;;pyel.el ends here

(setq pyel-use-list-for-varargs t)
;;(setq pyel-directory "path/to/pyel/directory")
;;(require 'pyel)
